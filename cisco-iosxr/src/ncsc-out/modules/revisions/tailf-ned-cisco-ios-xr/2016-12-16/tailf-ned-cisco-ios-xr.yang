module tailf-ned-cisco-ios-xr {
  // Generated by yanger -t ncs
  tailf:ncs-device-type cli-ned;

  namespace "http://tail-f.com/ned/cisco-ios-xr";
  prefix cisco-ios-xr;

  import tailf-common {
    prefix tailf;
  }
  import ietf-inet-types {
    prefix inet;
  }
  import tailf-ncs {
    prefix ncs;
  }

  revision 2016-12-16 {
    description
      "4.6.2
       See CHANGES.
      ";
  }
  revision 2016-12-09 {
    description
      "4.6.1
       See CHANGES.
      ";
  }
  revision 2016-12-02 {
    description
      "4.6.0
       See CHANGES.
      ";
  }
  revision 2016-11-18 {
    description
      "4.5.2
       See CHANGES.
      ";
  }
  revision 2016-11-11 {
    description
      "4.5.1
       See CHANGES.
      ";
  }
  revision 2016-11-08 {
    description
      "4.5
       See CHANGES.
      ";
  }
  revision 2016-10-28 {
    description
      "4.4.6
       See CHANGES.
      ";
  }
  revision 2016-10-21 {
    description
      "4.4.5
       See CHANGES.
      ";
  }
  revision 2016-10-14 {
    description
      "4.4.4
       See CHANGES.
      ";
  }
  revision 2016-10-10 {
    description
      "4.4.3
       See CHANGES.
      ";
  }
  revision 2016-09-25 {
    description
      "4.4.2
       See CHANGES.
      ";
  }
  revision 2016-09-16 {
    description
      "4.4.1
       See CHANGES.
      ";
  }
  revision 2016-09-09 {
    description
      "4.4
       See CHANGES.
      ";
  }
  revision 2016-09-02 {
    description
      "4.3.9
       See CHANGES.
      ";
  }
  revision 2016-08-26 {
    description
      "4.3.8
       See CHANGES.
      ";
  }
  revision 2016-08-19 {
    description
      "4.3.7
       See CHANGES.
      ";
  }
  revision 2016-08-12 {
    description
      "4.3.6
       See CHANGES.
      ";
  }
  revision 2016-08-05 {
    description
      "4.3.5
       See CHANGES.
      ";
  }
  revision 2016-07-22 {
    description
      "4.3.4
       See CHANGES.
      ";
  }
  revision 2016-07-15 {
    description
      "4.3.3
       See CHANGES.
      ";
  }
  revision 2016-06-30 {
    description
      "4.3.2
       See CHANGES.
      ";
  }
  revision 2016-06-24 {
    description
      "4.3.1
       See CHANGES.
      ";
  }
  revision 2016-06-17 {
    description
      "4.3
       See CHANGES.
      ";
  }
  revision 2016-06-10 {
    description
      "4.2
       See CHANGES.
      ";
  }
  revision 2016-06-03 {
    description
      "4.1.7
       See CHANGES.
      ";
  }
  revision 2016-05-26 {
    description
      "4.1.6
       See CHANGES.
      ";
  }
  revision 2016-05-20 {
    description
      "4.1.5
       See CHANGES.
      ";
  }
  revision 2016-05-12 {
    description
      "4.1.4
       See CHANGES.
      ";
  }
  revision 2016-04-29 {
    description
      "4.1.3
       See CHANGES.
      ";
  }
  revision 2016-04-06 {
    description
      "4.1.2
       See CHANGES.
      ";
  }
  revision 2016-03-30 {
    description
      "4.1.1
       See CHANGES.
      ";
  }
  revision 2016-03-14 {
    description
      "4.1.0.3
       Enhancements:
       Support for EXEC proxy login configuration, which can be used to access
        a device through a terminal server which requires extra command.
        Configure cisco-iosxr-proxy-settings under ned-settings to enable.
        See README file for example.
         (IOSXR-15)
       Corrections:
       API CHANGE: router static / address-family ipv4|ipv6 unicast / *
       Did not support multiple entries in combo of net,interface and ip.
        (RT22185)
      ";
  }
  revision 2016-03-07 {
    description
      "4.1.0.2
       Enhancements:
       Do not log telnet login password in trace.
       Support for SSH/TELNET proxy login configuration.
        Configure cisco-iosxr-proxy-settings under ned-settings to enable.
        See new README file for example.
       Corrections:
       Fixed null pointer exception with no-statements in set's.
        (RT22047)
      ";
  }
  revision 2016-02-12 {
    description
      "4.1.0.1
       Enhancements:
       Additions to the YANG model:
        bfd / interface * / echo
        router ospf * / area * / fast-reroute per-prefix
        router ospf * / area * / stub
        router ospf * / area * / multi-area-interface *
         (RT21731)
        router isis * / address-family * / ispf level
         (RT21759)
        router hsrp / interface * / hsrp delay
         (RT21791)
       Corrections:
      ";
  }
  revision 2016-01-08 {
    description
      "4.1
       Enhancements:
       Additions to the YANG model:
        router ospf * / authentication
        router ospf * / message-digest-key
        router ospf * / timers pacing
        line * / escape-character
        router bgp * / address-family * / distance
        router bgp * / address-family ipv6 multicast
        router bgp * / neighbor * / address-family ipv6 multicast
        router bgp * / neighbor * / address-family ? / default-originate route-policy
        router bgp / bgp graceful-restart graceful-reset
        router bgp * / session-group * / use
        domain ipv4
        ntp server * key
        ntp authentication-key *
        ntp authenticate
        ntp trusted-key
        dhcp ipv4 / profile * / relay
        flow monitor-map * / record mpls
        flow monitor-map * / cache entries
        flow monitor-map * / cache timeout inactive
        flow monitor-map * / cache timeout rate-limit
        flow monitor-map * / cache timeout update
        as-path-set ios-regex
        mpls ldp / address-family ipv4 / label / local / advertise / disable
        l2vpn / bridge group * / bridge-domain * / flooding
        logging host * port
        ipv6 conflict-policy
        ipv6 prefix-list *
       Corrections:
        Replaced custom type ipv6-prefix with
        tailf:ipv6-address-and-prefix-length. This will take advantage of NCS
        built-in canonicalization of ipv6 addresses (i.e. case-insensitivity +
        compression).
      ";
  }
  revision 2015-12-22 {
    description
      "4.0.1.3
       Enhancements:
       Additions to the YANG model:
        l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / route-target *
        l2vpn / xconnect group * / mp2mp * / auto-discovery bgp / signaling-protocol
        l2vpn / xconnect group * / mp2mp * / control-word
        l2vpn / xconnect group * / mp2mp * / l2-encapsulation
        l2vpn / xconnect group * / mp2mp * / mtu
        l2vpn / xconnect group * / mp2mp * / vpn-id
        l2vpn / xconnect group * / p2p * / neighbor * / tag-impose
      ";
  }
  revision 2015-12-09 {
    description
      "4.0.1.2
       Enhancements:
       Additions to the YANG model:
        interface * / ethernet cfm / ais
        interface tunnel-te* / autoroute destination *
        interface tunnel-te* / forward-class
        interface tunnel-mte*
        multicast-routing / address-family ipv4 / mdt data p2mp-te
        multicast-routing / address-family ipv4 / mdt default p2mp-te
        multicast-routing / address-family ipv4 / bgp
        router pim / address-family ipv4 / rpf
        router pim / address-family ipv4 / mdt
        ethernet cfm / domain * / service * / continuity-check interval loss-threshold
        ethernet cfm / domain * / service * / continuity-check archive
        ethernet cfm / domain * / service * / continuity-check loss
        ethernet cfm / domain * / service * / log ais
        ethernet cfm / domain * / service * / log crosscheck
        l2vpn / pw-class * / encapsulation mpls / preferred-path fallback
        mpls traffic-eng / attribute-set p2mp-te *
       
       Corrections:
       Changed 'ethernet cfm / domain * / service * / continuity-check interval'
       to container to be able to model containers archive and loss within
       continuity-check
      ";
  }
  revision 2015-12-07 {
    description
      "4.0.1.1
       Enhancements:
       Additions to the YANG model:
        router ospf * / area * / dead-interval
        router ospf * / distance ospf
        router ospf * / redistribute isis *
        router isis * / address-family * / mpls ldp sync level
        router isis * / address-family * / redistribute ospf
        router isis * / address-family * / redistribute ospfv3
        class-map * / match dei
        interface tunnel-te* / affinity-value
        interface tunnel-te* / path-option * attribute-set
        interface tunnel-te* / path-option * protected-by
        router bgp * / timers
        router bgp / bgp bestpath as-path
        multicast-routing / address-family ipv4 / interface-inheritance
        router pim / address-family ipv4 / interface * / enable
        explicit-path identifier *
        nv / satellite * / description
        nv / satellite * / secret
        snmp-server packetsize
        snmp-server ipv4 precedence
        snmp-server interface *
        spanning-tree mst * / instance * / vlan-ids
        hw-module mac-move
        router isis * / interface * / hello-interval
        mpls traffic-eng / interface * / attribute-flags
        mpls traffic-eng / interface * / backup-path
        mpls traffic-eng / attribute-set
        mpls ldp / address-family ipv4 / label / local / advertise
       
       Added enum value 'disable' to severity-type
       
       Corrections:
       Moved container bfd from non-subinterface-common-grouping to new grouping
       interface-bfd-grouping to be able to model interface
       tunnel-te correctly
       
       Added 'ordered-by user' to 'policy-map * / class *'
      ";
  }
  revision 2015-11-25 {
    description
      "4.0.1
       Enhancements:
       Merged to master branch. Release 4.0.1.
       Corrections:
      ";
  }
  revision 2015-11-23 {
    description
      "4.0.0.5
       Enhancements:
       Expanded YANG model in:
        ipsla
       Additions to the YANG model:
        dhcp ipv4 / profile * / giaddr policy
        ethernet cfm / domain * / service * down-meps
        ethernet cfm / domain * / service * / mep crosscheck
        forward-protocol udp *
        ftp client password
        ftp client username
        multicast-routing / address-family ipv4 / mdt source
        performance-mgmt statistics
        router bgp * / address-family ipv4 multicast
        router ospf * / redistribute connected
        router-convergence / collect-diagnostics *
        rpl editor
        (RT20884)
       The NED is now configurable regarding the max number of command lines it
        shall send in a chunk to the device. Default is 100.
        A higher number usually gives better performance but can also
        have negative impact on the NEDs error detection ability. If an error
        occurs in the middle of the 'chunk' the execution will continue with the
        remaining lines. This can result in that for instance a config leaf is
        accidentally set.
       
        Note, the cisco-iosxr NED was previously hard coded to send chunks of
        1000 commands at a time.
       
        To set to one command per chunk, do as follows in the NCS/NSO CLI:
         $ devices device <name> ned-settings cisco-iosxr-number-of-lines-to-send-in-chunk 1
         $ commit
       Corrections:
        Fixed problem when config error and abort, dead locking ncs.
      ";
  }
  revision 2015-11-10 {
    description
      "4.0.0.4
       Enhancements:
       Additions to the YANG model:
        l2vpn / bridge group * / bridge-domain * / vfi * / autodiscovery bgp /
         signaling-protocol
        interface * / nv / edge / interface
        l2vpn / autodiscovery bgp / signaling-protocol bgp
        mirror location *
        ospf name-lookup
        router bgp * / neighbor * / local-as
        router mld / vrf *
        router ospf * / ignore lsa mospf
        router ospf * / passive
        router ospf * / queue limit
        router static / maximum path
        taskgroup * / task debug *
       Corrections:
       router ospf * / default-information
      ";
  }
  revision 2015-11-02 {
    description
      "4.0.0.3
       Enhancements:
       Corrections:
       Removed choice from router bgp * / neighbor * / use neighbor-group
        and use session-group.
       (RT20723)
      ";
  }
  revision 2015-10-26 {
    description
      "4.0.0.2
       Enhancements:
       Additions to the YANG model:
        evpn / evi * / network-controller / host * / ipv4 address
        interface nve *
        l2vpn / bridge group * / bridge-domain * / member vni *
        l2vpn / router-id
        router bgp * / address-family * / advertise vpnv4|vpnv6 unicast
        neighbor * / address-family ? / import
        router bgp * / address-family * / label mode
        router bgp * / neighbor * /  ignore-connected-check
        vrf * / address-family ipvX unicast / XXport route-target / * stitching
       Corrections:
       Added netmask leaf: evpn / evi * / network-controller / host * / gateway
      ";
  }
  revision 2015-10-20 {
    description
      "4.0.0.1
       Enhancements:
       Additions to the YANG model:
        interface FortyGigE
        router ospf * / distribute-list
        router static / address-family ipv4 unicast / * vrf *
       Corrections:
      ";
  }
  revision 2015-09-30 {
    description
      "4.0
       Enhancements:
       Merged to master branch. Release 4.0.
       Corrections:
      ";
  }
  revision 2015-09-28 {
    description
      "3.11.0.8
       Enhancements:
       Corrections:
       Changed interface IPv4 address api. (RT20158)
      ";
  }
  revision 2015-09-21 {
    description
      "3.11.0.7
       Enhancements:
       Additions to the YANG model:
        interface * / encapsulation dot1ad * exact
       Corrections:
       Ignore trailing characters after end delimiter in banners.
      ";
  }
  revision 2015-09-16 {
    description
      "3.11.0.6
       Enhancements:
       Expanded segment routing support.
       Additions to the YANG model:
        interface tunnel-te* / path-selection / segment-routing adjacency
        mpls traffic-eng / auto-tunnel pcc / tunnel-id
        router bgp * / address-family link-state link-state
        router ospf * / segment-routing
       Corrections:
      ";
  }
  revision 2015-09-14 {
    description
      "3.11.0.5
       Enhancements:
       Implemented basic support for segment routing.
       Additions to the YANG model:
        icmp ipv4 rate-limit unreachable
        l2vpn / bridge group * / bridge-domain * / neighbor * / split-horizon
        mpls traffic-eng / interface * / attribute-names
        mpls traffic-eng / interface * / admin-weight
        mpls traffic-eng / pce
        router isis * / address-family * / segment-routing
        router isis * / interface * / address-family ipv4 unicast / prefix-sid
        segment-routing / global-block
       Corrections:
       Fixed yet another bug with reading/writing banners.
       Dirty 'mpls traffic-eng / auto-tunnel backup' fix
      ";
  }
  revision 2015-09-09 {
    description
      "3.11.0.4
       Enhancements:
       EPN 4.0 support for MEF and TI (Transport infrastructure).
       Additions to the YANG model:
        ethernet cfm / traceroute cache
        ipv4 prefix-list *
        l2vpn / pw-class * / encapsulation mpls / redundancy
        l2vpn / redundancy
        logging disable
       Expanded the YANG model in:
        mpls ldp
        router bgp
        router isis
       Corrections:
       clock-interface / frequency synchronization / quality
       Quote and dequote description strings.
      ";
  }
  revision 2015-08-25 {
    description
      "3.11.0.3
       Enhancements:
       Additions to the YANG model:
        router vrrp / interface * / address-family ipv6 / vrrp * / address linklocal
       Expanded the YANG model in:
        spanning-tree mst *
       Corrections:
      ";
  }
  revision 2015-08-20 {
    description
      "3.11.0.2
       Enhancements:
       Additions to the YANG model:
        class-map * / match vpls
        controller E3 *
        explicit-path name * / index * next-label
        interface FastEthernet*
        interface POS* (subinterface)
        interface * / dot1ad
        interface * / flow-control
        l2vpn / bridge group * / bridge-domain * / mac / learning
        l2vpn / bridge group * / bridge-domain * / pbb / edge *
        l2vpn / pw-class * / encapsulation mpls / preferred-path
        line * / secret
        mpls ldp / session protection
        multicast-routing / vrf *
        ntp interface * / broadcast
        policy-map * / class * / police * / child-conform-aware
        router bgp / bgp auto-policy-soft-reset disable
        router bgp / default-information originate
        router bgp / neighbor * / address-family ? / site-of-origin
        router pim / vrf *
        snmp-server entityindex
       Expanded the YANG model in:
        controller E1 *
        controller SONET *
        interface * / service-policy
        policy-map * / class * / random-detect
       Corrections:
       Changed network-controller / switch * from container to list.
       Corrected interface * / dot1q vlan, added second vlan id. API change.
       Use 'show version' if 'show version brief' fails in login check.
       Fixed regexp for exec commands when prompted to continue. [RT 19832]
       Fixed dependency problem when delete of class-map. [RT 19802]
      ";
  }
  revision 2015-07-17 {
    description
      "3.11.0.1
       Enhancements:
       Additions to the YANG model:
        router bgp * / neighbor * / ttl-security
       Corrections:
      ";
  }
  revision 2015-06-23 {
    description
      "3.10.0
       Enhancements:
       Support for NSO-4.0 (note: NSO is new name for NCS)
       The NED is now compliant with NSO 4.0 regarding registering
        platform information. Use this command to see:
         admin@ncs# show devices device platform
       Additions to the YANG model:
        evpn / evi *
        evpn / network-controller
        l2vpn / bridge group * / bridge-domain * / evpn evi
        router bgp * / address-family l2vpn evpn
        router bgp * / neighbor * / address-family l2vpn evpn
       Corrections:
       logging console disable always became logging console alerts
       Changed logging host * type to union of IPv4/IPv6 address.
      ";
  }
  revision 2015-06-12 {
    description
      "3.9.0.10
       Enhancements:
       Expanded controller SONET config.
        (RT 19125)
       Additions to the YANG model:
        snmp-server vrf *
        spanning-tree mst *
        control-plane / management-plane / out-of-band / interface * / ..
          allow * peer / address ipv4 *
       Corrections:
       Fixed bug with reading/writing banners.
      ";
  }
  revision 2015-05-15 {
    description
      "3.9.0.9
       Enhancements:
       Additions to the YANG model:
        bfd / interface *
        bfd / multihop|multipath
        class-map * / match source-address ipv4 *
        interface * / affinity include *
        interface * / affinity include-strict *
        line * / telnet transparent
        policy-map * / class * / random-detect default
        router bgp * / neighbor * / enforce-first-as
        router ospf * / mpls ldp auto-config
       Corrections:
       Updated class-map * / match protocol values.
       Updated policy-map * / class * / redirect nexthop
      ";
  }
  revision 2015-05-11 {
    description
      "3.9.0.8
       Enhancements:
       Added basic support for BGP flowspec.
       Additions to the YANG model:
        class-map * / match destination-address ipv4 *
        class-map * / match destination-port
        class-map type traffic
        flowspec / address-family ipv4 / service-policy
        interface * / encapsulation ambiguous dot1q
        interface * / service-policy input|output * subscriber-parent
        l2vpn / bridge group * / bridge-domain * / interface * / split-horizon
        netconf-yang agent ssh
        policy-map type
        policy-map * / class type traffic *
        policy-map * / class * / redirect nexthop
        router bgp * / address-family ipv4 flowspec
        router bgp * / address-family vpnv4 flowspec
        router bgp * / neighbor * / address-family ipv4 flowspec
        vrf * / address-family ipv4 flowspec
        xml agent / iteration
       Corrections:
       Fixed problem with replacing interface * / service-policy (API change!)
      ";
  }
  revision 2015-04-28 {
    description
      "3.9.0.7
       Enhancements:
       Additions to the YANG model:
        interface tunnel-te* / autoroute metric
        interface tunnel-te* / load-share
       Corrections:
       Fixed problems with the new annotation in description leaves.
      ";
  }
  revision 2015-04-23 {
    description
      "3.9.0.6
       Enhancements:
       Added 'IOS XR Configuration' version number to 'version' leaf.
       Corrections:
       Added 'tailf:cli-preformatted' to all description leaves to suppress
        quoting of non-config elements when displaying them.
      ";
  }
  revision 2015-04-21 {
    description
      "3.9.0.5
       Enhancements:
       Corrections:
       Fixed interface * / encapsulation dot1q|dot1ad vlan ranges.
      ";
  }
  revision 2015-04-17 {
    description
      "3.9.0.4
       Enhancements:
       Added NCS version and NETSIM confd&NED version in ned trace.
       Additions to the YANG model:
        vrf * / vpn id
        router bgp * / address-family * / bgp dampening
        router ospf * / area * / nssa
       Corrections:
      ";
  }
  revision 2015-04-08 {
    description
      "3.9.0.3
       Enhancements:
       Additions to the YANG model:
        l2vpn / bridge group * / bridge-domain * / neighbor * / storm-control
        router isis * / address-family * / redistribute connected
        router isis * / address-family * / advertise passive-only
       Corrections:
      ";
  }
  revision 2015-03-25 {
    description
      "3.9.0.2
       Enhancements:
       Additions to the YANG model:
        igmp snooping profile *
        interface * / nv / satellite-fabric-link # / redundancy
        l2vpn / bridge group * / bridge-domain * / igmp snooping
        l2vpn / bridge group * / bridge-domain * / storm-control
        mpls ldp / neighbor / * password
        mpls ldp / address-family ipv4
        nv / satellite * / redundancy
        nv / satellite * / serial-number
        redundancy / iccp / group * / backbone
        redundancy / iccp / group * / nv satellite
        .. and more minor additions ..
       Corrections:
      ";
  }
  revision 2015-03-18 {
    description
      "3.9.0.1
       Enhancements:
       Expanded and improved controller SONET config.
       Additions to the YANG model:
        cem
        controller E1 *
        ethernet sla
        ethernet cfm
        interface ATM *
        interface CEM *
        interface * / ethernet cfm
        ipsla / operation *
        ipsla / schedule operation *
         .. and more minor additions ..
        router bgp / neighbor / address-family / send-extended-community-ebgp
       Corrections:
       Fixed bug in l2vpn / bridge group * / bridge-domain * / routed interface
      ";
  }
  revision 2015-03-12 {
    description
      "3.8.0
       Enhancements:
       Support for NCS-3.4.
       Corrections:
      ";
  }
  revision 2015-02-19 {
    description
      "3.7.0.1
       Enhancements:
       - Added support for generic-interface-list / interface config.
        (#12557 / RT17938)
       Corrections:
      ";
  }
  revision 2015-02-11 {
    description
      "3.6.0
       Enhancements:
       Corrections:
      ";
  }
  revision 2015-02-11 {
    description
      "3.5.0.9
       Enhancements:
       Corrections:
       Bugfixed copy and reload commands under live-status exec.
       More work on prompt matching in java code.
      ";
  }
  revision 2015-02-10 {
    description
      "3.5.0.8
       Enhancements:
       Corrections:
       Improved prompt matching in java code to avoid deadlock when setting
        complex descriptions (e.g. with '#' and '(' etc).
      ";
  }
  revision 2015-02-09 {
    description
      "3.5.0.7
       Enhancements:
       Expanded router bgp.
       Added traceroute, copy and reload commands under live-status exec.
       Corrections:
      ";
  }
  revision 2015-02-04 {
    description
      "3.5.0.6
       Enhancements:
       Implemented basic support for router hsrp.
       Added timer config in bfd address-family ipv4 interface config.
       Added route-policy config to vrf address-family export/import.
       Corrections:
      ";
  }
  revision 2015-01-19 {
    description
      "3.5.0.5
       Enhancements:
       Expanded rewrite ingress tag sub-interface config.
       Added level option to isis router metric config.
       Added signalled-name to interface tunnel-te config.
       Corrections:
      ";
  }
  revision 2015-01-14 {
    description
      "3.5.0.4
       Enhancements:
       Expanded interface tunnel-te config.
       Corrections:
      ";
  }
  revision 2014-12-19 {
    description
      "3.5.0.3
       Enhancements:
       Added domain list config.
       Expanded ospf and ospfv3 config.
       Added generic snmp-server traps list accepting all entries.
       Corrections:
       Removed all 'tailf:cli-no-keyword' on non policy-map config.
      ";
  }
  revision 2014-12-10 {
    description
      "3.5.0.2
       Enhancements:
       Added support for explicit-path config.
       Corrections:
      ";
  }
  revision 2014-12-08 {
    description
      "3.5.0.1
       Enhancements:
       Added ping and clear exec commands under live-status, e.g.:
        devices device asr9k live-status exec ping 192.168.1.1
        devices device asr9k live-status exec clear ppp queues
       Added PW-Ether interface and sub-interface. (RT 17184)
       Send initial newline to device for terminal support. (RT 16500)
       Corrections:
       Strip no commands inside extcommunity-set, rd-set, prefix-set,
        as-path-set and community-set on real devices. (RT 17090)
      ";
  }
  revision 2014-11-26 {
    description
      "3.4.0
       Enhancements:
       The method to use by the NED for calculating transaction ID is now a
        configurable option.
        The config option cisco-iosxr-transaction-id-method is available under:
         /ncs:devices/global-settings/ned-settings/
         /ncs:devices/ncs:profiles/profile:cisco-iosxr/ned-settings/
         /ncs:/device/devices/device:<dev name>/ned-settings/
        Two values are supported:
         config-hash (default) : Use a snapshot of the running config for
                                 calculation.
         commit-list :           Use the configuration commit list time of
                                 the latest commit for calculation.
       Implemented support for 'crypto key' exec commands under live-status,
        e.g.: devices device asr9k live-status exec crypto key generate rsa
       Expanded router ospf, router pim, router igmp and router static.
       Numerous YANG model expansions in various areas.
       Implemented basic support for router ospfv3.
       YANG data model updates: class-map / match vlan
       YANG data model updates: l2vpn
       Corrections:
       Fixed two problem with class-map / match dscp, ordering and ipv4/ipv6.
      ";
  }
  revision 2014-10-16 {
    description
      "3.2.0
       Master merge and release.
      ";
  }
  revision 2014-10-15 {
    description
      "3.0.1.6
       Expanded router isis / interface *
       Added interface * / transport-mode
       Expanded snmp-server user *
       Various new config items supported.
      ";
  }
  revision 2014-10-12 {
    description
      "3.0.1.5
       Expanded router isis and router bgp.
       Reworked broken route-policy to single quoted string.
       Expanded path-option in tunnel-te interface.
      ";
  }
  revision 2014-10-09 {
    description
      "3.0.1.4
       Added version string in NED trace.
       Expanded router pim address family config.
      ";
  }
  revision 2014-09-30 {
    description
      "3.0.1.3
       Added isis and ospf to router bgp address family redistribute config.
       Expanded router bgp config.
      ";
  }
  revision 2014-09-15 {
    description
      "3.0.1.2
       Major config expansion in numerous areas all over, mainly routing.
       Expanded l2vpn bridge domain config settings.
       Implemented support for show commands under live-status exec show, e.g.
        devices device asr9k live-status exec show running-config interface Loopback0
      ";
  }
  revision 2014-08-22 {
    description
      "3.0.1.1
       Expanded RSVP config.
       Enabled transaction ID's unique string, restoring check-sync.
       Implemented support for multiple secondary ipv4 addresses in interface.
       Implemented l2vpn / xconnect / mp2mp / autodiscovery / bgp / rd
         skeleton config to avoid matching top level rd-set.
      ";
  }
  revision 2014-06-05 {
    description
      "Additional config supported for Ethernet/Frame Relay Bundled Service
       and Ethernet MPLS L2VPN.
      ";
  }
  revision 2014-02-18 {
    description
      "Additional config supported";
  }
  revision 2014-02-17 {
    description
      "Added support for route-policy in router bgp / vrf / address-family";
  }
  revision 2014-01-27 {
    description
      "Added 'mpls static' config
       Added 'interface tunnel-ip' config
       Added 'tailf:cli-explicit-exit' to top containers
       Changed references to interface(s) to non-strict leafrefs";
  }
  revision 2014-01-16 {
    description
      "Additional config supported";
  }
  revision 2013-12-19 {
    description
      "Additional config supported and bugfixes";
  }
  revision 2013-12-11 {
    description
      "Cleanup, improvements and bugfixes";
  }
  revision 2013-08-20 {
    description
      "Renamed YANG module, submodule and namespace.
       First revision statement added.
      ";
  }

  typedef aaa-group-type {
    type union {
      type string {
        tailf:info "WORD;;Server-group name";
      }
      type enumeration {
        enum ldap {
          tailf:info "Use list of all LDAP hosts.";
        }
        enum radius {
          tailf:info "Use list of all Radius hosts.";
        }
        enum tacacs+ {
          tailf:info "Use list of all Tacacs+ hosts.";
        }
      }
    }
  }

  typedef vrf-type {
    type union {
      type string {
        tailf:info "WORD;;Name of VRF";
      }
      type enumeration {
        enum default {
          tailf:info "Default vrf";
        }
      }
    }
  }

  typedef control-plane-proto {
    type enumeration {
      enum HTTP {
        tailf:info HTTP(S);
      }
      enum NETCONF {
        tailf:info "NETCONF version 1.1 protocol";
      }
      enum SNMP {
        tailf:info "SNMP (all versions)";
      }
      enum SSH {
        tailf:info "Secure Shell (v1 & v2)";
      }
      enum TFTP {
        tailf:info "Enable TFTP";
      }
      enum Telnet {
        tailf:info Telnet;
      }
      enum XML {
        tailf:info XML;
      }
      enum all {
        tailf:info "All Protocols";
      }
    }
  }

  typedef operator-type {
    type enumeration {
      enum eq {
        tailf:info "Equal to";
      }
      enum ge {
        tailf:info "Greater than or equal to";
      }
      enum gt {
        tailf:info "Greater than";
      }
      enum le {
        tailf:info "Less than or equal to";
      }
      enum lt {
        tailf:info "Less than";
      }
      enum ne {
        tailf:info "Not equal to";
      }
      enum rg {
        tailf:info "Not in range";
      }
    }
  }

  typedef ospf-area-type {
    type union {
      type uint32 {
        tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
        range "0 .. 4294967295";
      }
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF area ID in IP address format";
      }
    }
  }

  typedef police-rate-units-type {
    type enumeration {
      enum bps {
        tailf:info "Bits per second (default)";
      }
      enum gbps {
        tailf:info "Gigabits per second";
      }
      enum kbps {
        tailf:info "Kilobits per second";
      }
      enum mbps {
        tailf:info "Megabits per second";
      }
      enum pps {
        tailf:info "Packets per second";
      }
    }
  }

  typedef police-burst-units-type {
    type enumeration {
      enum bytes {
        tailf:info "Bytes (default)";
      }
      enum gbytes {
        tailf:info Gigabytes;
      }
      enum kbytes {
        tailf:info Kilobytes;
      }
      enum mbytes {
        tailf:info Megabytes;
      }
      enum ms {
        tailf:info Milliseconds;
      }
      enum packets {
        tailf:info Packets;
      }
      enum us {
        tailf:info Microseconds;
      }
    }
  }

  typedef precedence-type {
    type union {
      type uint8 {
        tailf:info "<0-7>;;Precedence value";
        range "0..7";
      }
      type enumeration {
        enum routine {
          tailf:info "Set packets with routine precedence (0)";
          value 0;
        }
        enum priority {
          tailf:info "Set packets with priority precedence (1)";
          value 1;
        }
        enum immediate {
          tailf:info "Set packets with immediate precedence (2)";
          value 2;
        }
        enum flash {
          tailf:info "Set packets with flash precedence (3)";
          value 3;
        }
        enum flash-override {
          tailf:info "Set packets with flash override precedence (4)";
          value 4;
        }
        enum critical {
          tailf:info "Set packets with critical precedence (5)";
          value 5;
        }
        enum internet {
          tailf:info "Set packets with internetwork control precedence (6)";
          value 6;
        }
        enum network {
          tailf:info "Set packets with network control precedence (7)";
          value 7;
        }
      }
    }
  }

  typedef dscp-type {
    type union {
      type uint8 {
        tailf:info "<0-63>;;Differentiated services codepoint value";
        range "0..63";
      }
      type enumeration {
        enum af11 {
          tailf:info "AF11 dscp (001010)";
          tailf:code-name dscp_af11;
        }
        enum af12 {
          tailf:info "AF12 dscp (001100)";
          tailf:code-name dscp_af12;
        }
        enum af13 {
          tailf:info "AF13 dscp (001110)";
          tailf:code-name dscp_af13;
        }
        enum af21 {
          tailf:info "AF21 dscp (010010)";
          tailf:code-name dscp_af21;
        }
        enum af22 {
          tailf:info "AF22 dscp (010100)";
          tailf:code-name dscp_af22;
        }
        enum af23 {
          tailf:info "AF23 dscp (010110)";
          tailf:code-name dscp_af23;
        }
        enum af31 {
          tailf:info "AF31 dscp (011010)";
          tailf:code-name dscp_af31;
        }
        enum af32 {
          tailf:info "AF32 dscp (011100)";
          tailf:code-name dscp_af32;
        }
        enum af33 {
          tailf:info "AF33 dscp (011110)";
          tailf:code-name dscp_af33;
        }
        enum af41 {
          tailf:info "AF41 dscp (100010)";
          tailf:code-name dscp_af41;
        }
        enum af42 {
          tailf:info "AF42 dscp (100100)";
          tailf:code-name dscp_af42;
        }
        enum af43 {
          tailf:info "AF43 dscp (100110)";
          tailf:code-name dscp_af43;
        }
        enum cs1 {
          tailf:info "CS1(precedence 1) dscp (001000)";
          tailf:code-name dscp_cs1;
        }
        enum cs2 {
          tailf:info "CS2(precedence 2) dscp (010000)";
          tailf:code-name dscp_cs2;
        }
        enum cs3 {
          tailf:info "CS3(precedence 3) dscp (011000)";
          tailf:code-name dscp_cs3;
        }
        enum cs4 {
          tailf:info "CS4(precedence 4) dscp (100000)";
          tailf:code-name dscp_cs4;
        }
        enum cs5 {
          tailf:info "CS5(precedence 5) dscp (101000)";
          tailf:code-name dscp_cs5;
        }
        enum cs6 {
          tailf:info "CS6(precedence 6) dscp (110000)";
          tailf:code-name dscp_cs6;
        }
        enum cs7 {
          tailf:info "CS7(precedence 7) dscp (111000)";
          tailf:code-name dscp_cs7;
        }
        enum default {
          tailf:info "Default dscp (000000)";
          tailf:code-name dscp_default;
        }
        enum ef {
          tailf:info "EF dscp (101110)";
          tailf:code-name dscp_ef;
        }
      }
    }
  }

  typedef severity-type {
    type enumeration {
      enum alerts {
        tailf:info "Immediate action needed           (severity=1)";
      }
      enum critical {
        tailf:info "Critical conditions               (severity=2)";
      }
      enum debugging {
        tailf:info "Debugging messages                (severity=7)";
      }
      enum emergencies {
        tailf:info "System is unusable                (severity=0)";
      }
      enum errors {
        tailf:info "Error conditions                  (severity=3)";
      }
      enum info;
      enum informational {
        tailf:info "Informational messages            (severity=6)";
      }
      enum notifications {
        tailf:info "Normal but significant conditions (severity=5)";
      }
      enum warnings {
        tailf:info "Warning conditions                (severity=4)";
      }
      enum disable {
        tailf:info "Disable logging";
      }
    }
  }

  typedef task-type {
    type string;
  }

  typedef ipv4-prefix {
    type string {
      pattern "(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]))";
    }
    description
      "The ipv4-prefix type represents an IPv4 address prefix.
       The prefix length is given by the number following the
       slash character and must be less than or equal to 32.
       
       A prefix length value of n corresponds to an IP address
       mask that has n contiguous 1-bits from the most
       significant bit (MSB) and all other bits set to 0.
       
       The canonical format of an IPv4 prefix has all bits of
       the IPv4 address set to zero that are not part of the
       IPv4 prefix.";
  }

  typedef asn-ip-type {
    type string {
      pattern "(([0-9]+)|((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))):[0-9]+";
      tailf:info "ASN:nn or IP-address:nn";
    }
  }

  typedef percentage-type {
    type uint8 {
      tailf:info "<1-100>;;Percentage";
      range "1..100";
    }
  }

  typedef month-type {
    type enumeration {
      enum january;
      enum february;
      enum march;
      enum april;
      enum may;
      enum june;
      enum july;
      enum august;
      enum september;
      enum october;
      enum november;
      enum december;
    }
  }

  typedef ifname {
    type string {
      tailf:info "WORD;;Interface name";
    }
  }

  grouping ncs_template_description-grouping {
    leaf description {
      type string;
    }
  }

  grouping ncs_template_banner-grouping {
    leaf start-marker {
      type string;
    }
    leaf message {
      type string;
    }
    leaf end-marker {
      // NCS drop must statement
      type string;
    }
  }

  grouping ncs_template_vrf-route-target-grouping {
    list address-list {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
    }
    list stitching-address-list {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf stitching {
        type empty;
      }
    }
  }

  grouping ncs_template_router-af-redistribute-grouping {
    leaf metric {
      type string;
    }
    leaf route-policy {
      type string;
    }
  }

  grouping ncs_template_router-ospf-af-redistribute-grouping {
    leaf metric {
      type string;
    }
    leaf tag {
      type string;
    }
    leaf metric-type {
      type string;
    }
    leaf route-policy {
      type string;
    }
  }

  grouping ncs_template_router-isis-af-redistribute-grouping {
    leaf level {
      type string;
    }
    uses ncs_template_router-af-redistribute-grouping;
    leaf metric-type {
      type string;
    }
  }

  grouping ncs_template_router-ospf-authentication-grouping {
    container authentication {
      presence true;
      choice authentication-choice {
        container message-digest {
          presence true;
          leaf keychain {
            type string;
          }
        }
        leaf null {
          type empty;
        }
      }
    }
    list message-digest-key {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      container md5 {
        choice md5-choice {
          leaf key {
            type string;
          }
          leaf clear {
            type string;
          }
          leaf encrypted {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_bfd-common-parameters-grouping {
    container bfd {
      leaf minimum-interval {
        type string;
      }
      container fast-detect {
        presence true;
        leaf disable {
          type empty;
        }
      }
      leaf multiplier {
        type string;
      }
    }
  }

  grouping ncs_template_router-ospf-common-area-grouping {
    leaf cost {
      type string;
    }
    container passive {
      presence true;
      leaf mode {
        type string;
      }
    }
    leaf priority {
      type string;
    }
    container mtu-ignore {
      presence true;
      leaf mode {
        type string;
      }
    }
    leaf dead-interval {
      type string;
    }
    container fast-reroute {
      choice per-link-or-prefix {
        leaf disable {
          type empty;
        }
        container per-link {
          presence true;
          leaf enable {
            type empty;
          }
        }
        leaf per-prefix {
          type empty;
        }
      }
      container per-prefix-conf {
        container per-prefix {
          container remote-lfa {
            container tunnel {
              leaf mpls-ldp {
                type empty;
              }
            }
          }
        }
      }
    }
    leaf hello-interval {
      type string;
    }
  }

  grouping ncs_template_router-ospf-area-grouping {
    uses ncs_template_bfd-common-parameters-grouping;
    uses ncs_template_router-ospf-common-area-grouping;
    uses ncs_template_router-ospf-authentication-grouping;
    leaf network {
      type string;
    }
    container mpls {
      container ldp {
        container sync {
          presence true;
          leaf disable {
            type empty;
          }
        }
        leaf auto-config {
          type empty;
        }
        container sync-igp-shortcuts {
          presence true;
          leaf disable {
            type empty;
          }
        }
      }
      leaf traffic-eng {
        type empty;
      }
    }
    container prefix-sid {
      choice prefix-sid-choice {
        leaf absolute {
          type string;
        }
        leaf index {
          type string;
        }
      }
      leaf explicit-null {
        type empty;
      }
    }
    list distribute-list {
      // NCS patched for predictable order
      ordered-by user;
      key direction;
      leaf direction {
        type string;
      }
      leaf route-policy {
        type empty;
      }
      leaf access-list {
        type string;
      }
    }
    list neighbor {
      // NCS patched for predictable order
      ordered-by user;
      key address;
      leaf address {
        type string;
      }
      leaf priority {
        type string;
      }
    }
    container nssa {
      presence true;
      leaf no-redistribution {
        type empty;
      }
      leaf default-information-originate {
        type empty;
      }
      leaf metric {
        // NCS drop when statement
        type string;
      }
      leaf metric-type {
        // NCS drop when statement
        type string;
      }
      leaf no-summary {
        type empty;
      }
    }
  }

  grouping ncs_template_router-ospfvx-common-pre-grouping {
    leaf nsr {
      type empty;
    }
    leaf router-id {
      type string;
    }
    uses ncs_template_router-ospf-common-area-grouping;
    container log {
      container adjacency {
        container changes {
          presence true;
          leaf changes-state {
            type string;
          }
        }
      }
    }
    container timers {
      container throttle {
        container lsa {
          container all {
            leaf delay {
              type string;
            }
            leaf min-delay {
              type string;
            }
            leaf max-delay {
              type string;
            }
          }
        }
        container spf {
          leaf delay {
            type string;
          }
          leaf min-delay {
            type string;
          }
          leaf max-delay {
            type string;
          }
        }
      }
      container lsa {
        leaf min-arrival {
          type string;
        }
      }
      container pacing {
        leaf flood {
          type string;
        }
      }
    }
    container auto-cost {
      presence true;
      leaf reference-bandwidth {
        type string;
      }
    }
    container maximum {
      leaf paths {
        type string;
      }
      leaf interfaces {
        type string;
      }
      container redistributed-prefixes {
        leaf maximum {
          type string;
        }
        leaf threshold-value {
          type string;
        }
        leaf warning-only {
          type empty;
        }
      }
    }
    container bfd {
      leaf fast-detect {
        type empty;
      }
      leaf minimum-interval {
        type string;
      }
      leaf multiplier {
        type string;
      }
    }
    container network {
      choice network-choice {
        leaf broadcast {
          type empty;
        }
        leaf non-broadcast {
          type empty;
        }
        container point-to-multipoint {
          presence true;
          leaf non-broadcast {
            type empty;
          }
        }
        leaf point-to-point {
          type empty;
        }
      }
    }
    container domain-id {
      container primary {
        uses ncs_template_router-ospf-domain-id-grouping;
      }
      container secondary {
        uses ncs_template_router-ospf-domain-id-grouping;
      }
    }
    container default-information {
      container originate {
        presence true;
        leaf always {
          type empty;
        }
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
    }
    container spf {
      container prefix-priority {
        leaf route-policy {
          type string;
        }
      }
    }
    container distance {
      leaf weight {
        type string;
      }
      list distance-list {
        // NCS patched for predictable order
        ordered-by user;
        key "ip-address wildcard-mask";
        leaf weight {
          type string;
        }
        leaf ip-address {
          type string;
        }
        leaf wildcard-mask {
          type string;
        }
        leaf access-list-name {
          type string;
        }
      }
      container ospf {
        container external {
          leaf distance {
            type string;
          }
        }
      }
    }
    container redistribute {
      container connected {
        presence true;
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
      list ospf {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
      list bgp {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf preserve-med {
          type empty;
        }
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
      container static {
        presence true;
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
      list isis {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf level {
          type string;
        }
        uses ncs_template_router-ospf-af-redistribute-grouping;
      }
    }
  }

  grouping ncs_template_router-ospfvx-common-post-grouping {
    list area {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_router-ospf-area-grouping;
      container stub {
        presence true;
        leaf no-summary {
          type empty;
        }
      }
      list multi-area-interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_router-ospf-area-grouping;
      }
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_router-ospf-area-grouping;
      }
    }
  }

  grouping ncs_template_router-ospf-grouping {
    uses ncs_template_router-ospfvx-common-pre-grouping;
    list distribute-list {
      // NCS patched for predictable order
      ordered-by user;
      key direction;
      leaf direction {
        type string;
      }
      leaf route-policy {
        type empty;
      }
      leaf access-list {
        type string;
      }
    }
    container distribute-list-proto {
      list distribute-list {
        // NCS patched for predictable order
        ordered-by user;
        key direction;
        leaf access-list {
          type string;
        }
        leaf direction {
          type string;
        }
        leaf connected {
          type empty;
        }
        leaf static {
          type empty;
        }
        leaf bgp {
          type string;
        }
        leaf ospf {
          type string;
        }
      }
    }
    uses ncs_template_router-ospfvx-common-post-grouping;
    container nsf {
      container ietf {
        presence true;
        container helper {
          leaf disable {
            type empty;
          }
        }
      }
      container cisco {
        presence true;
        container enforce {
          leaf global {
            type empty;
          }
        }
      }
    }
    container queue {
      container limit {
        leaf low {
          type string;
        }
        leaf high {
          type string;
        }
        leaf medium {
          type string;
        }
      }
    }
    container ignore {
      container lsa {
        leaf mospf {
          type empty;
        }
      }
    }
    container segment-routing {
      container global-block {
        leaf lower-bound {
          type string;
        }
        leaf upper-bound {
          type string;
        }
      }
      choice mpls-disable-choice {
        leaf mpls {
          type empty;
        }
        leaf disable {
          type empty;
        }
      }
      leaf forwarding {
        type string;
      }
      container sr-prefer {
        presence true;
        leaf prefix-list {
          type string;
        }
      }
      container prefix-sid-map {
        container receive {
          presence true;
          leaf disable {
            type empty;
          }
        }
        leaf advertise-local {
          type empty;
        }
      }
    }
    container address-family {
      container ipv4 {
        presence true;
        leaf unicast {
          type empty;
        }
      }
    }
    container max-metric {
      container router-lsa {
        leaf on-startup {
          type string;
        }
        leaf include-stub {
          type empty;
        }
        choice external-lsa-choice {
          container external-lsa-container {
            leaf external-lsa {
              type string;
            }
          }
          leaf external-lsa {
            type empty;
          }
        }
        choice summary-lsa-choice {
          container summary-lsa-container {
            leaf summary-lsa {
              type string;
            }
          }
          leaf summary-lsa {
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_template_router-ospfv3-grouping {
    container graceful-restart {
      presence true;
    }
    uses ncs_template_router-ospfvx-common-pre-grouping;
    uses ncs_template_router-ospfvx-common-post-grouping;
    container address-family {
      container ipv6 {
        presence true;
        leaf unicast {
          type empty;
        }
      }
    }
  }

  grouping ncs_template_router-isis-common-af-grouping {
    leaf metric {
      type string;
    }
    container metric-level {
      list metric {
        // NCS patched for predictable order
        ordered-by user;
        key level;
        leaf level {
          type string;
        }
        leaf value {
          type string;
        }
      }
    }
    container fast-reroute {
      choice fast-reroute-choice {
        leaf disable {
          type empty;
        }
        container per-prefix {
          presence true;
          leaf-list level {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          container remote-lfa {
            container tunnel {
              container mpls-ldp {
                presence true;
              }
            }
          }
          container ti-lfa {
            presence true;
          }
        }
      }
    }
    container mpls {
      container ldp {
        leaf auto-config {
          type empty;
        }
        container sync {
          presence true;
          leaf level {
            type string;
          }
        }
      }
      container traffic-eng {
        leaf level {
          type string;
        }
        container router-id {
          uses ncs_template_interface-name-grouping;
        }
        leaf multicast-intact {
          type empty;
        }
      }
    }
    container monitor-convergence {
      presence true;
      leaf track-ip-frr {
        type empty;
      }
    }
    leaf tag {
      type string;
    }
  }

  grouping ncs_template_router-isis-af-grouping {
    container advertise {
      leaf passive-only {
        type empty;
      }
    }
    leaf ispf {
      type empty;
    }
    container ispf-conf {
      container ispf {
        leaf-list level {
          // NCS patched for predictable order
          ordered-by user;
          type string;
        }
      }
    }
    container spf-interval {
      leaf maximum-wait {
        type string;
      }
      leaf initial-wait {
        type string;
      }
      leaf secondary-wait {
        type string;
      }
    }
    leaf single-topology {
      type empty;
    }
    container adjacency-check {
      leaf disable {
        type empty;
      }
    }
    container spf {
      list prefix-priority {
        // NCS patched for predictable order
        ordered-by user;
        key priority;
        leaf priority {
          type string;
        }
        choice priority-type {
          leaf access-list {
            type string;
          }
          leaf tag {
            type string;
          }
        }
      }
    }
    container default-information {
      container originate {
        presence true;
        leaf external {
          type empty;
        }
        leaf route-policy {
          type string;
        }
      }
    }
    leaf maximum-paths {
      type string;
    }
    container propagate {
      list level {
        // NCS patched for predictable order
        ordered-by user;
        key "from level";
        leaf from {
          type string;
        }
        leaf into {
          type empty;
        }
        leaf level {
          type string;
        }
        leaf route-policy {
          type string;
        }
      }
    }
    container microloop {
      container avoidance {
        leaf rib-update-delay {
          type string;
        }
      }
    }
    container redistribute {
      container connected {
        presence true;
        uses ncs_template_router-isis-af-redistribute-grouping;
      }
      container static {
        presence true;
        uses ncs_template_router-isis-af-redistribute-grouping;
      }
      list isis {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_router-isis-af-redistribute-grouping;
      }
      list ospf {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf match {
          type string;
        }
        uses ncs_template_router-isis-af-redistribute-grouping;
      }
      list ospfv3 {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf match {
          type string;
        }
        uses ncs_template_router-isis-af-redistribute-grouping;
      }
    }
    container segment-routing {
      container mpls {
        presence true;
      }
      container prefix-sid-map {
        container receive {
          presence true;
        }
        leaf advertise-local {
          type empty;
        }
      }
    }
  }

  grouping ncs_template_router-isis-common-grouping {
    leaf metric-style {
      type string;
    }
    container metric-style-list {
      list metric-style {
        // NCS patched for predictable order
        ordered-by user;
        key level;
        leaf level {
          type string;
        }
        leaf style {
          type string;
        }
      }
    }
  }

  grouping ncs_template_router-isis-if-af-grouping {
    container prefix-sid {
      choice value-choice {
        leaf absolute {
          type string;
        }
        leaf index {
          type string;
        }
      }
      leaf explicit-null {
        type empty;
      }
      leaf n-flag-clear {
        type empty;
      }
    }
  }

  grouping ncs_template_vty-pool-grouping {
    leaf first-vty {
      type string;
    }
    leaf last-vty {
      type string;
    }
    leaf line-template {
      type string;
    }
  }

  grouping ncs_template_line-grouping {
    container flowcontrol {
      container hardware {
        leaf direction {
          type string;
        }
      }
    }
    leaf parity {
      type string;
    }
    leaf databits {
      type string;
    }
    leaf stopbits {
      type string;
    }
    container access-class {
      leaf egress {
        type string;
      }
      leaf ingress {
        type string;
      }
    }
    container secret {
      leaf type {
        type string;
      }
      leaf secret {
        type string;
      }
    }
    container password {
      leaf encryption {
        type string;
      }
      leaf password {
        type string;
      }
    }
    container users {
      list group {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container accounting {
      leaf commands {
        type string;
      }
      leaf exec {
        type string;
      }
    }
    container authorization {
      leaf commands {
        type string;
      }
      leaf exec {
        type string;
      }
    }
    container timeout {
      container login {
        leaf response {
          type string;
        }
      }
    }
    container timestamp {
      presence true;
      leaf disable {
        type empty;
      }
    }
    container transport {
      leaf-list input {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list output {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf preferred {
        type string;
      }
    }
    container exec-timeout {
      leaf minutes {
        type string;
      }
      leaf seconds {
        type string;
      }
    }
    leaf length {
      type string;
    }
    leaf width {
      type string;
    }
    container login {
      leaf authentication {
        type string;
      }
    }
    leaf session-limit {
      type string;
    }
    leaf absolute-timeout {
      type string;
    }
    container telnet {
      leaf transparent {
        type empty;
      }
    }
    container session-timeout {
      leaf minutes {
        type string;
      }
      leaf output {
        type empty;
      }
    }
    leaf escape-character {
      type string;
    }
  }

  grouping ncs_template_lpts-grouping {
    list flow {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf ospf-type {
        // NCS drop when statement
        type string;
      }
      leaf ldp-type {
        // NCS drop when statement
        type string;
      }
      leaf rsvp-type {
        // NCS drop when statement
        type string;
      }
      leaf raw-type {
        // NCS drop when statement
        type string;
      }
      leaf udp-tcp-type {
        // NCS drop when statement
        type string;
      }
      leaf icmp-type {
        // NCS drop when statement
        type string;
      }
      leaf which {
        type string;
      }
      leaf rate {
        type string;
      }
    }
  }

  grouping ncs_template_class-random-detect-grouping {
    leaf min-threshold {
      type string;
    }
    leaf min-threshold-unit {
      type string;
    }
    leaf max-threshold {
      type string;
    }
    leaf max-threshold-unit {
      type string;
    }
  }

  grouping ncs_template_class-map-match-grouping {
    container access-group {
      leaf ipv4 {
        type string;
      }
      leaf ipv6 {
        type string;
      }
    }
    leaf any {
      type empty;
    }
    container cos {
      leaf-list cos-value {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list inner {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container destination-address {
      list ipv4 {
        // NCS patched for predictable order
        ordered-by user;
        key "address mask";
        leaf address {
          type string;
        }
        leaf mask {
          type string;
        }
      }
      leaf mac {
        type string;
      }
    }
    leaf-list destination-port {
      // NCS patched for predictable order
      ordered-by user;
      type string;
    }
    leaf-list discard-class {
      // NCS patched for predictable order
      ordered-by user;
      type string;
    }
    container dscp {
      leaf-list dscp-list {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list ipv4 {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list ipv6 {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container fr-de {
      presence true;
      leaf fr-de-value {
        type string;
      }
    }
    container frame-relay {
      leaf-list dlci {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container mpls {
      container experimental {
        leaf-list topmost {
          // NCS patched for predictable order
          ordered-by user;
          type string;
        }
      }
    }
    container packet {
      leaf-list length {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container precedence {
      leaf-list ipv4 {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list ipv6 {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list list {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    leaf-list protocol {
      // NCS patched for predictable order
      ordered-by user;
      // NCS drop max-elements statement
      type string;
    }
    leaf-list qos-group {
      // NCS patched for predictable order
      ordered-by user;
      type string;
    }
    container source-address {
      list ipv4 {
        // NCS patched for predictable order
        ordered-by user;
        key "address mask";
        leaf address {
          type string;
        }
        leaf mask {
          type string;
        }
      }
      leaf mac {
        type string;
      }
    }
    leaf-list source-port {
      // NCS patched for predictable order
      ordered-by user;
      type string;
    }
    container vlan {
      leaf-list vlan-list {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list inner {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container vpls {
      leaf control {
        type empty;
      }
      leaf broadcast {
        type empty;
      }
      leaf known {
        type empty;
      }
      leaf multicast {
        type empty;
      }
      leaf unknown {
        type empty;
      }
    }
    leaf dei {
      type string;
    }
  }

  grouping ncs_template_lsp-status-grouping {
    container lsp-status {
      leaf reoptimize {
        type empty;
      }
      leaf state {
        type empty;
      }
      leaf reroute {
        type empty;
      }
      leaf insufficient-bandwidth {
        type empty;
      }
      leaf bw-change {
        type empty;
      }
    }
  }

  grouping ncs_template_interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        leaf valid-lifetime {
          type string;
        }
        leaf preferred-lifetime {
          type string;
        }
      }
      leaf no-adv {
        type empty;
      }
      container options {
        leaf no-autoconfig {
          type empty;
        }
        leaf off-link {
          type empty;
        }
      }
    }
  }

  grouping ncs_template_interface-service-policy-content-grouping {
    container account {
      choice account-choice {
        leaf nolayer2 {
          type empty;
        }
        leaf user-defined {
          type string;
        }
      }
    }
    leaf subscriber-parent {
      type empty;
    }
    leaf resource-id {
      // NCS drop when statement
      type string;
    }
    leaf shared-policy-instance {
      type string;
    }
  }

  grouping ncs_template_interface-service-policy-grouping {
    container service-policy {
      container input {
        leaf name {
          type string;
        }
        uses ncs_template_interface-service-policy-content-grouping;
      }
      container output {
        leaf name {
          type string;
        }
        uses ncs_template_interface-service-policy-content-grouping;
      }
      container type {
        container lan-queuing {
          leaf input {
            type string;
          }
          leaf output {
            type string;
          }
        }
        container performance-monitor {
          leaf input {
            type string;
          }
          leaf output {
            type string;
          }
          leaf inline {
            type string;
          }
        }
        container test {
          leaf input {
            type string;
          }
          leaf output {
            type string;
          }
          leaf inline {
            type string;
          }
        }
        container pbr {
          leaf input {
            type string;
          }
        }
        container control {
          leaf subscriber {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_interface-isis-grouping {
    container isis {
      container authentication {
        container mode {
          leaf crypt {
            type string;
          }
          leaf level {
            type string;
          }
        }
        leaf key-chain {
          type string;
        }
        container send-only {
          presence true;
          leaf level {
            type string;
          }
        }
      }
      leaf circuit-type {
        type string;
      }
      container hello {
        leaf padding {
          type empty;
        }
      }
      container metric {
        leaf metric {
          type string;
        }
        leaf delay {
          type string;
        }
        leaf expense {
          // NCS drop when statement
          type string;
        }
        leaf error {
          // NCS drop when statement
          type string;
        }
        leaf rest {
          // NCS drop when statement
          type string;
        }
      }
    }
  }

  grouping ncs_template_interface-switch-grouping {
    container channel-protocol {
      leaf number {
        type string;
      }
      leaf mode {
        type string;
      }
    }
    container switch {
      container virtual {
        leaf link {
          type string;
        }
      }
    }
    container switchport-conf {
      leaf switchport {
        type string;
      }
    }
    container switchport {
      container access {
        leaf vlan {
          type string;
        }
      }
      container block {
        leaf multicast {
          type empty;
        }
        leaf unicast {
          type empty;
        }
      }
      container mode {
        choice mode-choice {
          leaf access {
            type empty;
          }
          leaf dot1q-tunnel {
            type empty;
          }
          leaf dynamic {
            type string;
          }
          leaf trunk {
            type empty;
          }
        }
      }
      leaf nonegotiate {
        type empty;
      }
      container trunk {
        container allowed {
          container vlan {
            choice vlan-choice {
              leaf-list vlans {
                // NCS patched for predictable order
                ordered-by user;
                type string;
              }
              leaf all {
                type empty;
              }
              leaf-list except {
                // NCS patched for predictable order
                ordered-by user;
                type string;
              }
              leaf none {
                type empty;
              }
            }
          }
        }
        container native {
          leaf vlan {
            type string;
          }
        }
        container pruning {
          container vlan {
            choice vlan-choice {
              leaf-list vlans {
                // NCS patched for predictable order
                ordered-by user;
                type string;
              }
              leaf-list except {
                // NCS patched for predictable order
                ordered-by user;
                type string;
              }
              leaf none {
                type empty;
              }
            }
          }
        }
      }
    }
    container spanning-tree {
      leaf bpdufilter {
        type string;
      }
      leaf bpduguard {
        type string;
      }
      leaf guard {
        type string;
      }
      leaf portfast {
        type string;
      }
    }
  }

  grouping ncs_template_interface-bundle-grouping {
    container bundle {
      leaf wait-while {
        type string;
      }
      container load-balancing {
        leaf hash {
          type string;
        }
        container localize {
          container threshold {
            leaf links {
              type string;
            }
          }
        }
      }
      container maximum-active {
        container links {
          leaf number {
            type string;
          }
          leaf hot-standby {
            type empty;
          }
        }
      }
      container minimum-active {
        leaf links {
          type string;
        }
      }
    }
    container lacp {
      container switchover {
        leaf suppress-flaps {
          type string;
        }
      }
    }
    container mlacp {
      leaf iccp-group {
        type string;
      }
      leaf port-priority {
        type string;
      }
      container switchover {
        container maximize {
          container links {
            presence true;
            leaf threshold {
              type string;
            }
          }
        }
        leaf recovery-delay {
          type string;
        }
        leaf type {
          type string;
        }
      }
    }
  }

  grouping ncs_template_interface-non-bundle-grouping {
    container bundle {
      container id {
        leaf id-value {
          type string;
        }
        leaf mode {
          type string;
        }
      }
      leaf port-priority {
        type string;
      }
    }
    container lacp {
      container period {
        leaf period-value {
          type string;
        }
        container short {
          presence true;
          leaf receive {
            type string;
          }
          leaf transmit {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_interface-pointtopoint-grouping {
    container keepalive {
      choice keepalive-choice {
        container values {
          leaf interval {
            type string;
          }
          leaf retry {
            type string;
          }
        }
        leaf disable {
          type empty;
        }
      }
    }
    list pvc {
      // NCS patched for predictable order
      ordered-by user;
      key dlci;
      leaf dlci {
        type string;
      }
      uses ncs_template_interface-service-policy-grouping;
      leaf encap {
        type string;
      }
      container fragment {
        leaf end-to-end {
          type string;
        }
        leaf fragment-counter {
          type empty;
        }
      }
    }
    container ppp {
      container multilink {
        container minimum-active {
          leaf links {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_interface-multilink-grouping {
    container multilink {
      container fragment-size {
        leaf size {
          type string;
        }
        leaf fragment-counter {
          type empty;
        }
      }
      container fragment {
        leaf size {
          type string;
        }
      }
    }
  }

  grouping ncs_template_interface-ethernet-grouping {
    container carrier-delay {
      leaf up {
        type string;
      }
      leaf down {
        type string;
      }
    }
    leaf duplex {
      type string;
    }
    container ethernet {
      container udld {
        leaf mode {
          type string;
        }
      }
      container cfm {
        container mep {
          list domain {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf service {
              type string;
            }
            leaf mep-id {
              type string;
            }
            leaf cos {
              type string;
            }
            container sla {
              container operation {
                list profile {
                  // NCS patched for predictable order
                  ordered-by user;
                  key "name mep-id";
                  leaf name {
                    type string;
                  }
                  leaf target {
                    type empty;
                  }
                  leaf mep-id {
                    type string;
                  }
                }
              }
            }
          }
        }
        container ais {
          container transmission {
            container up {
              presence true;
              leaf cos {
                type string;
              }
              leaf interval {
                type string;
              }
            }
          }
        }
      }
      leaf egress-filter {
        type string;
      }
    }
    container ethernet-services {
      list access-group {
        // NCS patched for predictable order
        ordered-by user;
        key direction;
        leaf direction {
          type string;
        }
        leaf name {
          type string;
        }
      }
    }
    leaf mac-address {
      type string;
    }
    leaf speed {
      type string;
    }
    container transceiver {
      container permit {
        container pid {
          leaf all {
            type empty;
          }
        }
      }
    }
    container nv {
      container edge {
        leaf interface {
          type empty;
        }
      }
      container satellite-fabric-link {
        leaf satellite {
          type string;
        }
        container redundancy {
          leaf iccp-group {
            type string;
          }
        }
        container remote-ports {
          leaf GigabitEthernet {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_interface-common-grouping {
    leaf description {
      type string;
    }
    leaf bandwidth {
      type string;
    }
    leaf loopback {
      type string;
    }
    leaf mtu {
      type string;
    }
    container negotiation {
      container auto {
        presence true;
        leaf allow-overrides {
          type empty;
        }
      }
    }
    list monitor-session {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf ethernet {
        type empty;
      }
      leaf direction {
        type string;
      }
      leaf acl {
        type empty;
      }
    }
    container encapsulation {
      choice encapsulation-choice {
        container frame-relay {
          presence true;
          leaf IETF {
            type empty;
          }
        }
        leaf hdlc {
          type empty;
        }
        leaf mfr {
          type empty;
        }
        leaf ppp {
          type empty;
        }
        leaf default {
          type empty;
        }
        container untagged {
          presence true;
        }
        container ambiguous {
          container dot1q {
            leaf-list vlan-id {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
            leaf-list second-dot1q {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
          }
        }
        container dot1q {
          leaf-list vlan-id {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf-list second-dot1q {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf exact {
            type empty;
          }
          container ingress {
            leaf source-mac {
              type string;
            }
          }
        }
        container dot1ad {
          leaf-list vlan-id {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf-list dot1q {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          leaf exact {
            type empty;
          }
        }
      }
    }
    container pppoe {
      container enable {
        presence true;
        leaf bba-group {
          type string;
        }
      }
    }
    container frame-relay {
      container lmi {
        leaf disable {
          type empty;
        }
      }
      container lmi-type {
        presence true;
        leaf type {
          type string;
        }
      }
      container intf-type {
        presence true;
        leaf type {
          type string;
        }
      }
      container multilink {
        leaf bandwidth-class {
          type string;
        }
      }
    }
    container frequency {
      container synchronization {
        container selection {
          leaf input {
            type empty;
          }
        }
        leaf priority {
          type string;
        }
        leaf wait-to-restore {
          type string;
        }
        container quality {
          container receive {
            uses ncs_template_freqsync-quality-grouping;
          }
          container transmit {
            uses ncs_template_freqsync-quality-grouping;
          }
        }
      }
    }
    uses ncs_template_interface-service-policy-grouping;
    leaf vrf {
      // NCS drop tailf-common:cli-diff-dependency statement
      type string;
    }
    container aaa {
      container radius {
        container attribute {
          leaf nas-port-type {
            type string;
          }
        }
      }
    }
    container ipv4 {
      leaf point-to-point {
        type empty;
      }
      choice address-choice {
        case no {
          container no-address {
            leaf address {
              type string;
              // NCS drop default statement
            }
          }
        }
        case yes {
          container address {
            leaf ip {
              type string;
            }
            leaf mask {
              type string;
            }
            leaf route-tag {
              type string;
            }
          }
          container address-secondary-list {
            list address {
              // NCS patched for predictable order
              ordered-by user;
              key "ip secondary";
              leaf ip {
                type string;
              }
              leaf secondary {
                type string;
              }
              leaf mask {
                type string;
              }
              leaf route-tag {
                type string;
              }
            }
          }
        }
      }
      list access-group {
        // NCS patched for predictable order
        ordered-by user;
        key direction;
        leaf direction {
          type string;
        }
        leaf name {
          type string;
        }
        leaf hardware-count {
          type empty;
        }
        leaf interface-statistics {
          type empty;
        }
      }
      container helper-address {
        choice helper-address-choice {
          leaf local {
            type string;
          }
          leaf global {
            type string;
          }
          container vrf {
            leaf name {
              type string;
            }
            leaf address {
              type string;
            }
          }
        }
      }
      leaf redirects {
        type empty;
      }
      leaf directed-broadcast {
        type empty;
      }
      leaf mtu {
        type string;
      }
      container bgp {
        container policy {
          container propagation {
            container input {
              container qos-group {
                container destination {
                  presence true;
                }
              }
            }
          }
        }
      }
      container pim {
        leaf bidir-neighbor-filter {
          type string;
        }
        leaf bsr-border {
          type empty;
        }
        leaf dr-priority {
          type string;
        }
        leaf nbma-mode {
          type empty;
        }
        leaf neighbor-filter {
          type string;
        }
        container query-interval {
          choice interval-choice {
            case secs {
              leaf secs {
                type string;
              }
            }
            case msec {
              leaf msecs {
                type string;
                // NCS drop must statement
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            type empty;
          }
          container dense-mode {
            presence true;
            container proxy-register {
              choice proxy-mode {
                leaf list {
                  type string;
                }
                leaf route-map {
                  type string;
                }
              }
            }
          }
          leaf sparse-mode {
            type empty;
          }
        }
        container state-refresh {
          container origination-interval {
            presence true;
            leaf secs {
              type string;
            }
          }
        }
      }
      container verify {
        container unicast {
          container notification {
            leaf threshold {
              type string;
            }
          }
          container source {
            leaf reachable-via {
              type string;
            }
            leaf allow-self-ping {
              type empty;
            }
            leaf allow-default {
              type empty;
            }
          }
        }
      }
      container router {
        container isis {
          presence true;
          leaf routing-process {
            type string;
          }
        }
      }
      container unnumbered {
        uses ncs_template_interface-name-grouping;
      }
      container unreachables {
        leaf disable {
          type empty;
        }
      }
    }
    leaf proxy-arp {
      type empty;
    }
    container ipv6 {
      leaf mtu {
        type string;
      }
      container nd {
        leaf cache-limit {
          type string;
        }
        container dad {
          leaf attempts {
            type string;
          }
        }
        leaf managed-config-flag {
          type empty;
        }
        leaf ns-interval {
          type string;
        }
        leaf other-config-flag {
          type empty;
        }
        container prefix {
          list prefix-list {
            // NCS patched for predictable order
            ordered-by user;
            key prefix;
            leaf prefix {
              type string;
            }
            uses ncs_template_interface-ipv6-nd-prefix-list-grouping;
          }
          container default {
            uses ncs_template_interface-ipv6-nd-prefix-list-grouping;
          }
        }
        container ra {
          leaf hoplimit {
            type string;
          }
          leaf mtu {
            type string;
          }
        }
        leaf ra-interval {
          type string;
        }
        leaf ra-lifetime {
          type string;
        }
        leaf reachable-time {
          type string;
        }
        leaf redirects {
          type empty;
        }
        leaf suppress-ra {
          type empty;
        }
      }
      container verify {
        container unicast {
          container source {
            leaf reachable-via {
              type string;
            }
            leaf allow-default {
              type empty;
            }
            leaf allow-self-ping {
              type empty;
            }
          }
        }
      }
      container address {
        list prefix-list {
          // NCS patched for predictable order
          ordered-by user;
          key prefix;
          leaf prefix {
            type string;
          }
          leaf eui-64 {
            type empty;
          }
          leaf link-local {
            type empty;
          }
          leaf route-tag {
            type string;
          }
        }
      }
      leaf enable {
        type empty;
      }
      list access-group {
        // NCS patched for predictable order
        ordered-by user;
        key direction;
        leaf direction {
          type string;
        }
        leaf name {
          type string;
        }
        leaf interface-statistics {
          type empty;
        }
      }
      container unreachables {
        leaf disable {
          type empty;
        }
      }
    }
    container lldp {
      container receive {
        leaf disable {
          type empty;
        }
      }
      container transmit {
        leaf disable {
          type empty;
        }
      }
    }
    container mpls {
      leaf ip {
        type empty;
      }
      container label-security {
        leaf rpf {
          type empty;
        }
        leaf multi-label-packet {
          type string;
        }
      }
      leaf mtu {
        type string;
      }
    }
    container backup-bw {
      container unlimited {
        choice unlimited-choice {
          leaf any-class-type {
            type empty;
          }
          leaf class-type {
            type string;
          }
        }
      }
    }
    leaf shutdown {
      type empty;
    }
    uses ncs_template_interface-isis-grouping;
    leaf load-interval {
      type string;
    }
    container capture {
      container software {
        leaf packets {
          type empty;
        }
      }
    }
    container transport-mode {
      choice transport-mode-choice {
        leaf wan {
          type empty;
        }
        container otn {
          leaf bit-transparent {
            type string;
          }
        }
        leaf rx-only {
          type empty;
        }
        leaf tx-only {
          type empty;
        }
      }
    }
    leaf flow-control {
      type string;
    }
    list flow {
      // NCS patched for predictable order
      ordered-by user;
      key "proto monitor direction";
      leaf proto {
        type string;
      }
      leaf monitor {
        type string;
      }
      leaf sampler {
        type string;
      }
      leaf direction {
        type string;
      }
    }
    container dampening {
      presence true;
      leaf half-life {
        type string;
      }
      leaf reuse {
        type string;
      }
      leaf suppress {
        type string;
      }
      leaf max-suppress-time {
        type string;
      }
    }
    container logging {
      container events {
        leaf bundle-status {
          type empty;
        }
        leaf link-status {
          type empty;
        }
        leaf nfas-status {
          type empty;
        }
        container spanning-tree {
          leaf status {
            type empty;
          }
        }
        container subif-link-status {
          presence true;
          leaf ignore-bulk {
            type empty;
          }
        }
        leaf trunk-status {
          type empty;
        }
        uses ncs_template_lsp-status-grouping;
      }
      container ip {
        container access-list {
          container cache {
            leaf in {
              type empty;
            }
            leaf out {
              type empty;
            }
          }
        }
      }
    }
    container storm-control {
      container action {
        leaf level {
          type string;
        }
      }
      container broadcast {
        leaf level {
          type string;
        }
      }
      container multicast {
        leaf level {
          type string;
        }
      }
      container unicast {
        leaf level {
          type string;
        }
      }
    }
  }

  grouping ncs_template_subinterface-common-grouping {
    container rewrite {
      container ingress {
        container tag {
          choice tag-choice {
            leaf pop {
              type string;
            }
            leaf push {
              type empty;
            }
            leaf translate {
              type string;
            }
          }
          leaf dot1ad {
            // NCS drop when statement
            type string;
          }
          leaf dot1q {
            // NCS drop when statement
            type string;
          }
          leaf second-dot1q {
            // NCS drop when statement
            type string;
          }
          leaf mode {
            type string;
          }
        }
      }
    }
    container dot1q {
      container vlan {
        leaf vlan-id {
          type string;
        }
        leaf second-dot1q {
          type string;
        }
      }
    }
    container dot1ad {
      leaf vlan-id {
        type string;
      }
      leaf second-dot1d {
        type string;
      }
    }
    container l2protocol {
      leaf cpsv {
        type string;
      }
    }
  }

  grouping ncs_template_interface-bfd-grouping {
    container bfd {
      container address-family {
        container ipv4 {
          container timers {
            leaf start {
              type string;
            }
            leaf nbr-unconfig {
              type string;
            }
          }
          leaf multiplier {
            type string;
          }
          leaf destination {
            type string;
          }
          leaf fast-detect {
            type empty;
          }
          leaf minimum-interval {
            type string;
          }
        }
      }
      leaf echo {
        type empty;
      }
      container interval {
        leaf msecs {
          type string;
        }
        leaf min_rx {
          type string;
        }
        leaf multiplier {
          type string;
        }
      }
    }
  }

  grouping ncs_template_non-subinterface-common-grouping {
    container backup {
      container interface {
        uses ncs_template_interface-name-grouping;
      }
    }
    leaf cdp {
      type empty;
    }
    container dual-active {
      leaf fast-hello {
        type empty;
      }
    }
    container l2transport {
      presence true;
      uses ncs_template_interface-service-policy-grouping;
      container l2protocol {
        leaf cpsv {
          type string;
        }
      }
    }
    container platform {
      container qos {
        leaf channel-consistency {
          type string;
          // NCS drop default statement
        }
      }
    }
    container xconnect {
      leaf vfi {
        type string;
      }
    }
    uses ncs_template_interface-switch-grouping;
  }

  grouping ncs_template_interface-tunnel-path-option-grouping {
    list path-option {
      // NCS patched for predictable order
      ordered-by user;
      key preference-priority;
      leaf preference-priority {
        type string;
      }
      choice path-option-choice {
        container dynamic {
          presence true;
        }
        container explicit {
          choice path-choice {
            leaf identifier {
              type string;
            }
            leaf name {
              type string;
            }
          }
        }
      }
      leaf segment-routing {
        type empty;
      }
      leaf verbatim {
        type empty;
      }
      leaf lockdown {
        type empty;
      }
      container ospf {
        leaf instance-name {
          type string;
        }
        leaf area {
          type string;
        }
      }
      leaf attribute-set {
        type string;
      }
      leaf protected-by {
        type string;
      }
    }
  }

  grouping ncs_template_interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        type string;
      }
      container Bundle-Ether-subinterface {
        leaf Bundle-Ether {
          type string;
        }
      }
      leaf BVI {
        type string;
      }
      leaf FastEthernet {
        type string;
      }
      container FastEthernet-subinterface {
        leaf FastEthernet {
          type string;
        }
      }
      leaf GigabitEthernet {
        type string;
      }
      container GigabitEthernet-subinterface {
        leaf GigabitEthernet {
          type string;
        }
      }
      leaf TenGigE {
        type string;
      }
      container TenGigE-subinterface {
        leaf TenGigE {
          type string;
        }
      }
      leaf FortyGigE {
        type string;
      }
      container FortyGigE-subinterface {
        leaf FortyGigE {
          type string;
        }
      }
      leaf HundredGigE {
        type string;
      }
      container HundredGigE-subinterface {
        leaf HundredGigE {
          type string;
        }
      }
      leaf PW-Ether {
        type string;
      }
      leaf Loopback {
        type string;
      }
      leaf MgmtEth {
        type string;
      }
      leaf Multilink {
        type string;
      }
      container Multilink-subinterface {
        leaf Multilink {
          type string;
        }
      }
      leaf SRP {
        type string;
      }
      leaf Null {
        type string;
      }
      leaf Port-channel {
        type string;
      }
      leaf POS {
        type string;
      }
      container POS-subinterface {
        leaf POS {
          type string;
        }
      }
      leaf Serial {
        type string;
      }
      container Serial-subinterface {
        leaf Serial {
          type string;
        }
      }
      leaf tunnel-ip {
        type string;
      }
      leaf tunnel-te {
        type string;
      }
      leaf tunnel-tp {
        type string;
      }
      leaf tunnel-mte {
        type string;
      }
      leaf tunnel-ipsec {
        type string;
      }
      leaf ATM {
        type string;
      }
      container ATM-subinterface {
        leaf ATM {
          type string;
        }
      }
      leaf Vlan {
        type string;
      }
      leaf CEM {
        type string;
      }
    }
  }

  grouping ncs_template_interface-grouping {
    list Loopback {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list Bundle-Ether {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-bundle-grouping;
    }
    container Bundle-Ether-subinterface {
      list Bundle-Ether {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list MgmtEth {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    list TenGigE {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    container TenGigE-subinterface {
      list TenGigE {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list FortyGigE {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    container FortyGigE-subinterface {
      list FortyGigE {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list HundredGigE {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    container HundredGigE-subinterface {
      list HundredGigE {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list FastEthernet {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    container FastEthernet-subinterface {
      list FastEthernet {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list GigabitEthernet {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
    }
    container GigabitEthernet-subinterface {
      list GigabitEthernet {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
      }
    }
    list nve {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      container redundancy {
        container backbone {
          container mpls {
            container iccp {
              leaf group {
                type string;
              }
            }
          }
          container vxlan {
            container iccp {
              leaf group {
                type string;
              }
            }
          }
        }
      }
      container member {
        list vni {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf vrf {
            type string;
          }
          container host-reachability {
            leaf protocol {
              type string;
            }
          }
          container host-reachabilty {
            leaf protocol {
              type string;
            }
          }
          container mcast-group {
            leaf ip-address {
              type string;
            }
            leaf end-ip-address {
              type string;
            }
          }
        }
      }
      leaf remap-replication-servers {
        type empty;
      }
      leaf replication-server {
        type string;
      }
      container source-interface {
        leaf Loopback {
          type string;
        }
      }
      container anycast {
        container source-interface {
          leaf Loopback {
            type string;
          }
        }
      }
    }
    list PW-Ether {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-non-bundle-grouping;
      container attach {
        leaf generic-interface-list {
          type string;
        }
      }
    }
    container PW-Ether-subinterface {
      list PW-Ether {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf l2transport {
          type empty;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-ethernet-grouping;
        uses ncs_template_subinterface-common-grouping;
        container attach {
          leaf generic-interface-list {
            type string;
          }
        }
      }
    }
    list Port-channel {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-ethernet-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list POS {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-pointtopoint-grouping;
      container pos {
        leaf crc {
          type string;
        }
      }
    }
    container POS-subinterface {
      list POS {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_subinterface-common-grouping;
        uses ncs_template_interface-pointtopoint-grouping;
      }
    }
    list BVI {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list Vlan {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list tunnel-ip {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-pointtopoint-grouping;
      container tunnel {
        container mode {
          leaf gre {
            type string;
          }
        }
        leaf source {
          type string;
        }
        leaf destination {
          type string;
        }
      }
    }
    list tunnel-te {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      container bfd {
        presence true;
        leaf multiplier {
          type string;
        }
        container fast-detect {
          presence true;
          leaf sbfd {
            type empty;
          }
        }
        leaf minimum-interval {
          type string;
        }
        container dampening {
          leaf maximum-wait {
            type string;
          }
          leaf secondary-wait {
            type string;
          }
          leaf initial-wait {
            type string;
          }
        }
        leaf bringup-timeout {
          type string;
        }
        container lsp-ping {
          choice lsp-ping-choice {
            leaf disable {
              type empty;
            }
            leaf interval {
              type string;
            }
          }
        }
      }
      leaf load-share {
        type string;
      }
      container auto-bw {
        container bw-limit {
          leaf min {
            type string;
          }
          leaf max {
            type string;
          }
        }
        container overflow {
          uses ncs_template_interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container underflow {
          uses ncs_template_interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container adjustment-threshold {
          leaf percentage {
            type string;
          }
          leaf min {
            type string;
          }
        }
        leaf application {
          type string;
        }
      }
      container autoroute {
        container metric {
          choice metric-choice {
            leaf absolute {
              type string;
            }
            leaf relative {
              type string;
            }
          }
        }
        container announce {
          presence true;
          container metric {
            choice metric-choice {
              leaf constant {
                type string;
              }
              leaf absolute {
                type string;
              }
              leaf relative {
                type string;
              }
            }
          }
        }
        list destination {
          // NCS patched for predictable order
          ordered-by user;
          key addr;
          leaf addr {
            type string;
          }
        }
      }
      leaf destination {
        type string;
      }
      leaf forward-class {
        type string;
      }
      leaf policy-class {
        type string;
      }
      leaf soft-preemption {
        type empty;
      }
      container affinity {
        container affinity-value {
          leaf value {
            type string;
          }
          leaf mask {
            type string;
          }
        }
        list include {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        list include-strict {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        list exclude {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      leaf path-protection {
        type empty;
      }
      container path-selection {
        container metric {
          leaf metric-type {
            type string;
          }
        }
        container segment-routing {
          leaf adjacency {
            type string;
          }
        }
      }
      container priority {
        leaf setup {
          type string;
        }
        leaf hold-value {
          type string;
        }
      }
      leaf signalled-name {
        type string;
      }
      container signalled-bandwidth {
        leaf sub-pool {
          type empty;
        }
        leaf bandwidth {
          type string;
        }
        leaf class-type {
          // NCS drop when statement
          type string;
        }
      }
      leaf fast-reroute {
        type empty;
      }
      leaf record-route {
        type empty;
      }
      uses ncs_template_interface-tunnel-path-option-grouping;
      container pce {
        presence true;
        leaf delegation {
          type empty;
        }
      }
    }
    list tunnel-tp {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list tunnel-mte {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      list destination {
        // NCS patched for predictable order
        ordered-by user;
        key addr;
        leaf addr {
          type string;
        }
        uses ncs_template_interface-tunnel-path-option-grouping;
      }
    }
    list tunnel-ipsec {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_non-subinterface-common-grouping;
    }
    list ATM {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-atm-grouping;
    }
    container ATM-subinterface {
      list ATM {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        choice mode-choice {
          leaf l2transport {
            type empty;
          }
          leaf point-to-point {
            type empty;
          }
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_subinterface-common-grouping;
        uses ncs_template_interface-atm-grouping;
      }
    }
    list Multilink {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-pointtopoint-grouping;
      uses ncs_template_interface-multilink-grouping;
    }
    container Multilink-subinterface {
      list Multilink {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_subinterface-common-grouping;
        uses ncs_template_interface-pointtopoint-grouping;
        uses ncs_template_interface-multilink-grouping;
      }
    }
    list SRP {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      container threshold {
        leaf b2-tca {
          type string;
        }
      }
    }
    list Serial {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      uses ncs_template_interface-pointtopoint-grouping;
      container multilink {
        leaf group {
          type string;
        }
      }
      container serial {
        leaf crc {
          type string;
        }
        leaf scramble {
          type empty;
        }
      }
    }
    container Serial-subinterface {
      list Serial {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf mode {
          type string;
        }
        uses ncs_template_interface-common-grouping;
        uses ncs_template_interface-bfd-grouping;
        uses ncs_template_subinterface-common-grouping;
        uses ncs_template_interface-pointtopoint-grouping;
        leaf subinterface {
          type empty;
        }
      }
    }
    list CEM {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_interface-common-grouping;
      uses ncs_template_interface-bfd-grouping;
      uses ncs_template_non-subinterface-common-grouping;
      container cem {
        leaf class-attach {
          type string;
        }
        leaf dejitter {
          type string;
        }
      }
    }
  }

  grouping ncs_template_bgp-address-family-pre-grouping {
    container label {
      container mode {
        choice mode-choice {
          leaf per-ce {
            type empty;
          }
          leaf per-prefix {
            type empty;
          }
          leaf per-vrf {
            type empty;
          }
          leaf route-policy {
            type string;
          }
        }
      }
    }
    leaf table-policy {
      type string;
    }
    container retain {
      leaf local-label {
        type string;
      }
      container route-target {
        choice route-target-choice {
          leaf all {
            type empty;
          }
          leaf route-policy {
            type string;
          }
        }
      }
    }
    container update {
      container limit {
        leaf address-family {
          type string;
        }
        container sub-group {
          leaf ebgp {
            type string;
          }
          leaf ibgp {
            type string;
          }
        }
      }
    }
    container additional-paths {
      leaf receive {
        type empty;
      }
      leaf send {
        type empty;
      }
      container selection {
        list route-policy {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
    }
    leaf weight {
      type string;
    }
    container advertise {
      leaf best-external {
        type empty;
      }
      container vpnv4 {
        container unicast {
          presence true;
          uses ncs_template_router-bgp-af-advertise-grouping;
        }
      }
      container vpnv6 {
        container unicast {
          presence true;
          uses ncs_template_router-bgp-af-advertise-grouping;
        }
      }
      container l2vpn {
        container evpn {
          presence true;
          uses ncs_template_router-bgp-af-advertise-grouping;
        }
      }
    }
    container bgp {
      leaf attribute-download {
        type empty;
      }
      container dampening {
        presence true;
        choice dampening-choice {
          case a {
            leaf half-life {
              type string;
            }
            leaf reuse {
              type string;
            }
            leaf suppress {
              type string;
            }
            leaf max-suppress-time {
              type string;
            }
          }
          case b {
            leaf route-policy {
              type string;
            }
          }
        }
      }
      container label-delay {
        leaf seconds {
          type string;
        }
        leaf milliseconds {
          type string;
        }
      }
      container client-to-client {
        container reflection {
          leaf disable {
            type empty;
          }
        }
      }
    }
    container maximum-paths {
      container eibgp {
        leaf maximum {
          type string;
        }
        leaf selective {
          type empty;
        }
      }
      container ebgp {
        leaf maximum {
          type string;
        }
        leaf selective {
          type empty;
        }
      }
      container ibgp {
        leaf maximum {
          type string;
        }
        leaf unequal-cost {
          type empty;
        }
        leaf selective {
          type empty;
        }
      }
    }
    container distance {
      container bgp {
        leaf external {
          type string;
        }
        leaf internal {
          type string;
        }
        leaf local {
          type string;
        }
      }
    }
    container nexthop {
      container resolution {
        container prefix-length {
          leaf minimum {
            type string;
          }
        }
      }
      leaf route-policy {
        type string;
      }
      container trigger-delay {
        leaf critical {
          type string;
        }
        leaf non-critical {
          type string;
        }
      }
    }
    leaf domain-distinguisher {
      type string;
    }
  }

  grouping ncs_template_bgp-address-family-post-grouping {
    list aggregate-address {
      // NCS patched for predictable order
      ordered-by user;
      key prefix;
      leaf prefix {
        type string;
      }
      leaf as-set {
        type empty;
      }
      leaf as-confed-set {
        type empty;
      }
      leaf summary-only {
        type empty;
      }
      container route-policy {
        leaf name {
          type string;
        }
      }
    }
    container redistribute {
      container connected {
        presence true;
        uses ncs_template_router-af-redistribute-grouping;
      }
      container static {
        presence true;
        uses ncs_template_router-af-redistribute-grouping;
      }
      container rip {
        presence true;
        uses ncs_template_router-af-redistribute-grouping;
      }
      container mobile {
        presence true;
        uses ncs_template_router-af-redistribute-grouping;
      }
      list ospf {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf match {
          type empty;
        }
        leaf internal {
          // NCS drop when statement
          type empty;
        }
        leaf external {
          // NCS drop when statement
          type empty;
        }
        leaf external-type {
          // NCS drop when statement
          type string;
        }
        leaf nssa-external {
          // NCS drop when statement
          type empty;
        }
        leaf nssa-external-type {
          // NCS drop when statement
          type string;
        }
        uses ncs_template_router-af-redistribute-grouping;
      }
      list isis {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf level {
          type string;
        }
        uses ncs_template_router-af-redistribute-grouping;
      }
    }
    container allocate-label {
      choice allocate-label-choice {
        leaf all {
          type empty;
        }
        leaf route-policy {
          type string;
        }
      }
    }
  }

  grouping ncs_template_bgp-address-family-ipv4-grouping {
    uses ncs_template_bgp-address-family-pre-grouping;
    list network {
      // NCS patched for predictable order
      ordered-by user;
      key net;
      leaf net {
        type string;
      }
      leaf backdoor {
        type empty;
      }
      leaf route-policy {
        type string;
      }
    }
    uses ncs_template_bgp-address-family-post-grouping;
  }

  grouping ncs_template_bgp-address-family-ipv6-grouping {
    uses ncs_template_bgp-address-family-pre-grouping;
    list network {
      // NCS patched for predictable order
      ordered-by user;
      key net;
      leaf net {
        type string;
      }
      leaf backdoor {
        type empty;
      }
      leaf route-policy {
        type string;
      }
    }
    uses ncs_template_bgp-address-family-post-grouping;
  }

  grouping ncs_template_bgp-address-family-grouping {
    container address-family {
      container ipv4 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container multicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container labeled-unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container mdt {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container mvpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
      }
      container ipv6 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
        }
        container multicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
        }
        container mvpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
        }
      }
      container vpnv4 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container multicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv6 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
        }
      }
      container l2vpn {
        container vpls-vpws {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container evpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
        container mspw {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
        }
      }
      container link-state {
        container link-state {
          presence true;
          uses ncs_template_bgp-address-family-pre-grouping;
        }
      }
    }
  }

  grouping ncs_template_router-bgp-neighbor-af-grouping {
    leaf multipath {
      type empty;
    }
    list route-policy {
      // NCS patched for predictable order
      ordered-by user;
      key direction;
      leaf direction {
        type string;
      }
      leaf name {
        type string;
      }
    }
    leaf encapsulation-type {
      type string;
    }
    container remove-private-AS {
      presence true;
      leaf entire-aspath {
        type empty;
      }
    }
    container soft-reconfiguration {
      container inbound {
        presence true;
        leaf type {
          type string;
        }
      }
    }
    container allowas-in {
      leaf as-occurrence-number {
        type string;
      }
    }
    leaf site-of-origin {
      type string;
    }
    container import {
      choice import-choice {
        container stitching-rt {
          presence true;
          choice re-originate-choice {
            leaf re-originate {
              type empty;
            }
            leaf reoriginate {
              type empty;
            }
          }
          leaf stitching-rt {
            type empty;
          }
        }
        container re-originate {
          presence true;
          leaf stitching-rt {
            type empty;
          }
        }
      }
    }
    container accept-own {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container as-override {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container maximum-prefix {
      leaf max-prefix-limit {
        type string;
      }
      leaf threshold {
        type string;
      }
      leaf restart {
        type string;
      }
      leaf warning-only {
        type empty;
      }
    }
    container next-hop-self {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container next-hop-unchanged {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    leaf route-reflector-client {
      type empty;
    }
    container default-originate {
      presence true;
      leaf route-policy {
        type string;
      }
    }
    container send-community-ebgp {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container send-extended-community-ebgp {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container use {
      leaf af-group {
        type string;
      }
    }
    container capability {
      container orf {
        leaf prefix {
          type string;
        }
      }
    }
  }

  grouping ncs_template_bgp-neighbor-grouping {
    leaf remote-as {
      type string;
    }
    container local {
      container address {
        leaf ip {
          type string;
        }
      }
    }
    container local-as {
      choice local-as-choice {
        leaf inheritance-disable {
          type empty;
        }
        case as-number-case {
          leaf as-number {
            type string;
          }
          leaf no-prepend {
            type empty;
          }
          leaf replace-as {
            type empty;
          }
          leaf dual-as {
            type empty;
          }
        }
      }
    }
    uses ncs_template_bfd-common-parameters-grouping;
    container ebgp-multihop {
      leaf ttl-value {
        type string;
      }
      leaf mpls {
        type empty;
      }
    }
    container enforce-first-as {
      presence true;
      leaf disable {
        type empty;
      }
    }
    container advertisement-interval {
      leaf seconds {
        type string;
      }
      leaf milliseconds {
        type string;
      }
    }
    container timers {
      leaf keepalive {
        type string;
      }
      leaf holdtime {
        type string;
      }
      leaf min-holdtime {
        type string;
      }
    }
    leaf description {
      type string;
    }
    container password {
      leaf enc-type {
        type string;
      }
      leaf password {
        type string;
      }
    }
    container ttl-security {
      presence true;
      leaf inheritance-disable {
        type empty;
      }
    }
    container update {
      container in {
        container filtering {
          container attribute-filter {
            leaf group {
              type string;
            }
          }
        }
      }
    }
    container update-source {
      uses ncs_template_interface-name-grouping;
    }
    container ignore-connected-check {
      presence true;
    }
    leaf cluster-id {
      type string;
    }
    container graceful-restart {
      presence true;
      leaf suppress {
        type empty;
      }
      leaf disable {
        type empty;
      }
    }
    container capability {
      container suppress {
        container four-byte-as {
          tailf:alt-name 4-byte-as;
          presence true;
          leaf inheritance-disable {
            type empty;
          }
        }
      }
    }
    container address-family {
      container ipv4 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container multicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container mdt {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container rt-filter {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container flowspec {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
      }
      container l2vpn {
        container vpls-vpws {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container evpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container mspw {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv4 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv4-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
      }
      container ipv6 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container multicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv6 {
        container unicast {
          presence true;
          uses ncs_template_bgp-address-family-ipv6-grouping;
          uses ncs_template_router-bgp-neighbor-af-grouping;
        }
      }
    }
    leaf keychain {
      type string;
    }
    container peer-group {
      presence true;
      leaf group-name {
        type string;
      }
    }
    container use {
      leaf af-group {
        type string;
      }
      leaf neighbor-group {
        type string;
      }
      leaf session-group {
        type string;
      }
    }
    container shutdown {
      presence true;
    }
  }

  grouping ncs_template_router-bgp-vrf-grouping {
    container bfd {
      leaf multiplier {
        type string;
      }
      leaf minimum-interval {
        type string;
      }
    }
    container timers {
      container bgp {
        leaf keepalive {
          type string;
        }
        leaf holdtime {
          type string;
        }
        leaf min-neighbor-holdtime {
          type string;
        }
      }
    }
    container bgp {
      leaf router-id {
        type string;
      }
      leaf cluster-id {
        type string;
      }
      leaf scan-time {
        type string;
      }
      container update-delay {
        leaf update-delay-value {
          type string;
        }
        leaf always {
          type empty;
        }
      }
      leaf redistribute-internal {
        type empty;
      }
      container graceful-restart {
        presence true;
        leaf extended {
          type empty;
        }
        leaf restart-time {
          type string;
        }
        leaf stalepath-time {
          type string;
        }
        leaf purge-time {
          type string;
        }
        leaf graceful-reset {
          type empty;
        }
      }
      container bestpath {
        leaf compare-routerid {
          type empty;
        }
        container cost-community {
          leaf ignore {
            type empty;
          }
        }
        container med {
          leaf always {
            type empty;
          }
          leaf confed {
            type empty;
          }
          leaf missing-as-worst {
            type empty;
          }
        }
        container as-path {
          leaf ignore {
            type empty;
          }
        }
      }
      container log {
        container neighbor {
          leaf changes {
            type string;
          }
        }
      }
      container default {
        leaf local-preference {
          type string;
        }
      }
      container auto-policy-soft-reset {
        leaf disable {
          type empty;
        }
      }
      container label-delay {
        leaf seconds {
          type string;
        }
        leaf milliseconds {
          type string;
        }
      }
      container import-delay {
        leaf seconds {
          type string;
        }
        leaf milliseconds {
          type string;
        }
      }
      container fast-external-fallover {
        leaf disable {
          type empty;
        }
      }
    }
    container default-information {
      leaf originate {
        type empty;
      }
    }
    container mpls {
      container activate {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
    }
    container update {
      leaf limit {
        type string;
      }
    }
    container ibgp {
      container policy {
        container out {
          leaf enforce-modifications {
            type empty;
          }
        }
      }
    }
    uses ncs_template_bgp-address-family-grouping;
    list af-group {
      // NCS patched for predictable order
      ordered-by user;
      key "name address-family af-modifier";
      leaf name {
        type string;
      }
      leaf address-family {
        type string;
      }
      leaf af-modifier {
        type string;
      }
      uses ncs_template_router-bgp-neighbor-af-grouping;
    }
    list neighbor-group {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_bgp-neighbor-grouping;
    }
    list neighbor {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      leaf activate {
        type empty;
      }
      uses ncs_template_bgp-neighbor-grouping;
    }
    container socket {
      container receive-buffer-size {
        leaf socket-size {
          type string;
        }
        leaf bgp-size {
          type string;
        }
      }
      container send-buffer-size {
        leaf socket-size {
          type string;
        }
        leaf bgp-size {
          type string;
        }
      }
    }
  }

  grouping ncs_template_router-bgp-grouping {
    container nsr {
      presence true;
      leaf disable {
        type empty;
      }
    }
    uses ncs_template_router-bgp-vrf-grouping;
    list session-group {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf remote-as {
        type string;
      }
      container use {
        leaf session-group {
          type string;
        }
      }
      container ebgp-multihop {
        leaf ttl-value {
          type string;
        }
        leaf mpls {
          type empty;
        }
      }
      container advertisement-interval {
        leaf seconds {
          type string;
        }
        leaf milliseconds {
          type string;
        }
      }
      container local-as {
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              type empty;
            }
          }
          case b {
            leaf as-number {
              type string;
            }
            leaf no-prepend {
              type empty;
            }
            leaf replace-as {
              type empty;
            }
            leaf dual-as {
              type empty;
            }
          }
        }
      }
      container password {
        choice password-choice {
          leaf clear {
            type string;
          }
          leaf encrypted {
            type string;
          }
          leaf inheritance-disable {
            type empty;
          }
        }
      }
      leaf description {
        type string;
      }
      container update-source {
        uses ncs_template_interface-name-grouping;
      }
      leaf session-open-mode {
        type string;
      }
      leaf send-buffer-size {
        type string;
      }
      leaf receive-buffer-size {
        type string;
      }
      uses ncs_template_bfd-common-parameters-grouping;
    }
    list vrf {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf rd {
        type string;
      }
      leaf label-allocation-mode {
        type string;
      }
      container label {
        leaf mode {
          type string;
        }
      }
      uses ncs_template_router-bgp-vrf-grouping;
    }
  }

  grouping ncs_template_police-set-grouping {
    leaf atm-clp {
      type empty;
    }
    container cos {
      leaf cos-value {
        type string;
      }
      leaf inner {
        type string;
      }
    }
    leaf dei {
      type string;
    }
    leaf discard-class {
      type string;
    }
    container dscp {
      leaf outer {
        type string;
      }
      leaf tunnel {
        type string;
      }
    }
    leaf fr-de {
      type string;
    }
    container mpls {
      container experimental {
        leaf imposition {
          type string;
        }
        leaf topmost {
          type string;
        }
      }
    }
    container precedence {
      leaf outer {
        type string;
      }
      leaf tunnel {
        type string;
      }
    }
    leaf qos-group {
      type string;
    }
    leaf forward-class {
      type string;
    }
    leaf srp-priority {
      type string;
    }
  }

  grouping ncs_template_police-action-grouping {
    leaf child-conform-aware {
      type empty;
    }
    container conform-action {
      leaf drop {
        type empty;
      }
      container set {
        uses ncs_template_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
    container exceed-action {
      leaf drop {
        type empty;
      }
      container set {
        uses ncs_template_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
    container violate-action {
      leaf drop {
        type empty;
      }
      container set {
        uses ncs_template_police-set-grouping;
      }
      leaf transmit {
        type empty;
      }
    }
  }

  grouping ncs_template_policy-map-class-grouping {
    leaf type {
      type string;
    }
    leaf drop {
      type empty;
    }
    container redirect {
      container nexthop {
        leaf vrf {
          type string;
        }
        choice nexthop-choice {
          leaf IPv4-address {
            type string;
          }
          leaf IPv6-address {
            type string;
          }
          leaf route-target {
            type string;
          }
        }
      }
    }
    container shape {
      container average {
        choice average-choice {
          case percent-case {
            leaf percent {
              type string;
            }
          }
          case unit-case {
            leaf rate {
              type string;
            }
            leaf rate-unit {
              type string;
            }
          }
        }
        leaf burst {
          type string;
        }
        leaf burst-unit {
          type string;
        }
      }
    }
    container bandwidth {
      container bandwidth-units {
        leaf rate {
          type string;
        }
        leaf units {
          type string;
        }
      }
      leaf percent {
        type string;
      }
      container remaining {
        leaf percent {
          type string;
        }
        leaf ratio {
          type string;
        }
      }
    }
    choice police-choice {
      case police-rate-unit-case {
        container police-rate-unit {
          container police {
            container rate {
              choice rate-choice {
                case units-case {
                  leaf cir {
                    type string;
                  }
                  leaf cir-unit {
                    type string;
                  }
                }
                case percent-case {
                  leaf percent {
                    type string;
                  }
                }
              }
              leaf burst {
                type string;
              }
              leaf burst-units {
                // NCS drop when statement
                type string;
              }
              leaf peak-rate {
                type string;
              }
              leaf peak-rate-units {
                // NCS drop when statement
                type string;
              }
              container peak-rate-percent {
                // NCS drop when statement
                container peak-rate {
                  leaf percent {
                    type string;
                  }
                }
              }
              leaf peak-burst {
                type string;
              }
              leaf peak-burst-units {
                // NCS drop when statement
                type string;
              }
              uses ncs_template_police-action-grouping;
            }
          }
        }
      }
      case police-unit-case {
        container police-unit {
          container police {
            leaf cir {
              type string;
            }
            leaf bc {
              type string;
            }
            leaf be {
              type string;
            }
            uses ncs_template_police-action-grouping;
          }
        }
      }
    }
    container set {
      uses ncs_template_police-set-grouping;
    }
    container priority {
      leaf level {
        type string;
      }
    }
    container queue-limit {
      leaf queue-limit-value {
        type string;
      }
      leaf queue-limit-unit {
        type string;
      }
    }
    container service-function-path {
      leaf id {
        type string;
      }
      leaf index {
        type string;
      }
      leaf metadata {
        type string;
      }
    }
    container service-policy {
      leaf type {
        type string;
      }
      leaf name {
        type string;
      }
    }
    container random-detect {
      leaf default {
        type empty;
      }
      list cos {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      list dei {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      list dscp {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      list exp {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      list precedence {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      list discard-class {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_class-random-detect-grouping;
      }
      container default-values {
        uses ncs_template_class-random-detect-grouping;
      }
    }
  }

  grouping ncs_template_performance-mgmt-grouping {
    choice case-choice {
      container AverageCpuUsed {
        uses ncs_template_average-cpu-used-grouping;
      }
      container AverageCPUUsed {
        uses ncs_template_average-cpu-used-grouping;
      }
    }
    leaf sample-size {
      type string;
    }
    leaf sample-interval {
      type string;
    }
  }

  grouping ncs_template_ipv4-ipv6-common-grouping {
    leaf conflict-policy {
      type string;
    }
    list prefix-list {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      list rule {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf line {
          type string;
        }
      }
    }
  }

  grouping ncs_template_arp-grouping {
    list arp-list {
      // NCS patched for predictable order
      ordered-by user;
      key address;
      leaf address {
        type string;
      }
      leaf mac {
        type string;
      }
      leaf type {
        type string;
      }
      leaf alias {
        type empty;
      }
    }
  }

  grouping ncs_template_tftp-server-grouping {
    list tftp-server-list {
      // NCS patched for predictable order
      ordered-by user;
      key af;
      leaf af {
        type string;
      }
      leaf server {
        type empty;
      }
      leaf homedir {
        type string;
      }
      leaf max-servers {
        type string;
      }
      leaf access-list {
        type string;
      }
    }
  }

  grouping ncs_template_telnet-server-grouping {
    list telnet-server-list {
      // NCS patched for predictable order
      ordered-by user;
      key af;
      leaf af {
        type string;
      }
      leaf dscp {
        type string;
      }
      container server {
        leaf max-servers {
          type string;
        }
        leaf access-list {
          type string;
        }
      }
    }
  }

  grouping ncs_template_ntp-server-grouping {
    list server-list {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf ip-version {
        type string;
      }
      leaf version {
        type string;
      }
      leaf minpoll {
        type string;
      }
      leaf maxpoll {
        type string;
      }
      leaf prefer {
        type empty;
      }
      leaf burst {
        type empty;
      }
      leaf iburst {
        type empty;
      }
      container source {
        uses ncs_template_interface-name-grouping;
      }
      leaf key {
        type string;
      }
    }
  }

  grouping ncs_template_router-static-options-grouping {
    leaf bfd {
      type string;
    }
    leaf minimum-interval {
      // NCS drop when statement
      type string;
    }
    leaf multiplier {
      // NCS drop when statement
      type string;
    }
    choice metric-choice {
      leaf metric {
        type string;
      }
      container metric2 {
        leaf metric {
          type string;
        }
      }
    }
    leaf tag {
      type string;
    }
    leaf permanent {
      type empty;
    }
    leaf vrflabel {
      type string;
    }
    leaf tunnel-id {
      type string;
    }
    leaf description {
      type string;
    }
  }

  grouping ncs_template_router-static-grouping {
    container maximum {
      container path {
        leaf ipv4 {
          type string;
        }
        leaf ipv6 {
          type string;
        }
      }
    }
    container address-family {
      container ipv4 {
        container unicast {
          list routes {
            // NCS patched for predictable order
            ordered-by user;
            key "net interface address";
            leaf net {
              type string;
            }
            leaf interface {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-ip {
            // NCS patched for predictable order
            ordered-by user;
            key "net address";
            leaf net {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-if {
            // NCS patched for predictable order
            ordered-by user;
            key "net interface";
            leaf net {
              type string;
            }
            leaf interface {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf interface address";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf interface {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-ip-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf address";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-if-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf interface";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf interface {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
        }
      }
      container ipv6 {
        container unicast {
          list routes {
            // NCS patched for predictable order
            ordered-by user;
            key "net interface address";
            leaf net {
              type string;
            }
            leaf interface {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-ip {
            // NCS patched for predictable order
            ordered-by user;
            key "net address";
            leaf net {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-if {
            // NCS patched for predictable order
            ordered-by user;
            key "net interface";
            leaf net {
              type string;
            }
            leaf interface {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf interface address";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf interface {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-ip-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf address";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf address {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
          list routes-if-vrf {
            // NCS patched for predictable order
            ordered-by user;
            key "net vrf interface";
            leaf net {
              type string;
            }
            leaf vrf {
              type string;
            }
            leaf interface {
              type string;
            }
            uses ncs_template_router-static-options-grouping;
          }
        }
      }
    }
  }

  grouping ncs_template_router-igmp-grouping {
    list interface {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      container explicit-tracking {
        presence true;
      }
      leaf version {
        type string;
      }
      leaf router {
        type string;
      }
      list join-group {
        // NCS patched for predictable order
        ordered-by user;
        key address;
        leaf address {
          type string;
        }
        choice source-choice {
          leaf source-address {
            type string;
          }
          leaf exclude {
            type string;
          }
        }
      }
      list static-group {
        // NCS patched for predictable order
        ordered-by user;
        key address;
        leaf address {
          type string;
        }
        leaf source-address {
          type string;
        }
      }
    }
    container explicit-tracking {
      presence true;
    }
    leaf version {
      type string;
    }
    leaf access-group {
      type string;
    }
    leaf query-interval {
      type string;
    }
    leaf query-max-response-time {
      type string;
    }
    leaf robustness-count {
      type string;
    }
  }

  grouping ncs_template_key-grouping {
    leaf encryption {
      type string;
    }
    leaf key {
      type string;
    }
  }

  grouping ncs_template_l2vpn-bridge-domain-mac-grouping {
    container learning {
      presence true;
      leaf disable {
        type empty;
      }
    }
    container limit {
      leaf maximum {
        type string;
      }
      leaf action {
        type string;
      }
      leaf notification {
        type string;
      }
    }
    container secure {
      leaf action {
        type string;
      }
      leaf logging {
        type empty;
      }
    }
  }

  grouping ncs_template_freqsync-quality-grouping {
    choice quality-type {
      leaf exact {
        type empty;
      }
      leaf highest {
        type empty;
      }
      leaf lowest {
        type empty;
      }
    }
    container itu-t {
      leaf option {
        type string;
      }
      leaf generation {
        // NCS drop when statement
        type string;
      }
      leaf ql1 {
        // NCS drop when statement
        type string;
      }
      leaf ql2 {
        // NCS drop when statement
        type string;
      }
    }
  }

  grouping ncs_template_router-hsrp-group-grouping {
    leaf name {
      type string;
    }
    leaf authentication {
      type string;
    }
    container timers {
      container hello {
        choice hello-timer-choice {
          leaf seconds {
            type string;
          }
          leaf msec {
            type string;
          }
        }
      }
      container hold {
        choice hold-timer-choice {
          leaf seconds {
            type string;
          }
          leaf msec {
            type string;
          }
        }
      }
    }
    leaf mac-address {
      type string;
    }
    container preempt {
      presence true;
      leaf delay {
        type string;
        // NCS drop default statement
      }
    }
    leaf priority {
      type string;
    }
    list track {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf priority-decrement {
        type string;
        // NCS drop default statement
      }
    }
    container bfd {
      container fast-detect {
        presence true;
        container peer {
          container ipv4 {
            leaf ipv4-address {
              type string;
            }
            container interface {
              uses ncs_template_interface-name-grouping;
            }
          }
          container ipv6 {
            leaf ipv6-address {
              type string;
            }
            container interface {
              uses ncs_template_interface-name-grouping;
            }
          }
        }
      }
    }
  }

  grouping ncs_template_router-hsrp-ipv4-group-grouping {
    leaf address {
      type string;
    }
    uses ncs_template_router-hsrp-group-grouping;
  }

  grouping ncs_template_router-hsrp-ipv6-group-grouping {
    uses ncs_template_router-hsrp-group-grouping;
    container address {
      leaf-list global {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      container linklocal {
        choice linklocal-choice {
          leaf address {
            type string;
          }
          container autoconfig {
            presence true;
            leaf legacy-compatible {
              type empty;
            }
          }
        }
      }
    }
  }

  grouping ncs_template_interface-atm-grouping {
    container atm {
      container mcpt-timers {
        leaf timer-1 {
          type string;
        }
        leaf timer-2 {
          type string;
        }
        leaf timer-3 {
          type string;
        }
      }
      container ilmi-keepalive {
        presence true;
      }
    }
    list pvc {
      // NCS patched for predictable order
      ordered-by user;
      key vpi-vci;
      leaf vpi-vci {
        type string;
      }
      uses ncs_template_interface-service-policy-grouping;
      container shape {
        container vbr-nrt {
          leaf peak-output-rate {
            type string;
          }
          leaf sustained-output-rate {
            type string;
          }
          leaf burst-size {
            type string;
          }
        }
      }
      leaf encapsulation {
        type string;
      }
      container oam {
        container retry {
          presence true;
          leaf up-count {
            type string;
          }
          leaf down-count {
            type string;
          }
          leaf retry-frequency {
            type string;
          }
        }
      }
      container oam-pvc {
        container manage {
          presence true;
          leaf disable {
            type empty;
          }
          leaf frequency {
            type string;
          }
        }
      }
      container cell-packing {
        leaf cells {
          type string;
        }
        leaf timer {
          type string;
        }
      }
    }
  }

  grouping ncs_template_ipsla-operation-type-grouping {
    leaf tag {
      type string;
    }
    leaf timeout {
      type string;
    }
    leaf vrf {
      type string;
    }
    container source {
      leaf address {
        type string;
      }
      leaf port {
        type string;
      }
    }
    container destination {
      leaf address {
        type string;
      }
      leaf port {
        type string;
      }
    }
    container statistics {
      leaf hourly {
        type empty;
      }
      leaf buckets {
        type string;
      }
    }
    container packet {
      leaf count {
        type string;
      }
      leaf interval {
        type string;
      }
    }
    leaf tos {
      type string;
    }
    container datasize {
      leaf request {
        type string;
      }
    }
    container target {
      container traffic-eng {
        leaf tunnel {
          type string;
        }
      }
      container pseudowire {
        leaf address {
          type string;
        }
        leaf pw-id {
          type string;
        }
      }
      leaf ipv4 {
        type string;
      }
    }
    leaf frequency {
      type string;
    }
    container statistics-interval {
      container statistics {
        list interval {
          // NCS patched for predictable order
          ordered-by user;
          key seconds;
          leaf seconds {
            type string;
          }
          leaf buckets {
            type string;
          }
        }
      }
    }
  }

  grouping ncs_template_storm-control-grouping {
    container storm-control {
      container broadcast {
        leaf kbps {
          type string;
        }
        leaf pps {
          type string;
        }
      }
      container multicast {
        leaf kbps {
          type string;
        }
        leaf pps {
          type string;
        }
      }
      container unknown-unicast {
        leaf kbps {
          type string;
        }
        leaf pps {
          type string;
        }
      }
    }
  }

  grouping ncs_template_vrf-af-ipv4-grouping {
    container import {
      leaf route-policy {
        type string;
      }
      container route-target {
        uses ncs_template_vrf-route-target-grouping;
      }
      container from {
        container vrf {
          leaf advertise-as-vpn {
            type empty;
          }
        }
        container default-vrf {
          leaf route-policy {
            type string;
          }
          leaf advertise-as-vpn {
            type empty;
          }
        }
      }
    }
    container export {
      leaf route-policy {
        type string;
      }
      container route-target {
        uses ncs_template_vrf-route-target-grouping;
      }
      container to {
        container vrf {
          leaf allow-imported-vpn {
            type empty;
          }
        }
        container default-vrf {
          leaf route-policy {
            type string;
          }
          leaf allow-imported-vpn {
            type empty;
          }
        }
      }
    }
    container maximum {
      container prefix {
        leaf limit {
          type string;
        }
        leaf mid-thresh {
          type string;
        }
      }
    }
  }

  grouping ncs_template_snmp-server-host-grouping {
    list host {
      // NCS patched for predictable order
      ordered-by user;
      key address;
      leaf address {
        type string;
      }
      leaf informs {
        type empty;
      }
      leaf traps {
        type empty;
      }
      leaf version {
        type string;
      }
      leaf security-level {
        // NCS drop when statement
        type string;
      }
      leaf enc {
        type string;
      }
      leaf community-string {
        // NCS drop mandatory statement
        type string;
      }
      leaf udp-port {
        type string;
      }
    }
  }

  grouping ncs_template_multicast-routing-grouping {
    container address-family {
      container ipv4 {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          choice status-choice {
            leaf enable {
              type empty;
            }
            leaf disable {
              type empty;
            }
          }
          leaf boundary {
            type string;
          }
        }
        container interface-inheritance {
          leaf disable {
            type empty;
          }
        }
        leaf nsf {
          type empty;
        }
        leaf log-traps {
          type empty;
        }
        container mdt {
          leaf mtu {
            type string;
          }
          container source {
            uses ncs_template_interface-name-grouping;
          }
          container data {
            container address {
              leaf mdt-group-address {
                type string;
              }
              leaf threshold {
                type string;
                // NCS drop default statement
              }
              leaf acl-name {
                type string;
              }
            }
            container p2mp-te {
              choice max-or-rp-choice {
                container max-number {
                  leaf value {
                    type string;
                  }
                }
                leaf route-policy {
                  type string;
                }
              }
            }
          }
          container default {
            leaf ipv4 {
              type string;
            }
            container mldp {
              list ipv4 {
                // NCS patched for predictable order
                ordered-by user;
                key address;
                leaf address {
                  type string;
                }
                container partitioned {
                  leaf bidir {
                    type empty;
                  }
                }
              }
            }
            container p2mp-te {
              presence true;
              leaf attribute-set {
                type string;
              }
              container static {
                leaf tunnel-mte {
                  type string;
                }
              }
            }
          }
        }
        container bgp {
          container auto-discovery {
            leaf ad-tree {
              type string;
            }
            leaf inter-as {
              type empty;
            }
            leaf leaf-info-required {
              type empty;
            }
          }
        }
        container multipath {
          presence true;
          leaf hash {
            type string;
          }
        }
        container ssm {
          leaf range {
            type string;
          }
          leaf allow-override {
            type empty;
          }
        }
        container oom-handling {
          presence true;
        }
        leaf rate-per-route {
          type empty;
        }
        container accounting {
          container per-prefix {
            presence true;
          }
        }
      }
      container ipv6 {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf enable {
            type empty;
          }
        }
        container multipath {
          presence true;
        }
      }
    }
  }

  grouping ncs_template_router-mld-grouping {
    leaf version {
      type string;
    }
    list interface {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf router {
        type string;
      }
    }
  }

  grouping ncs_template_router-pim-grouping {
    container address-family {
      container ipv4 {
        leaf hello-interval {
          type string;
        }
        container rpf {
          container topology {
            leaf route-policy {
              type string;
            }
          }
        }
        container mdt {
          container c-multicast-routing {
            choice protocol-choice {
              leaf bgp {
                type empty;
              }
              leaf pim {
                type empty;
              }
            }
            container unicast-reachability {
              leaf connector {
                type string;
              }
            }
          }
        }
        container auto-rp {
          container listen {
            leaf disable {
              type empty;
            }
          }
        }
        list rp-address {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf group-access-list {
            type string;
          }
          leaf override {
            type empty;
          }
          leaf bidir {
            type empty;
          }
        }
        leaf accept-register {
          type string;
        }
        container spt-threshold {
          container infinity {
            presence true;
            leaf group-list {
              type string;
            }
          }
        }
        container neighbor-check-on-recv {
          leaf enable {
            type empty;
          }
        }
        container neighbor-check-on-send {
          leaf enable {
            type empty;
          }
        }
        container nsf {
          leaf lifetime {
            type string;
          }
        }
        container log {
          container neighbor {
            leaf changes {
              type empty;
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_bfd-common-parameters-grouping;
          choice status-choice {
            leaf enable {
              type empty;
            }
            leaf disable {
              type empty;
            }
          }
          leaf dr-priority {
            type string;
          }
        }
        container maximum {
          container routes {
            leaf number {
              type string;
            }
            leaf threshold {
              type string;
            }
          }
        }
      }
      container ipv6 {
        leaf neighbor-check-on-recv {
          type string;
        }
        leaf neighbor-check-on-send {
          type string;
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf enable {
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_template_router-rip-redistribute-grouping {
    leaf route-policy {
      type string;
    }
  }

  grouping ncs_template_router-rip-grouping {
    list interface {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf passive-interface {
        type empty;
      }
    }
    container timers {
      container basic {
        leaf update {
          type string;
        }
        leaf invalid {
          type string;
        }
        leaf holddown {
          type string;
        }
        leaf flush {
          type string;
        }
      }
    }
    container redistribute {
      container static {
        presence true;
        uses ncs_template_router-rip-redistribute-grouping;
      }
      list bgp {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        uses ncs_template_router-rip-redistribute-grouping;
      }
    }
  }

  grouping ncs_template_router-vrrp-if-af-vrrp-grouping {
    leaf priority {
      type string;
    }
    container preempt {
      choice preempt-choice {
        leaf delay {
          type string;
        }
        leaf disable {
          type empty;
        }
      }
    }
    container timer {
      choice timer-choice {
        leaf time-value {
          type string;
        }
        leaf msec {
          type string;
        }
      }
      leaf force {
        type empty;
      }
    }
    container track {
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf priority {
          type string;
        }
      }
    }
  }

  grouping ncs_template_router-bgp-af-advertise-grouping {
    container re-originated {
      presence true;
      leaf route-target {
        type string;
      }
    }
    container local {
      presence true;
      leaf route-target {
        type string;
      }
    }
    leaf disable {
      type empty;
    }
    container imported-from-vrf {
      leaf disable {
        type empty;
      }
    }
    container imported-from-default-vrf {
      leaf disable {
        type empty;
      }
    }
  }

  grouping ncs_template_controller-dwdm-grouping {
    list dwdm {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_description-grouping;
      leaf proactive {
        type empty;
      }
      container proactive-conf {
        container proactive {
          container revert {
            container threshold {
              leaf x-coefficient {
                type string;
              }
              leaf y-power {
                type string;
              }
            }
            leaf window {
              type string;
            }
          }
          container trigger {
            container threshold {
              leaf x-coefficient {
                type string;
              }
              leaf y-power {
                type string;
              }
            }
            leaf window {
              type string;
            }
          }
        }
      }
      container g709 {
        leaf enable {
          type empty;
        }
        container fec {
          choice fec-choice {
            leaf ci-bch {
              type empty;
            }
            leaf disable {
              type empty;
            }
            leaf enhanced {
              type string;
            }
            leaf high-gain-hd-fec {
              type empty;
            }
            leaf high-gain-multivendor-hd-fec {
              type empty;
            }
            leaf high-gain-sd-fec {
              type empty;
            }
            leaf long-haul-hd-fec {
              type empty;
            }
            leaf long-haul-sd-fec {
              type empty;
            }
            leaf standard {
              type empty;
            }
          }
        }
        leaf framing {
          type string;
        }
        container odu {
          container overhead {
            container tti {
              container expected {
                leaf ascii {
                  type string;
                }
              }
              container sent {
                leaf ascii {
                  type string;
                }
              }
            }
          }
        }
        container otu {
          container overhead {
            container tti {
              container expected {
                leaf ascii {
                  type string;
                }
              }
              container sent {
                leaf ascii {
                  type string;
                }
              }
            }
          }
          container threshold {
            leaf sf-ber {
              type string;
            }
          }
        }
        leaf tti-processing {
          type empty;
        }
      }
      leaf loopback {
        type string;
      }
      container wavelength {
        choice wave-length-choice {
          leaf channel-number {
            type string;
          }
          leaf frequency {
            type string;
          }
        }
      }
      leaf admin-state {
        type string;
      }
      leaf transmit-power {
        type string;
      }
    }
  }

  grouping ncs_template_controller-grouping {
    uses ncs_template_controller-dwdm-grouping;
    list MgmtMultilink {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      list bundle {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
      }
    }
    list T1 {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_description-grouping;
      leaf mode {
        type string;
      }
      leaf framing {
        type string;
      }
      leaf linecode {
        type string;
      }
      container carrier-delay {
        choice carrier-delay-choice {
          leaf seconds {
            type string;
          }
          leaf msec {
            type string;
          }
        }
      }
      list channel-group {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf speed {
          type string;
        }
        leaf timeslots {
          type string;
        }
      }
      container clock {
        container source {
          choice source-choice {
            leaf internal {
              type empty;
            }
            leaf line {
              type empty;
            }
          }
        }
      }
      container bert {
        leaf error {
          type string;
        }
        leaf interval {
          type string;
        }
        leaf pattern {
          type string;
        }
      }
      leaf shutdown {
        type empty;
      }
      container loopback {
        leaf local {
          type empty;
        }
        leaf network {
          type string;
        }
        container remote {
          choice line-payload {
            container line {
              leaf fdl {
                type string;
              }
              leaf inband {
                type empty;
              }
            }
            container payload {
              leaf fdl {
                type string;
              }
            }
          }
        }
      }
    }
    list T3 {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_description-grouping;
      leaf mode {
        type string;
      }
      container dsu {
        leaf bandwidth {
          type string;
        }
        leaf mode {
          type string;
        }
        leaf remote {
          type string;
        }
      }
      leaf framing {
        type string;
      }
      container delay {
        leaf trigger {
          type string;
        }
      }
      leaf cablelength {
        type string;
      }
      container clock {
        container source {
          choice source-choice {
            leaf internal {
              type empty;
            }
            leaf line {
              type empty;
            }
          }
        }
      }
      container bert {
        leaf error {
          type string;
        }
        leaf interval {
          type string;
        }
        leaf pattern {
          type string;
        }
      }
      leaf shutdown {
        type empty;
      }
      container loopback {
        leaf local {
          type empty;
        }
        leaf network {
          type string;
        }
        leaf remote {
          type string;
        }
      }
    }
    list E1 {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_description-grouping;
      container cem-group {
        leaf unframed {
          type empty;
        }
        list framed {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf timeslots {
            type string;
          }
        }
      }
      leaf framing {
        type string;
      }
      leaf linecode {
        type string;
      }
      list channel-group {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf timeslots {
          type string;
        }
      }
      leaf down-when-looped {
        type empty;
      }
      container clock {
        container source {
          choice source-choice {
            leaf internal {
              type empty;
            }
            leaf line {
              type empty;
            }
            leaf recovered {
              type string;
            }
          }
        }
      }
      leaf shutdown {
        type empty;
      }
    }
    list E3 {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_description-grouping;
      leaf mode {
        type string;
      }
      leaf framing {
        type string;
      }
      container dsu {
        leaf mode {
          type string;
        }
        leaf bandwidth {
          type string;
        }
      }
      leaf down-when-looped {
        type empty;
      }
      container clock {
        container source {
          choice source-choice {
            leaf internal {
              type empty;
            }
            leaf line {
              type empty;
            }
            leaf recovered {
              type string;
            }
          }
        }
      }
      leaf shutdown {
        type empty;
      }
    }
    list SONET {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      uses ncs_template_description-grouping;
      leaf ais-shut {
        type empty;
      }
      container line {
        container delay {
          leaf clear {
            type string;
          }
          leaf trigger {
            type string;
          }
        }
      }
      container path {
        container report {
          leaf pais {
            type empty;
          }
          leaf prdi {
            type empty;
          }
        }
        leaf ais-shut {
          type empty;
        }
        container delay {
          leaf trigger {
            type string;
          }
        }
        leaf scrambling {
          type string;
        }
        container threshold {
          leaf b3-tca {
            type string;
          }
        }
      }
      leaf framing {
        type string;
      }
      container report {
        leaf lais {
          type empty;
        }
        leaf sd-ber {
          type empty;
        }
      }
      container overhead {
        leaf j0 {
          type string;
        }
        leaf s1s0 {
          type string;
        }
      }
      list sts {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf width {
          type string;
        }
        container mode {
          leaf carrying {
            type string;
          }
          leaf pos-option {
            // NCS drop when statement
            type string;
          }
        }
        container delay {
          leaf trigger {
            type string;
          }
        }
      }
      container threshold {
        leaf sf-ber {
          type string;
        }
        leaf b1-tca {
          type string;
        }
        leaf b2-tca {
          type string;
        }
      }
      leaf down-when-looped {
        type empty;
      }
      list au {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf width {
          type string;
        }
        container mode {
          leaf carrying {
            type string;
          }
          leaf pos-option {
            // NCS drop when statement
            type string;
          }
        }
        list tug3 {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container mode {
            leaf carrying {
              type string;
            }
          }
        }
      }
      container clock {
        leaf source {
          type string;
        }
      }
      container s1byte {
        leaf ignore {
          type empty;
        }
      }
      leaf shutdown {
        type empty;
      }
    }
    list wanphy {
      // NCS patched for predictable order
      ordered-by user;
      key id;
      leaf id {
        type string;
      }
      container lanmode {
        leaf on {
          type empty;
        }
      }
      container wanmode {
        leaf on {
          type empty;
        }
      }
    }
  }

  grouping ncs_template_set-list-grouping {
    list set {
      // NCS patched for predictable order
      ordered-by user;
      key value;
      leaf value {
        type string;
      }
    }
  }

  grouping ncs_template_ipsla-reaction-operation-react-grouping {
    container action {
      leaf logging {
        type empty;
      }
      leaf trigger {
        type empty;
      }
    }
    container threshold {
      container type {
        choice type-choice {
          leaf immediate {
            type empty;
          }
          leaf consecutive {
            type string;
          }
          leaf average {
            type string;
          }
        }
      }
      container limit {
        leaf lower-limit {
          type string;
        }
        leaf upper-limit {
          type string;
        }
      }
    }
  }

  grouping ncs_template_interface-tunnel-te-auto-bw-threshold-grouping {
    container threshold {
      leaf percentage {
        type string;
      }
      leaf min {
        type string;
      }
      leaf limit {
        type string;
      }
    }
  }

  grouping ncs_template_router-ospf-domain-id-grouping {
    leaf type {
      type string;
    }
    leaf value {
      type string;
    }
  }

  grouping ncs_template_explicit-path-index-list-grouping {
    list index {
      // NCS patched for predictable order
      ordered-by user;
      key index-id;
      leaf index-id {
        type string;
      }
      leaf keyword {
        type string;
      }
      leaf hop-type {
        // NCS drop when statement
        type string;
      }
      leaf label {
        // NCS drop when statement
        type string;
      }
      container ipv4 {
        leaf unicast {
          type string;
        }
      }
    }
  }

  grouping ncs_template_route-target-import-export-grouping {
    container route-target {
      list route-target-list {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
      leaf-list import {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf-list export {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
  }

  grouping ncs_template_username-grouping {
    list username {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      list group {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
      container password {
        leaf encryption {
          type string;
        }
        leaf password {
          type string;
        }
      }
      leaf privilege {
        type string;
      }
      container secret {
        leaf encryption {
          type string;
        }
        leaf password {
          type string;
        }
      }
    }
  }

  grouping ncs_template_clock-grouping {
    container clock {
      leaf calendar-valid {
        type empty;
      }
      container summer-time {
        leaf zone {
          type string;
        }
        choice summer {
          case a {
            container date;
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              type string;
            }
            leaf start-day {
              type string;
            }
            leaf start-month {
              type string;
            }
            leaf start-time {
              type string;
            }
            leaf end {
              type string;
            }
            leaf end-day {
              type string;
            }
            leaf end-month {
              type string;
            }
            leaf end-time {
              type string;
            }
          }
        }
      }
      container timezone {
        leaf zone {
          type string;
        }
        leaf hours-offset {
          type string;
        }
        leaf minutes-offset {
          type string;
        }
      }
    }
  }

  grouping ncs_template_exception-grouping {
    container exception {
      container exception-filepath {
        leaf choice {
          type string;
        }
        leaf compress {
          type string;
        }
        container filename {
          leaf name {
            type string;
          }
          leaf limit {
            type string;
          }
        }
        leaf filepath {
          type string;
        }
      }
      leaf sparse {
        type string;
      }
      leaf sprsize {
        type string;
      }
      leaf coresize {
        type string;
      }
      leaf pakmem {
        type string;
      }
    }
  }

  grouping ncs_template_average-cpu-used-grouping {
    leaf op {
      type string;
    }
    leaf threshold {
      type string;
    }
    leaf percent {
      type empty;
    }
    container rearm {
      choice rearm-choice {
        leaf toggle {
          type empty;
        }
        leaf window {
          type string;
        }
      }
    }
  }

  grouping ncs_rpc_notif_description-grouping {
    leaf description {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  grouping ncs_rpc_notif_banner-grouping {
    leaf start-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;delimitting start character";
        length 1;
      }
    }
    leaf message {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;quoted banner message";
      }
    }
    leaf end-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      must "../end-marker = ../start-marker" {
        tailf:xpath-root 3;
        tailf:dependency "../start-marker";
        tailf:dependency "../end-marker";
      }
      type string {
        tailf:info "WORD;;delimitting end character";
        length 1;
      }
    }
  }

  grouping ncs_rpc_notif_vrf-route-target-grouping {
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info
            "<1-65535>:<0-4294967295>;;ASN2:index
             <65536-4294967295>:<0-65535>;;ASN4:index
             <IP address>:<0-65535>;;IPAddress:index (hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
    }
    list stitching-address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      key name;
      leaf name {
        type string {
          tailf:info
            "<1-65535>:<0-4294967295>;;ASN2:index
             <65536-4294967295>:<0-65535>;;ASN4:index
             <IP address>:<0-65535>;;IPAddress:index (hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
      leaf stitching {
        tailf:info "These are stitching RTs";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_router-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      // NCS drop tailf-common:non-strict-leafref statement
    }
  }

  grouping ncs_rpc_notif_router-ospf-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum 1 {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum 2 {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      // NCS drop tailf-common:non-strict-leafref statement
    }
  }

  grouping ncs_rpc_notif_router-isis-af-redistribute-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "Redistribute routes into level 1 only";
        }
        enum level-1-2 {
          tailf:info "Redistribute routes into both levels";
        }
        enum level-2 {
          tailf:info "Redistribute routes into level 2 only (the default)";
        }
      }
    }
    uses ncs_rpc_notif_router-af-redistribute-grouping;
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "External metric type";
        }
        enum internal {
          tailf:info "Internal metric type";
        }
        enum rib-metric-as-external {
          tailf:info "External metric type and use RIB metric";
        }
        enum rib-metric-as-internal {
          tailf:info "Internal metric type and use RIB metric";
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-ospf-authentication-grouping {
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice authentication-choice {
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf keychain {
            tailf:info "Specify keychain name";
            type string {
              tailf:info "WORD;;The keychain name";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
        leaf null {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:info "Key ID";
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        choice md5-choice {
          leaf key {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED password (key)";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_bfd-common-parameters-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "Prevent bfd settings from being inherited from the parent";
          type empty;
        }
      }
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-50>;;Detect multiplier";
          range "2..50";
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-ospf-common-area-grouping {
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }
    container passive {
      tailf:info "Enable/Disable passive";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:info "Enable/Disable passive mode";
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable passive";
          }
          enum enable {
            tailf:info "Enable passive";
          }
        }
      }
    }
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum enable {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }
    leaf dead-interval {
      tailf:info "Dead interval time";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
    container fast-reroute {
      tailf:info "IP Fast Reroute";
      choice per-link-or-prefix {
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }
        container per-link {
          tailf:info "Per-link Computation";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          presence true;
          leaf enable {
            type empty;
          }
        }
        leaf per-prefix {
          tailf:info "Per-prefix Computation";
          type empty;
        }
      }
      container per-prefix-conf {
        tailf:cli-drop-node-name;
        container per-prefix {
          tailf:info "Per-prefix Computation";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          container remote-lfa {
            tailf:info "Remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              leaf mpls-ldp {
                tailf:info "MPLS LDP tunnel";
                type empty;
              }
            }
          }
        }
      }
    }
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
  }

  grouping ncs_rpc_notif_router-ospf-area-grouping {
    uses ncs_rpc_notif_bfd-common-parameters-grouping;
    uses ncs_rpc_notif_router-ospf-common-area-grouping;
    uses ncs_rpc_notif_router-ospf-authentication-grouping;
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum non-broadcast {
          tailf:info "Specify OSPF NBMA network";
        }
        enum point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum point-to-point {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          tailf:cli-full-command;
          type empty;
        }
        container sync-igp-shortcuts {
          tailf:info "LDP sync for igp-shortcut tunnels";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync igp-shortcuts";
            type empty;
          }
        }
      }
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }
    container prefix-sid {
      tailf:info "Prefix SID Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice prefix-sid-choice {
        leaf absolute {
          tailf:info "SID value";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<16000-1048575>;;SID label";
            range "16000..1048575";
          }
        }
        leaf index {
          tailf:info "SID Index";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<0-1048575>;;SID Index";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Force penultimate hop to send explicit-null label";
        type empty;
      }
    }
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address (name)";
        }
      }
      leaf priority {
        tailf:info "OSPF priority of non-broadcast neighbor";
        type uint8 {
          tailf:info "<0-255>;;Priority";
        }
      }
    }
    container nssa {
      tailf:info "Specify area as a NSSA area";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf no-redistribution {
        tailf:info "No redistribution into this NSSA area";
        type empty;
      }
      leaf default-information-originate {
        tailf:info "Originate Type 7 default into NSSA area";
        type empty;
      }
      leaf metric {
        tailf:info "OSPF default metric";
        when "../default-information-originate" {
          tailf:xpath-root 3;
        }
        type uint32 {
          tailf:info "<0-16777214>;;OSPF metric";
          range "0..16777214";
        }
      }
      leaf metric-type {
        tailf:info "OSPF metric type for default routes";
        when "../default-information-originate" {
          tailf:xpath-root 3;
        }
        type uint8 {
          tailf:info "<1-2>;;Link State metric type";
          range "1..2";
        }
      }
      leaf no-summary {
        tailf:info "Do not send summary LSA into NSSA";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_router-ospfvx-common-pre-grouping {
    leaf nsr {
      tailf:info "Enable NSR for all VRFs in this process";
      tailf:cli-full-command;
      type empty;
    }
    leaf router-id {
      tailf:info "Specify the router-id for this OSPF process";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
      }
    }
    uses ncs_rpc_notif_router-ospf-common-area-grouping;
    container log {
      tailf:info "Log ospf info";
      container adjacency {
        tailf:info "Log adjacency state info";
        container changes {
          tailf:info "Log changes";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf changes-state {
            tailf:info "Log all state changes or disable logging";
            tailf:cli-drop-node-name;
            type enumeration {
              enum detail {
                tailf:info "Log all state changes";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container throttle {
        tailf:info "OSPF throttle timers";
        container lsa {
          tailf:info "LSA throttle timers";
          container all {
            tailf:info "For all types of OSPF LSAs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf delay {
              tailf:info "Delay to generate first occurrence of LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<0-600000>;;Delay to generate first occurrence of LSA in milliseconds";
                range "0..600000";
              }
            }
            leaf min-delay {
              tailf:info "Minimum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-600000>;;Minimum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
            leaf max-delay {
              tailf:info "Maximum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-600000>;;Maximum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
          }
        }
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf delay {
            tailf:info "Delay between receiving a change to SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between receiving a change to SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf min-delay {
            tailf:info "Delay between first and second SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between first and second SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf max-delay {
            tailf:info "Maximum wait time in milliseconds for SPF calculations";
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-600000>;;Maximum wait time in milliseconds for SPF calculations";
              range "1..600000";
            }
          }
        }
      }
      container lsa {
        tailf:info "OSPF global LSA timers";
        leaf min-arrival {
          tailf:info "OSPF MinLSArrival timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in millisec between accepting the same LSA";
            range "0..600000";
          }
        }
      }
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          type uint8 {
            tailf:info "<5-100>;;Interval in msec to pace flooding on all interfaces";
            range "5..100";
          }
        }
      }
    }
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-delete-when-empty;
      presence true;
      leaf reference-bandwidth {
        tailf:info "Specify reference bandwidth for OSPF cost computations";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of Mbits per second";
          range "1..4294967";
        }
      }
    }
    container maximum {
      tailf:info "Set OSPF limits";
      leaf paths {
        tailf:info "Limit number of paths";
        type uint8 {
          tailf:info "<1-64>;;Maximum number of paths per route";
          range "1..64";
        }
      }
      leaf interfaces {
        tailf:info "Limit number of interfaces";
        type uint32 {
          tailf:info "<1-4294967295>;;Maximum number of interfaces";
        }
      }
      container redistributed-prefixes {
        tailf:info "Limit number of redistributed prefixes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of prefixes redistributed into OSPF";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning messsage when limit is exceeded";
          type empty;
        }
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-full-command;
        type empty;
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-30000>;;hello interval in milli-seconds";
          range "0..30000";
        }
      }
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-30>;;Detect multiplier";
        }
      }
    }
    container network {
      tailf:info "Network type";
      choice network-choice {
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF non-broadcast point-to-multipoint network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
      }
    }
    container domain-id {
      tailf:info "Specify domain id";
      container primary {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses ncs_rpc_notif_router-ospf-domain-id-grouping;
      }
      container secondary {
        tailf:info "OSPF secondary domain-id";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses ncs_rpc_notif_router-ospf-domain-id-grouping;
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
    }
    container spf {
      tailf:info "SPF configuration";
      container prefix-priority {
        tailf:info "Configure SPF prefix priority route policy";
        leaf route-policy {
          tailf:info "Specify the route-policy to prioritize route install";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
    container distance {
      tailf:info "Define an administrative distance";
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf weight {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Wild Card bits";
          }
        }
        leaf access-list-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access list";
          }
        }
      }
      container ospf {
        tailf:info "OSPF distance";
        container external {
          tailf:info "External type 5 and type 7 routes";
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Distance for external type 5 and type 7 routes";
              range "1..255";
            }
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:info "AS number in 2-byte, 4-byte asdot and asplain";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        leaf preserve-med {
          tailf:info "Preserve med of BGP routes";
          type empty;
        }
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Redistribute routes into level 1 only";
            }
            enum level-1-2 {
              tailf:info "Redistribute routes into both levels";
            }
            enum level-2 {
              tailf:info "Redistribute routes into level 2 only (the default)";
            }
          }
        }
        uses ncs_rpc_notif_router-ospf-af-redistribute-grouping;
      }
    }
  }

  grouping ncs_rpc_notif_router-ospfvx-common-post-grouping {
    list area {
      tailf:info "Enter the OSPF area configuration submode";
      tailf:cli-mode-name config-ospf-ar;
      key id;
      leaf id {
        tailf:info "Area id";
        tailf:cli-suppress-range;
        type ospf-area-type;
      }
      uses ncs_rpc_notif_router-ospf-area-grouping;
      container stub {
        tailf:info "Specify the area as a stub area";
        tailf:cli-delete-when-empty;
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
      }
      list multi-area-interface {
        tailf:info "Enable multi-area adjacency on this interface";
        tailf:cli-mode-name config-ospf-ar-mif;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses ncs_rpc_notif_router-ospf-area-grouping;
      }
      list interface {
        tailf:info "Enable routing on an interface";
        tailf:cli-mode-name config-ospf-ar-if;
        key name;
        leaf name {
          tailf:info "Interface Name";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses ncs_rpc_notif_router-ospf-area-grouping;
      }
    }
  }

  grouping ncs_rpc_notif_router-ospf-grouping {
    uses ncs_rpc_notif_router-ospfvx-common-pre-grouping;
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routing updates";
          }
          enum out {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    container distribute-list-proto {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key direction;
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value out;
          type string {
            tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
        leaf direction {
          type enumeration {
            enum out {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf connected {
          tailf:cli-break-sequence-commands;
          tailf:info Connected;
          type empty;
        }
        leaf static {
          tailf:info "Static routes";
          type empty;
        }
        leaf bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern "[0-9]+\\.[0-9]+";
            }
          }
        }
        leaf ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
      }
    }
    uses ncs_rpc_notif_router-ospfvx-common-post-grouping;
    container nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";
      container ietf {
        tailf:info "Enable ietf graceful restart";
        tailf:cli-display-separated;
        presence true;
        container helper {
          tailf:info "router's helper support level";
          leaf disable {
            tailf:info "router's helper support disabled";
            type empty;
          }
        }
      }
      container cisco {
        tailf:info "Enable Cisco Non Stop Forwarding";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware neighbors detected";
          leaf global {
            tailf:info "For the whole OSPF process";
            type empty;
          }
        }
      }
    }
    container queue {
      tailf:info "Adjust OSPF input queue";
      container limit {
        tailf:info "High watermark for incoming priority events";
        leaf low {
          tailf:info "High watermark for incoming low priority events (DBD/LSUpd/Req)";
          type uint16 {
            tailf:info "<1000-30000>;;DBD/LS Update/Req packets are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        leaf high {
          tailf:info "High watermark for incoming high priority events (hello)";
          type uint16 {
            tailf:info "<1000-30000>;;Hello events are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        leaf medium {
          tailf:info "High watermark for incoming medium priority events (LSA ACK)";
          type uint16 {
            tailf:info "<1000-30000>;;LSA ACKs are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
      }
    }
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }
    container segment-routing {
      tailf:info "Segment Routing configuration";
      container global-block {
        tailf:info "MPLS label range for SID allocation";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }
      choice mpls-disable-choice {
        leaf mpls {
          tailf:info "SR using MPLS dataplane";
          type empty;
        }
        leaf disable {
          tailf:info "Disable Segment Routing";
          type empty;
        }
      }
      leaf forwarding {
        tailf:info "Enable Segment-routing forwarding on interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable advertising loopback as a stub network";
          }
          enum mpls {
            tailf:info "Use MPLS for Segment-routing forwarding";
          }
        }
      }
      container sr-prefer {
        tailf:info "Prefer segment routing labels over LDP labels";
        presence true;
        leaf prefix-list {
          tailf:info "Filter prefixes for which SR preference is applied";
          type string {
            tailf:info "WORD;;Prefix-list name";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      container prefix-sid-map {
        tailf:info "Configuring segment routing mapping server";
        container receive {
          tailf:info "Control the usage of remote mapping server advertisements";
          presence true;
          leaf disable {
            tailf:info "Disable the usage of remote mapping server advertisements";
            type empty;
          }
        }
        leaf advertise-local {
          tailf:info "Advertise and use local mapping server entries";
          type empty;
        }
      }
    }
    container address-family {
      tailf:info "OSPF address family";
      container ipv4 {
        tailf:info "IPV4 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        leaf on-startup {
          tailf:info "On startup";
          tailf:cli-optional-in-sequence;
          type union {
            type uint32 {
              tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
              range "5..86400";
            }
            type enumeration {
              enum wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA with normal metric";
              }
            }
          }
        }
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        choice external-lsa-choice {
          container external-lsa-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf external-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf external-lsa {
            tailf:info "Override external-lsa metric with max-metric";
            type empty;
          }
        }
        choice summary-lsa-choice {
          container summary-lsa-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf summary-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf summary-lsa {
            tailf:info "Override summary-lsa metric with max-metric value";
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-ospfv3-grouping {
    container graceful-restart {
      tailf:info "Enable Graceful-Restart";
      presence true;
    }
    uses ncs_rpc_notif_router-ospfvx-common-pre-grouping;
    uses ncs_rpc_notif_router-ospfvx-common-post-grouping;
    container address-family {
      tailf:info "OSPF address family";
      container ipv6 {
        tailf:info "IPV6 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-isis-common-af-grouping {
    leaf metric {
      tailf:info "Configure metric";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
          range "1..16777214";
        }
        type enumeration {
          enum maximum {
            tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
          }
        }
      }
    }
    container metric-level {
      tailf:cli-drop-node-name;
      list metric {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:info "Set metric for one level only";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Set metric at this level only";
            range "1..2";
          }
        }
        leaf value {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
      }
    }
    container fast-reroute {
      tailf:info "Configure Fast ReRoute";
      choice fast-reroute-choice {
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }
        container per-prefix {
          tailf:info "Prefix dependent computation";
          tailf:cli-display-separated;
          presence true;
          leaf-list level {
            tailf:info "Configure FRR for one level only";
            tailf:cli-list-syntax;
            type uint8 {
              tailf:info "<1-2>;;Level";
              range "1..2";
            }
          }
          container remote-lfa {
            tailf:info "Enable remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              container mpls-ldp {
                tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
                tailf:cli-display-separated;
                presence true;
              }
            }
          }
          container ti-lfa {
            tailf:info "Enable TI LFA computation";
            presence true;
          }
        }
      }
    }
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          type empty;
        }
        container sync {
          tailf:info "Configure LDP ISIS synchronization";
          presence true;
          leaf level {
            type uint8 {
              tailf:info "<1-2>;;Set LDP synchronization at this level only";
              range "1..2";
            }
          }
        }
      }
      container traffic-eng {
        tailf:info "Routing protocol commands for MPLS Traffic Engineering";
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum level-1 {
              tailf:info "Enable mpls traffic-eng at level 1";
            }
            enum level-1-2 {
              tailf:info "Enable mpls traffic-eng at both level 1 and 2";
            }
            enum level-2-only {
              tailf:info "Enable mpls traffic-eng at level 2";
            }
          }
        }
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses ncs_rpc_notif_interface-name-grouping;
        }
        leaf multicast-intact {
          tailf:info "Install non-TE nexthops in the RIB for use by multicast";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
    container monitor-convergence {
      tailf:info "Enables convergence monitoring";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-isis-af-rcmd;
      tailf:cli-delete-when-empty;
      presence true;
      leaf track-ip-frr {
        tailf:info "Enables Tracking IP-Frr Convergence";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Set interface tag";
      type uint32 {
        tailf:info "<1-4294967295>;;Interface tag";
      }
    }
  }

  grouping ncs_rpc_notif_router-isis-af-grouping {
    container advertise {
      tailf:info "Control the advertisement of prefixes in LSPs";
      leaf passive-only {
        tailf:info "advertise prefixes of passive interfaces only";
        type empty;
      }
    }
    leaf ispf {
      tailf:info "Use incremental SPF (ISPF) to calculate network topology";
      type empty;
    }
    container ispf-conf {
      tailf:cli-drop-node-name;
      container ispf {
        tailf:info "Use incremental SPF (ISPF) to calculate network topology";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf-list level {
          tailf:info "Enable ISPF for one level only";
          tailf:cli-list-syntax;
          type uint8 {
            tailf:info "<1-2>;;Enable ISPF for this level onl";
            range "1..2";
          }
        }
      }
    }
    container spf-interval {
      tailf:info "Route calculation scheduling parameters (FSPF, ISPF, PRC)";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf maximum-wait {
        tailf:info "Maximum delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf initial-wait {
        tailf:info "Initial delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf secondary-wait {
        tailf:info "Secondary delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
    }
    leaf single-topology {
      tailf:info "Run IPv6 Unicast using the standard (IPv4 Unicast) topology";
      type empty;
    }
    container adjacency-check {
      tailf:info "Suppress checking of consistent AF support on received IIHs";
      leaf disable {
        tailf:info "Disable adjacency-checking";
        type empty;
      }
    }
    container spf {
      tailf:info "SPF configuration";
      list prefix-priority {
        tailf:info "Configure a prefix priority list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key priority;
        leaf priority {
          type enumeration {
            enum critical {
              tailf:info "Specify critical priority prefixes";
            }
            enum high {
              tailf:info "Specify critical priority prefixes";
            }
            enum medium {
              tailf:info "Specify critical priority prefixes";
            }
          }
        }
        choice priority-type {
          leaf access-list {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Access-list name";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf tag {
            tailf:info "Specify a tag to indicate priority";
            type uint32 {
              tailf:info "<1-4294967295>;;The tag to indicate priority";
            }
          }
        }
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf external {
          tailf:info "Originate default prefix as an external route";
          type empty;
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
    leaf maximum-paths {
      tailf:info "Maximum number of active parallel paths per route";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64>;;Number of paths";
        range "1..64";
      }
    }
    container propagate {
      tailf:info "Propagate routes between IS-IS levels";
      list level {
        tailf:info "Source level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "from level";
        leaf from {
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf into {
          tailf:info into;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type empty;
        }
        leaf level {
          tailf:info "Destination level";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf route-policy {
          tailf:info "Propagate only specified routes";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
    container microloop {
      tailf:info "Enable microloop protection feature";
      container avoidance {
        tailf:info "Enable local microloop avoidance";
        leaf rib-update-delay {
          tailf:info "Delay in milliseconds";
          type uint16 {
            tailf:info "<1000-65535>;;Set value of delay";
            range "1000..65535";
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-isis-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-isis-af-redistribute-grouping;
      }
      list isis {
        tailf:info IS-IS;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "IS-IS instance identifier";
          }
        }
        uses ncs_rpc_notif_router-isis-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum external {
              tailf:info "Redistribute OSPF external routes";
            }
            enum internal {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum nssa-external {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses ncs_rpc_notif_router-isis-af-redistribute-grouping;
      }
      list ospfv3 {
        tailf:info "Open Shortest Path First (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum external {
              tailf:info "Redistribute OSPF external routes";
            }
            enum internal {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum nssa-external {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses ncs_rpc_notif_router-isis-af-redistribute-grouping;
      }
    }
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";
      container mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        presence true;
      }
      container prefix-sid-map {
        tailf:info "Enable prefix-sid-map";
        container receive {
          tailf:info "Use remote mapping server advertisements";
          presence true;
        }
        leaf advertise-local {
          tailf:info "Advertise active local prefix-SID mappings";
          type empty;
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-isis-common-grouping {
    leaf metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      tailf:cli-full-command;
      type enumeration {
        enum narrow {
          tailf:info "Use old style of TLVs with narrow metric";
        }
        enum transition {
          tailf:info "Send and accept both styles of TLVs during transition";
        }
        enum wide {
          tailf:info "Use new style of TLVs to carry wider metric";
        }
      }
    }
    container metric-style-list {
      tailf:cli-drop-node-name;
      list metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set metric-style for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf style {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum narrow {
              tailf:info "Use old style of TLVs with narrow metric";
            }
            enum transition {
              tailf:info "Send and accept both styles of TLVs during transition";
            }
            enum wide {
              tailf:info "Use new style of TLVs to carry wider metric";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-isis-if-af-grouping {
    container prefix-sid {
      tailf:info "Specify the Prefix Segment ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice value-choice {
        leaf absolute {
          tailf:info "Specify the absolute value of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
        leaf index {
          tailf:info "Specify the index of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf n-flag-clear {
        tailf:info "Clear N-flag for the prefix-SID ";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;First VTY number";
      }
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;Last VTY number";
      }
    }
    leaf line-template {
      tailf:info "Line template to configure VTYs";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Name of line template";
      }
    }
  }

  grouping ncs_rpc_notif_line-grouping {
    container flowcontrol {
      tailf:info "Configure flow control.";
      container hardware {
        tailf:info "Hardware flow control.";
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound flow control.";
            }
            enum none {
              tailf:info "No flow control.";
            }
            enum out {
              tailf:info "Outbound flow control.";
            }
          }
        }
      }
    }
    leaf parity {
      tailf:info "Set the parity used.";
      type enumeration {
        enum even {
          tailf:info "Even parity.";
        }
        enum none {
          tailf:info "No parity.";
        }
        enum odd {
          tailf:info "Odd parity.";
        }
      }
    }
    leaf databits {
      tailf:info "Set the number of databits.";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<5-8>;;Number of databits the serial connection should use.";
      }
    }
    leaf stopbits {
      tailf:info "Set the stopbits used.";
      tailf:cli-full-command;
      type enumeration {
        enum 1 {
          tailf:info "One stopbit.";
        }
        enum 2 {
          tailf:info "Two stopbits.";
        }
      }
    }
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }
    container secret {
      tailf:info "Provide a secure one way encrypted password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum 0 {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum 5 {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }
    container users {
      tailf:info "Users characteristics";
      list group {
        tailf:info "Group to which the user will belong";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
    }
    container accounting {
      tailf:info "Accounting parameters";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
    }
    container authorization {
      tailf:info "Authorization parameters";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
            range "0..300";
          }
        }
      }
    }
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }
    container transport {
      tailf:info "Define transport protocols for line";
      leaf-list input {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat;
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }
      leaf-list output {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "Unix ssh protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
          range "0..35791";
        }
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
          range "0..2147483";
        }
      }
    }
    leaf length {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
        range "0..512";
      }
    }
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
        range "0..512";
      }
    }
    container login {
      tailf:info "Enable password checking";
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    leaf session-limit {
      tailf:info "Set the number of outgoing connections";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-20>;;Number of outgoing connections";
        range "0..20";
      }
    }
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of a CR followed by a LF";
        type empty;
      }
    }
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf output {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }
    leaf escape-character {
      tailf:info "Change the current line template's escape character";
      type string {
        tailf:info "WORD;;Escape character or its ASCII decimal equivalent";
      }
    }
  }

  grouping ncs_rpc_notif_lpts-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;flow type";
        }
      }
      leaf ospf-type {
        when "../name = 'ospf'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum multicast {
            tailf:info Multicast;
          }
          enum unicast {
            tailf:info Unicast;
          }
        }
      }
      leaf ldp-type {
        when "../name = 'ldp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum tcp {
            tailf:info TCP;
          }
          enum udp {
            tailf:info UDP;
          }
        }
      }
      leaf rsvp-type {
        when "../name = 'rsvp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum udp {
            tailf:info UDP;
          }
        }
      }
      leaf raw-type {
        when "../name = 'raw'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum listen {
            tailf:info Listen;
          }
        }
      }
      leaf udp-tcp-type {
        when "../name = 'udp' or ../name = 'tcp'" {
          tailf:xpath-root 3;
          tailf:dependency "../name";
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum configured {
            tailf:info "Config peer";
          }
          enum listen {
            tailf:info Listen;
          }
        }
      }
      leaf icmp-type {
        when "../name = 'icmp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum application {
            tailf:info "Specific application packets";
          }
          enum control {
            tailf:info "Control packets";
          }
          enum generic {
            tailf:info "Generic application packets";
          }
          enum local {
            tailf:info "Local interest packets";
          }
        }
      }
      leaf which {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum default {
            tailf:info Default;
          }
          enum known {
            tailf:info Known;
          }
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
    }
  }

  grouping ncs_rpc_notif_class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }

  grouping ncs_rpc_notif_class-map-match-grouping {
    container access-group {
      tailf:info "Match access group";
      leaf ipv4 {
        tailf:info "IPv4 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf ipv6 {
        tailf:info "IPv6 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    leaf any {
      tailf:info "Any packets";
      type empty;
    }
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    container destination-address {
      tailf:info "Match based on destination address";
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
    leaf-list destination-port {
      tailf:info "Match based on destination port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }
    container dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";
      leaf-list dscp-list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      leaf-list ipv4 {
        tailf:info "IPV4 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      leaf-list ipv6 {
        tailf:info "IPV6 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
    }
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum 1 {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }
    container packet {
      tailf:info "Layer 3 Packet length";
      leaf-list length {
        tailf:info "Layer 3 Packet length";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "<0-65535>;;IP packet length, value or range x-y";
        }
      }
    }
    container precedence {
      tailf:info "Match based on IP precedence values";
      leaf-list ipv4 {
        tailf:info "IPV4 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      leaf-list ipv6 {
        tailf:info "IPV6 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      leaf-list list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
    }
    leaf-list protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      tailf:cli-flat-list-syntax;
      max-elements 8;
      type union {
        type uint8 {
          tailf:info "<0-255>;;An IP Protocol Number";
        }
        type string {
          tailf:info "<0-255>-<0-255>;;Lower-Upper limit of protocol range to match";
          pattern "[0-9]+\\-[0-9]+";
        }
        type enumeration {
          enum ahp {
            tailf:info "Authentication Header Protocol";
            value 51;
          }
          enum eigrp {
            tailf:info "Cisco's EIGRP Routing Protocol";
            value 88;
          }
          enum esp {
            tailf:info "Encapsulation Security Payload";
            value 50;
          }
          enum gre {
            tailf:info "Cisco's GRE Tunneling";
            value 47;
          }
          enum icmp {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum igmp {
            tailf:info "Internet Gateway Message Protocol";
            value 2;
          }
          enum igrp {
            tailf:info "Cisco's IGRP Routing Protocol";
            value 9;
          }
          enum ipinip {
            tailf:info "IP in IP tunneling";
            value 1001;
          }
          enum ipv4 {
            tailf:info "Any IPv4 Protocol";
            value 0;
          }
          enum ipv6 {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum ipv6icmp {
            tailf:info "IPV6Internet Control Message Protocol";
            value 58;
          }
          enum mpls {
            tailf:info "Any MPLS Packet";
            value 137;
          }
          enum nos {
            tailf:info "KA9Q NOS Compatible IP over IP Tunneling";
            value 94;
          }
          enum ospf {
            tailf:info "OSPF Routing Protocol";
            value 89;
          }
          enum pcp {
            tailf:info "Payload Compression Protocol";
            value 108;
          }
          enum pim {
            tailf:info "Protocol Independent Multicast";
            value 103;
          }
          enum sctp {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum tcp {
            tailf:info "Transport Control Protocol";
            value 6;
          }
          enum udp {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
      }
    }
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }
    container source-address {
      tailf:info "Match based on source address";
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
    leaf-list source-port {
      tailf:info "Match based on source port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }
    container vlan {
      tailf:info "Match based on Vlan Ids (Upto 8 values or ranges)";
      leaf-list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
      leaf-list inner {
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
    }
    container vpls {
      tailf:info "Match based on VPLS fields";
      leaf control {
        tailf:info "VPLS Control";
        tailf:cli-full-command;
        type empty;
      }
      leaf broadcast {
        tailf:info "VPLS Broadcast";
        tailf:cli-full-command;
        type empty;
      }
      leaf known {
        tailf:info "VPLS Known";
        type empty;
      }
      leaf multicast {
        tailf:info "VPLS Multicast";
        type empty;
      }
      leaf unknown {
        tailf:info "VPLS Unknown";
        type empty;
      }
    }
    leaf dei {
      tailf:info "Match based on DEI bit (0/1)";
      type uint8 {
        tailf:info "0-1;;DEI value";
        range "0..1";
      }
    }
  }

  grouping ncs_rpc_notif_lsp-status-grouping {
    container lsp-status {
      tailf:info "Enable interface LSP state change alarms";
      leaf reoptimize {
        tailf:info "Enable interface LSP REOPT change alarms";
        type empty;
      }
      leaf state {
        tailf:info "Enable interface LSP UP/DOWN change alarms";
        type empty;
      }
      leaf reroute {
        tailf:info "Enable interface LSP REROUTE change alarms";
        type empty;
      }
      leaf insufficient-bandwidth {
        tailf:info "Enable Syslog for setup/reopt failure due to bandwidth";
        type empty;
      }
      leaf bw-change {
        tailf:info "Enable interface LSP BANDWIDTH change alarms";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-service-policy-content-grouping {
    container account {
      tailf:info "Turn off layer specific accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      choice account-choice {
        leaf nolayer2 {
          tailf:info "Turn off l2 accounting";
          type empty;
        }
        leaf user-defined {
          tailf:info "User defined accounting";
          type int8 {
            tailf:info "<-63,+63>;;Overhead accounting value";
            range "-63..63";
          }
        }
      }
    }
    leaf subscriber-parent {
      tailf:info "Configure an svlan policy";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    leaf resource-id {
      when "../subscriber-parent" {
        tailf:xpath-root 3;
      }
      tailf:info "Configure a resource-id";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-3>;;resource-id value";
        range "0..3";
      }
    }
    leaf shared-policy-instance {
      tailf:info "Configure a shared-policy-instance";
      type string {
        tailf:info "WORD;;Name of the shared-policy-instance";
      }
    }
  }

  grouping ncs_rpc_notif_interface-service-policy-grouping {
    container service-policy {
      tailf:info "Configure QoS Service Policy";
      container input {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
        uses ncs_rpc_notif_interface-service-policy-content-grouping;
      }
      container output {
        tailf:info "direction of service policy application";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
        uses ncs_rpc_notif_interface-service-policy-content-grouping;
      }
      container type {
        tailf:info "Enter service policy type (default: qos)";
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container test {
          tailf:info "Configure Test Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container pbr {
          tailf:info "Policy based routing Service policy";
          leaf input {
            tailf:info "Configure a policy in the input direction";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
        container control {
          tailf:info "control policy";
          leaf subscriber {
            tailf:info "subscriber policy";
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-isis-grouping {
    container isis {
      tailf:info "IS-IS commands";
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        leaf key-chain {
          tailf:info "Authentication key-chain";
          type string;
          // NCS drop tailf-common:non-strict-leafref statement
        }
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-switch-grouping {
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }
    container switch {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }
    container switchport-conf {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:info "Set switching mode characteristics";
        tailf:cli-boolean-no;
        type boolean;
      }
    }
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode";
            range "1..4094";
          }
        }
      }
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        type empty;
      }
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-bundle-grouping {
    container bundle {
      tailf:info "Bundle interface commands";
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds (default: 2000)";
          range "0..2000";
        }
      }
      container load-balancing {
        tailf:info "Load balancing commands on a bundle";
        leaf hash {
          tailf:info "Select the hash function used for traffic forwarded over the bundle";
          type enumeration {
            enum dst-ip {
              tailf:info "Use the destination IP as the hash function";
            }
            enum src-ip {
              tailf:info "Use the source IP as the hash function";
            }
          }
        }
        container localize {
          tailf:info "Restrict forwarding to members in the same rack where possible";
          container threshold {
            tailf:info "The threshold below which traffic is no longer localized";
            leaf links {
              tailf:info "Set a threshold of active member links per rack";
              type uint8 {
                tailf:info "<1-64>;;The number of links required on each rack to localize";
                range "1..64";
              }
            }
          }
        }
      }
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only effective on links with LACP enabled)";
            type empty;
          }
        }
      }
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";
        leaf links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
          }
        }
      }
    }
    container lacp {
      tailf:info "Bundle interface LACP commands";
      container switchover {
        tailf:info "Modify behavior for switching between links in this bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }
    }
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which this bundle should operate.";
          range "1..4294967295";
        }
      }
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value is higher priority.";
          range "1..65535";
        }
      }
      container switchover {
        tailf:info "Set the parameters for performing a switchover to/from the mLACP peer";
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }
        leaf type {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum brute-force {
              tailf:info "Force switchover by disabling all local member links";
            }
            enum revertive {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-non-bundle-grouping {
    container bundle {
      tailf:info "Link aggregation per-interface commands";
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum active {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum on {
              tailf:info "Do not run LACP over the port.";
            }
            enum passive {
              tailf:info "Run LACP in passive mode over the port.";
            }
          }
        }
      }
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. Lower value is higher priority.";
          range "1..65535";
        }
      }
    }
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period (in milliseconds) for the partner system (must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-delete-when-empty;
          presence true;
          leaf receive {
            tailf:info "Expected period for rx packets if LACP short is enabled (NOTE: This CLI is deprecated and will be removed in future releases. Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
          leaf transmit {
            tailf:info "Period for tx packets if the peer is using LACP short (NOTE: This CLI is deprecated and will be removed in future releases. Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-pointtopoint-grouping {
    container keepalive {
      tailf:info "Set the keepalive interval, or disable keepalives";
      choice keepalive-choice {
        container values {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval (default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count (default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name config-fr-vc;
      key dlci;
      leaf dlci {
        type uint16 {
          tailf:info "<16-1007>;;DLCI Number";
          range "16..1007";
        }
      }
      uses ncs_rpc_notif_interface-service-policy-grouping;
      leaf encap {
        tailf:info "Set the Encapsulation of this PVC";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco encapsulation for this PVC";
          }
          enum ietf {
            tailf:info "Use RFC1490/RFC2427 encapsulation for this PVC";
          }
        }
      }
      container fragment {
        tailf:info "Enable FRF.12 fragmentation and define fragment size";
        tailf:cli-compact-syntax;
        leaf end-to-end {
          tailf:info "Choose end-to-end FRF.12 fragmentation";
          type uint16 {
            tailf:info "<16-1600>;;fragment size in bytes";
            range "16..1600";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable fragmentation counters";
          type empty;
        }
      }
    }
    container ppp {
      tailf:info "Point-to-Point Protocol";
      container multilink {
        tailf:info "Configure PPP Multilink settings";
        container minimum-active {
          tailf:info "Configure the minimum requirements to activate the interface";
          leaf links {
            tailf:info "Configure the minimum number of active links required";
            type uint16 {
              tailf:info "<1-65535>;;Number of links";
              range "1..65535";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-multilink-grouping {
    container multilink {
      tailf:info "Modify Multilink parameters!";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-multilink;
      container fragment-size {
        tailf:info "Fragment size (some fragment sizes may not be supported)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-multilink-frag;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf size {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<64-512>;;Size of fragments";
            range "64..512";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable/Disable the fragmentation counters";
          type empty;
        }
      }
      container fragment {
        tailf:info "Set the fragmentation";
        leaf size {
          tailf:info "Set the fragmentation size";
          type uint16 {
            tailf:info "<64-9216>;;Fragmentation size in bytes";
            range "64..9216";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-ethernet-grouping {
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum full {
          tailf:info "Full duplex";
          tailf:code-name duplex_full;
        }
        enum half {
          tailf:info "Half duplex";
          tailf:code-name duplex_half;
        }
      }
    }
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-udld;
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum aggressive {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum normal {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }
      }
      container cfm {
        tailf:info "802.1ag Connectivity Fault Management configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-cfm;
        container mep {
          tailf:info "CFM Maintenance End Point configuration";
          list domain {
            tailf:info "Specify the Maintenance Domain the MEP operates in";
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Maintenance Domain name";
              }
            }
            leaf service {
              tailf:info "Specify the Maintenance Service the MEP operates in";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Maintenance Service name";
              }
            }
            leaf mep-id {
              tailf:info "Specify the MEP ID to assign to the MEP";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;MEP ID";
                range "1..8191";
              }
            }
            leaf cos {
              tailf:info "Specify CoS bits for messages initiated by this MEP";
              type uint8 {
                tailf:info "<0-7>;;Class of Service";
                range "0..7";
              }
            }
            container sla {
              tailf:info "Service Level Agreement configuration";
              container operation {
                tailf:info "SLA operation configuration";
                list profile {
                  tailf:info "Specify the SLA profile for this operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key "name mep-id";
                  leaf name {
                    type string {
                      tailf:info "WORD;;Profile name";
                    }
                  }
                  leaf target {
                    tailf:info "Specify the target for the SLA operation";
                    tailf:cli-prefix-key {
                      tailf:cli-before-key 2;
                    }
                    type empty;
                  }
                  leaf mep-id {
                    tailf:cli-expose-key-name;
                    tailf:info "Specify a target MEP";
                    type uint16 {
                      tailf:info "<1-8191>;;Target MEP ID";
                    }
                  }
                }
              }
            }
          }
        }
        container ais {
          tailf:info "CFM Alarm Indication Signal configuration";
          container transmission {
            tailf:info "CFM AIS transmission configuration";
            container up {
              tailf:info "Up configuration";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              presence true;
              leaf cos {
                tailf:info "Specify CoS bits for AIS messages";
                type uint8 {
                  tailf:info "<0-7>;;Class of Service";
                  range "0..7";
                }
              }
              leaf interval {
                tailf:info "Specify the AIS transmission interval";
                type enumeration {
                  enum 1s {
                    tailf:info "Interval of 1 second";
                  }
                  enum 1m {
                    tailf:info "Interval of 1 minute";
                  }
                }
              }
            }
          }
        }
      }
      leaf egress-filter {
        tailf:info "Override default egress-filter configuration on this interface";
        type enumeration {
          enum disable {
            tailf:info "No egress filtering, regardless of the global configuration";
          }
          enum strict {
            tailf:info "Strict egress filtering, regardless of the global configuration";
          }
        }
      }
    }
    container ethernet-services {
      tailf:info "Ethernet related services";
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
      }
    }
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum 10 {
          tailf:info "Ethernet is 10Mb";
        }
        enum 100 {
          tailf:info "Ethernet is 100Mb";
        }
        enum 1000 {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info permit;
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info all;
            type empty;
          }
        }
      }
    }
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-nV;
      container edge {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-nV-Edge;
        leaf interface {
          tailf:info "nV Edge inter-rack interconnect interface";
          type empty;
        }
      }
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-satellite-fabric-link;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        container redundancy {
          tailf:cli-break-sequence-commands;
          tailf:info "Redundancy configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-nV-red;
          leaf iccp-group {
            tailf:info "Redundancy group ID";
            type uint32 {
              tailf:info "<1-4294967295>;;Redundancy group ID";
            }
          }
        }
        container remote-ports {
          tailf:info "Remote ports configuration";
          leaf GigabitEthernet {
            tailf:info "Remote ports type";
            type string {
              tailf:info "Slot/Subslot/Port(s)";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-common-grouping {
    leaf description {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }
    leaf loopback {
      tailf:info "Set the loopback mode on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum external {
          tailf:info "Enable external loopback (requires loopback connector)";
        }
        enum internal {
          tailf:info "Enable internal loopback";
        }
        enum line {
          tailf:info "Enable line loopback";
        }
      }
    }
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }
    container negotiation {
      tailf:info "Select autonegotiation mode";
      container auto {
        tailf:info "Perform link autonegotiation";
        tailf:cli-delete-when-empty;
        presence true;
        leaf allow-overrides {
          tailf:info "Allow configured values to override negotiated settings";
          type empty;
        }
      }
    }
    list monitor-session {
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name config-if-mon;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf ethernet {
        tailf:info "Replicate Ethernet traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf direction {
        tailf:info "Specify the direction of traffic to replicate";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum rx-only {
            tailf:info "Replicate only received (ingress) traffic";
          }
          enum tx-only {
            tailf:info "Replicate only transmitted (egress) traffic";
          }
        }
      }
      leaf acl {
        tailf:info "Enable acl based mirroring";
        type empty;
      }
    }
    container encapsulation {
      tailf:info "Set the encapsulation on an (sub)interface";
      choice encapsulation-choice {
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            type empty;
          }
        }
        leaf hdlc {
          tailf:info "Serial HDLC synchronous";
          tailf:cli-full-command;
          type empty;
        }
        leaf mfr {
          tailf:info "Multilink Frame Relay Member Link";
          tailf:cli-full-command;
          type empty;
        }
        leaf ppp {
          tailf:info "Point-to-Point protocol";
          tailf:cli-full-command;
          type empty;
        }
        leaf default {
          tailf:info "Packets unmatched by other service instances";
          tailf:cli-full-command;
          type empty;
        }
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
        }
        container ambiguous {
          tailf:info "Ambiguous L3 VLAN configuration";
          container dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list vlan-id {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
            leaf-list second-dot1q {
              tailf:info "IEEE 802.1Q VLAN-tagged packets";
              tailf:cli-optional-in-sequence;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
          }
        }
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf-list second-dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-optional-in-sequence;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf-list dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            type empty;
          }
        }
      }
    }
    container pppoe {
      tailf:info "PPP over Ethernet";
      container enable {
        tailf:info "Enable PPPoE on the interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf bba-group {
          tailf:info "Specify the bba-group to use with the interface";
          type string {
            tailf:info "WORD;;The bba-group to use";
          }
        }
      }
    }
    container frame-relay {
      tailf:info "Frame Relay interface configuration commands";
      container lmi {
        tailf:info "Disable LMI";
        leaf disable {
          tailf:info "Disable LMI";
          type empty;
        }
      }
      container lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI to select type";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum ansi {
              tailf:info "Use ANSI type LMI";
            }
            enum cisco {
              tailf:info "Use CISCO type LMI";
            }
            enum q933a {
              tailf:info "Use CCITT type LMI";
            }
          }
        }
      }
      container intf-type {
        tailf:info "Use DTE/DCE mode for LMI";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum dce;
          }
        }
      }
      container multilink {
        tailf:info "Multilink Frame Relay interface configuration commands";
        leaf bandwidth-class {
          tailf:info "Multilink Frame Relay bandwidth class";
          type enumeration {
            enum a {
              tailf:info "Bandwidth class A";
            }
            enum b {
              tailf:info "Bandwidth class B";
            }
            enum c {
              tailf:info "Bandwidth class C";
            }
          }
        }
      }
    }
    container frequency {
      tailf:info "Frequency Synchronization configuration";
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-freqsync;
        container selection {
          tailf:info "Selection configuration commands";
          leaf input {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
            range "1..254";
          }
        }
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
            range "0..12";
          }
        }
        container quality {
          tailf:info "Quality level configuration";
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses ncs_rpc_notif_freqsync-quality-grouping;
          }
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses ncs_rpc_notif_freqsync-quality-grouping;
          }
        }
      }
    }
    uses ncs_rpc_notif_interface-service-policy-grouping;
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf" {
        tailf:xpath-root 3;
      }
      type vrf-type;
    }
    container aaa {
      tailf:info "AAA configuration";
      container radius {
        tailf:info "AAA radius configuration";
        container attribute {
          tailf:info "AAA radius attribute";
          leaf nas-port-type {
            tailf:info "AAA nas-port-type attribute";
            type union {
              type uint8 {
                tailf:info "<0-44>;;Nas Port Type value";
              }
              type string {
                tailf:info "WORD;;Nas Port Type name";
              }
            }
          }
        }
      }
    }
    container ipv4 {
      tailf:info "IPv4 interface subcommands";
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }
      choice address-choice {
        case no {
          container no-address {
            tailf:cli-drop-node-name;
            leaf address {
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
        case yes {
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
              }
            }
            leaf route-tag {
              tailf:info "Route-tag to be associated with this address";
              type uint32 {
                tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                range "1..4294967295";
              }
            }
          }
          container address-secondary-list {
            tailf:cli-drop-node-name;
            list address {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip secondary";
              leaf ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
              leaf secondary {
                type enumeration {
                  enum secondary {
                    tailf:info "Make this IPv4 address a secondary address";
                  }
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type string {
                  tailf:info "A.B.C.D or /X;;IP subnet mask or /masklength";
                }
              }
              leaf route-tag {
                tailf:info "Route-tag to be associated with this address";
                type uint32 {
                  tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          // NCS drop tailf-common:non-strict-leafref statement
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        leaf hardware-count {
          tailf:cli-break-sequence-commands;
          tailf:info "Count packets in hardware";
          type empty;
        }
        leaf interface-statistics {
          tailf:info "Per interface statistics in hardware";
          type empty;
        }
      }
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        choice helper-address-choice {
          leaf local {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          container vrf {
            tailf:info "VRF name for helper-address (if different from interface VRF)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP destination address";
              }
            }
          }
        }
      }
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }
      leaf directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        type empty;
      }
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }
      container bgp {
        tailf:info "Enable BGP policy based feature";
        container policy {
          tailf:info "BGP policy";
          container propagation {
            tailf:info "BGP QoS policy propagation";
            container input {
              tailf:info "QPPB on input";
              container qos-group {
                tailf:info "QPPB using Qos Group";
                container destination {
                  tailf:info "QPPB on destination IP address ";
                  presence true;
                }
              }
            }
          }
        }
      }
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "100..65535";
                }
                must "../msec" {
                  tailf:xpath-root 3;
                }
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence true;
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf list {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }
                  }
                }
                leaf route-map {
                  tailf:info Route-map;
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container notification {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              type empty;
            }
          }
        }
      }
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence true;
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses ncs_rpc_notif_interface-name-grouping;
      }
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }
    container ipv6 {
      tailf:info "IPv6 interface subcommands";
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1280-65535>;;MTU (bytes)";
          range "1280..65535";
        }
      }
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";
        leaf cache-limit {
          tailf:info "Set Cache Limit for neighbor entry";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-10000>;;Cache Limit";
            range "1..10000";
          }
        }
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }
        leaf managed-config-flag {
          tailf:info "Hosts should use stateful protocol for address config";
          tailf:cli-full-command;
          type empty;
        }
        leaf ns-interval {
          tailf:info "Set advertised NS retransmission interval";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1000-4294967295>;;Retransmission interval in milliseconds";
            range "1000..4294967295";
          }
        }
        leaf other-config-flag {
          tailf:info "Hosts should use stateful protocol for non-address config";
          tailf:cli-full-command;
          type empty;
        }
        container prefix {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key prefix;
            leaf prefix {
              type union {
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type string;
              }
            }
            uses ncs_rpc_notif_interface-ipv6-nd-prefix-list-grouping;
          }
          container default {
            tailf:info "Specify prefix default parameters";
            uses ncs_rpc_notif_interface-ipv6-nd-prefix-list-grouping;
          }
        }
        container ra {
          tailf:info "IPv6 interface ND RA subcommands";
          leaf hoplimit {
            tailf:info "IPv6 ND RA hoplimit";
            tailf:cli-full-command;
            type enumeration {
              enum unspecified {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }
          leaf mtu {
            tailf:info "IPv6 ND RA mtu option configuration";
            tailf:cli-full-command;
            type enumeration {
              enum unspecified {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }
        }
        leaf ra-interval {
          tailf:info "Set IPv6 Router Advertisement Interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<4-1800>;;Maximum RA Interval (sec)";
            range "4..1800";
          }
        }
        leaf ra-lifetime {
          tailf:info "Set IPv6 Router Advertisement Lifetime";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-9000>;;RA Lifetime (seconds)";
            range "0..9000";
          }
        }
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds";
            range "0..3600000";
          }
        }
        leaf redirects {
          tailf:info "Enable sending of ICMP Redirect messages";
          tailf:cli-full-command;
          type empty;
        }
        leaf suppress-ra {
          tailf:info "Suppress IPv6 Router Advertisements";
          tailf:cli-full-command;
          type empty;
        }
      }
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key prefix;
          leaf prefix {
            type union {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;IPv6 prefix";
              }
              type string {
                tailf:info "X:X::X%zone;;IPv6 name or address";
              }
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf link-local {
            tailf:info "Use link-local address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;access-list name";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
        leaf interface-statistics {
          type empty;
        }
      }
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }
    container lldp {
      tailf:cli-add-mode;
      tailf:cli-mode-name config-lldp;
      container receive {
        tailf:info "Disable LLDP RX on an interface";
        leaf disable {
          tailf:info "Disable LLDP RX on an interface";
          type empty;
        }
      }
      container transmit {
        tailf:info "Disable LLDP TX on an interface";
        leaf disable {
          tailf:info "Disable LLDP TX on an interface";
          type empty;
        }
      }
    }
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-mpls;
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the stack";
          tailf:cli-full-command;
          type enumeration {
            enum drop {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }
    container backup-bw {
      tailf:info "Fast-reroute backup bandwidth requirement";
      container unlimited {
        tailf:info "Unlimited backup bandwidth";
        choice unlimited-choice {
          leaf any-class-type {
            tailf:info "Specify any bandwidth class type";
            type empty;
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }
      }
    }
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-full-command;
      type empty;
    }
    uses ncs_rpc_notif_interface-isis-grouping;
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step 30;
        }
      }
    }
    container capture {
      tailf:info "capture interface packets (platform)(cisco-support)";
      container software {
        tailf:info "capture software switched packets(cisco-support)";
        leaf packets {
          tailf:info "turns on both ingress and egress (platform)(cisco-support)";
          type empty;
        }
      }
    }
    container transport-mode {
      tailf:info "Set the transport mode on an interface";
      choice transport-mode-choice {
        leaf wan {
          tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
          type empty;
        }
        container otn {
          tailf:info "10GE over Optical Transport Network (G.709)";
          leaf bit-transparent {
            tailf:info "10GBASE-R transparently mapped into OTU-2";
            type enumeration {
              enum opu1e {
                tailf:info "10GBASE-R over OPU1e without fixed stuffing (11.0491Gb/s)";
              }
              enum opu2e {
                tailf:info "10GBASE-R over OPU2e with fixed stuffing (11.0957Gb/s)";
              }
            }
          }
        }
        leaf rx-only {
          tailf:info "10GE UDLR Mode, Receive Only";
          type empty;
        }
        leaf tx-only {
          tailf:info "10GE UDLR Mode, Transmit Only";
          type empty;
        }
      }
    }
    leaf flow-control {
      tailf:info "configure flow-control on the given interface";
      tailf:cli-full-command;
      type enumeration {
        enum bidirectional {
          tailf:info "Enable bidirectional flow-control on an interface";
        }
        enum egress {
          tailf:info "Enable egress flow-control on an interface";
        }
        enum ingress {
          tailf:info "Enable ingress flow-control on an interface";
        }
      }
    }
    list flow {
      tailf:info "Netflow configuration";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      key "proto monitor direction";
      leaf proto {
        type enumeration {
          enum ipv4 {
            tailf:info "IPV4 netflow configuration";
          }
          enum ipv6 {
            tailf:info "IPV6 netflow configuration";
          }
          enum mpls {
            tailf:info "MPLS netflow configuration";
          }
        }
      }
      leaf monitor {
        tailf:info "Specify a flow monitor for packets";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Flow monitor map name";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf sampler {
        tailf:info "Specify a sampler for packets";
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type string {
          tailf:info "WORD;;Sampler map name";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf direction {
        type enumeration {
          enum egress {
            tailf:info "Apply flow monitor on outgoing packets";
          }
          enum ingress {
            tailf:info "Apply flow monitor on incoming packets";
          }
        }
      }
    }
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf half-life {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }
    container logging {
      tailf:info "Configure logging for interface";
      container events {
        tailf:info "Interface events";
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          presence true;
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is transitioning";
            type empty;
          }
        }
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }
        uses ncs_rpc_notif_lsp-status-grouping;
      }
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info Access-list;
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }
    container storm-control {
      tailf:info "storm configuration";
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_subinterface-common-grouping {
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice tag-choice {
            leaf pop {
              tailf:info "Remove one or more tags";
              type enumeration {
                enum 1 {
                  tailf:info "Remove outer tag only";
                }
                enum 2 {
                  tailf:info "Remove two outermost tags";
                }
              }
            }
            leaf push {
              tailf:info "Push one or more tags";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf translate {
              tailf:info "Replace tags with other tags";
              tailf:cli-incomplete-command;
              type enumeration {
                enum 1-to-1 {
                  tailf:info "Replace the outermost tag with another tag";
                }
                enum 1-to-2 {
                  tailf:info "Replace the outermost tag with two tags";
                }
                enum 2-to-1 {
                  tailf:info "Replace the outermost two tags with one tag";
                }
                enum 2-to-2 {
                  tailf:info "Replace the outermost two tags with two other tags";
                }
              }
            }
          }
          leaf dot1ad {
            when "not(../pop)" {
              tailf:xpath-root 3;
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1ad tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf dot1q {
            when "not(../pop)" {
              tailf:xpath-root 3;
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf second-dot1q {
            when "(../dot1q and not(../dot1ad))" {
              tailf:xpath-root 3;
              tailf:dependency "../dot1ad";
              tailf:dependency "../dot1q";
            }
            tailf:info "Push another Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum symmetric {
                tailf:info "All rewrites must be symmetric";
              }
            }
          }
        }
      }
    }
    container dot1q {
      tailf:info "802.1Q VLAN configuration";
      container vlan {
        tailf:info "Configure a VLAN ID on the subinterface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;Configure second (inner 802.1Q) VLAN ID on the subinterface";
              range "1..4094";
            }
            type string;
            type enumeration {
              enum any {
                tailf:info "Match any VLAN id";
              }
            }
          }
        }
      }
    }
    container dot1ad {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4094>;;Single VLAN id";
          range "1..4094";
        }
      }
      leaf second-dot1d {
        tailf:cli-drop-node-name;
        type union {
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
          type string;
          type enumeration {
            enum any {
              tailf:info "Match any VLAN id";
            }
          }
        }
      }
    }
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        type enumeration {
          enum drop {
            tailf:info "Drop these protocol packets";
          }
          enum reverse-tunnel {
            tailf:info "Tunnel at egress";
          }
          enum tunnel {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-bfd-grouping {
    container bfd {
      tailf:info "BFD interface configuration commands";
      container address-family {
        tailf:info "Set configuration for a given address family";
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          container timers {
            tailf:info "Set the timers that determine when a BFD session defaults to down";
            leaf start {
              tailf:info "The time since starting a BFD session before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
            leaf nbr-unconfig {
              tailf:info "The time since a BFD signalled that a peer sessionis unconfigured before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
          }
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD session";
              range "2..50";
            }
          }
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            tailf:cli-full-command;
            type empty;
          }
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD session";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-30000>;;The preferred minimum interval (in ms) for the BFD session";
              range "15..30000";
            }
          }
        }
      }
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_non-subinterface-common-grouping {
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses ncs_rpc_notif_interface-name-grouping;
      }
    }
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      tailf:cli-full-command;
      type empty;
    }
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-l2;
      presence true;
      uses ncs_rpc_notif_interface-service-policy-grouping;
      container l2protocol {
        tailf:info "Layer 2 protocol handling";
        leaf cpsv {
          tailf:info "CDP, PVST+, STP, and VTP protocols";
          type enumeration {
            enum drop {
              tailf:info "Drop these protocol packets";
            }
            enum reverse-tunnel {
              tailf:info "Tunnel at egress";
            }
            enum tunnel {
              tailf:info "Tunnel at ingress";
            }
          }
        }
      }
    }
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }
    uses ncs_rpc_notif_interface-switch-grouping;
  }

  grouping ncs_rpc_notif_interface-tunnel-path-option-grouping {
    list path-option {
      tailf:info "Primary or fallback path setup option";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key preference-priority;
      leaf preference-priority {
        type uint16 {
          tailf:info "<1-1000>;;Preference for this path option";
          range "1..1000";
        }
      }
      choice path-option-choice {
        container dynamic {
          tailf:info "Setup based on dynamically allocated path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          presence true;
        }
        container explicit {
          tailf:info "Setup based on preconfigured path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice path-choice {
            leaf identifier {
              tailf:info "Specify an IP explicit path by number";
              type uint32 {
                tailf:info "<1-4294967295>;;Specify an IP explicit path by number";
              }
            }
            leaf name {
              tailf:info "Specify an IP explicit path by name";
              type string {
                tailf:info "WORD;;Specify an IP explicit path by name";
              }
            }
          }
        }
      }
      leaf segment-routing {
        tailf:info "Require segment routing`";
        tailf:cli-break-sequence-commands;
        type empty;
      }
      leaf verbatim {
        tailf:info "Do not require topology database for explicit path";
        type empty;
      }
      leaf lockdown {
        tailf:info "Not a candidate for reoptimization";
        type empty;
      }
      container ospf {
        tailf:info "Limit CSPF to a single OSPF instance and area";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf instance-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        leaf area {
          tailf:info "OSPF area";
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF area ID in IP address format";
            }
          }
        }
      }
      leaf attribute-set {
        tailf:info "Attribute set for this LSP";
        type string {
          tailf:info "WORD;;Specify attribute-set name (max 64 char)";
          length "1..64";
        }
      }
      leaf protected-by {
        tailf:info "Index of the protecting path-option";
        type uint32 {
          tailf:info "<1-1000>;;Index of the protecting path-option";
          range "1..1000";
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container Bundle-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle-Ether {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container FastEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FastEthernet {
          tailf:info "FastEthernet IEEE 802.3";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container GigabitEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GigabitEthernet {
          tailf:info "GigabitEthernet IEEE 802.3z";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf TenGigE {
        tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container TenGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TenGigE {
          tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf FortyGigE {
        tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container FortyGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FortyGigE {
          tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf HundredGigE {
        tailf:info HundredGigEthernet;
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container HundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf HundredGigE {
          tailf:info HundredGigEthernet;
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf PW-Ether {
        tailf:info "Pseudo-Wire Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-32768>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info <0-2147483647>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container Multilink-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Multilink {
          tailf:info "Multilink network interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf SRP {
        tailf:info "SRP interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        // NCS drop tailf-common:non-strict-leafref statement
        type string {
          pattern "[0-9]+.*";
        }
      }
      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info <0-0>;
          pattern 0;
        }
      }
      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info <1-512>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container POS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf POS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:info "Serial interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?\\.[0-9]+";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf tunnel-tp {
        tailf:info "MPLS Transport Protocol Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf tunnel-mte {
        tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf tunnel-ipsec {
        tailf:info "IPSec Tunnel interface(s)";
        type uint32 {
          tailf:info <0-4294967295>;
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+.*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container ATM-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf ATM {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+.*";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      leaf CEM {
        tailf:info "Circuit Emulation interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+.*";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
  }

  grouping ncs_rpc_notif_interface-grouping {
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Loopback interface number";
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Bundle-Ether interface id";
        type uint16 {
          tailf:info <1-65535>;
          range "1..65535";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-bundle-grouping;
    }
    container Bundle-Ether-subinterface {
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Bundle-Ether sub-interface id";
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Ethernet/IEEE 802.3 interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/.+/.+/.+";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Ten Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    container TenGigE-subinterface {
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Ten Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list FortyGigE {
      tailf:info FortyGigEthernet;
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Forty Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    container FortyGigE-subinterface {
      tailf:cli-drop-node-name;
      list FortyGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Forty Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list HundredGigE {
      tailf:info HundredGigEthernet;
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Hundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    container HundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Hundred Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list FastEthernet {
      tailf:info "FastEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Fast Ethernet interface id";
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    container FastEthernet-subinterface {
      tailf:cli-drop-node-name;
      list FastEthernet {
        tailf:info "FastEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-if;
        key id;
        leaf id {
          tailf:info "Fast Ethernet sub-interface id";
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
    }
    container GigabitEthernet-subinterface {
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
      }
    }
    list nve {
      tailf:info "Network Virtualization Endpoint Interface(s)";
      tailf:cli-mode-name config-if-nve;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        tailf:info "nve interface name";
        type uint16 {
          tailf:info "<0-65535>;;Config allowed on NVEs, range is 0-65535";
          range "0..65535";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      container redundancy {
        tailf:info Redundancy;
        tailf:cli-add-mode;
        tailf:cli-mode-name config-nve-red;
        container backbone {
          tailf:info "Configure ICCP backbone";
          container mpls {
            tailf:info "ICCP MPLS backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-nve-red-backbone-mpls;
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
          container vxlan {
            tailf:info "ICCP VXLAN backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-nve-red-backbone-vxlan;
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }
      container member {
        tailf:info "NVE VN-Segment Membership";
        list vni {
          tailf:info "vni;;Virtual Network Identifier";
          tailf:cli-mode-name config-nve-vni;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-16777215>;;Single VNI";
                range "1..16777215";
              }
              type string {
                tailf:info "<1-X>;;VNI range";
              }
            }
          }
          leaf vrf {
            tailf:info "Associate a VRF with VxLAN segment";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          container host-reachability {
            tailf:info "Configure host reachability advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum bgp {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          container host-reachabilty {
            tailf:info "Configure host reachabilty advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum bgp {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          container mcast-group {
            tailf:info "associate a multicast core group with VxLAN segment(s)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Single mcast ID or Start of range";
              }
            }
            leaf end-ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;End of mcast IP range";
              }
            }
          }
        }
      }
      leaf remap-replication-servers {
        tailf:info "Remap Replication servers to VNIs";
        tailf:cli-full-command;
        type empty;
      }
      leaf replication-server {
        tailf:info "Configure a replication server";
        tailf:cli-full-command;
        type inet:ipv4-address;
      }
      container source-interface {
        tailf:info "Configure source interface for Network Virtualization Endpoint";
        leaf Loopback {
          tailf:info "Loopback interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint32 {
            tailf:info <0-2147483647>;
            range "0..2147483647";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
      container anycast {
        tailf:info "Configure anycast mode parameters for this VTEP";
        container source-interface {
          tailf:info "Configure source interface for the anycast mode";
          leaf Loopback {
            tailf:info "Loopback interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info <0-2147483647>;
              range "0..2147483647";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
      }
    }
    list PW-Ether {
      tailf:info "Pseudo-Wire Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Pseudo-Wire Ethernet interface id";
        type uint16 {
          tailf:info <1-32768>;
          range "1..32768";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-non-bundle-grouping;
      container attach {
        tailf:info "Attach to an interface list";
        leaf generic-interface-list {
          tailf:info "Interface List";
          type string {
            tailf:info "WORD;;The name of the interface list";
          }
        }
      }
    }
    container PW-Ether-subinterface {
      tailf:cli-drop-node-name;
      list PW-Ether {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Pseudo-Wire Ethernet sub-interface id";
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
        }
        leaf l2transport {
          tailf:info "Treat as an attachment circuit";
          tailf:cli-hide-in-submode;
          type empty;
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-ethernet-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
        container attach {
          tailf:info "Attach to an interface list";
          leaf generic-interface-list {
            tailf:info "Interface List";
            type string {
              tailf:info "WORD;;The name of the interface list";
            }
          }
        }
      }
    }
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Port-channel interface id";
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-ethernet-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "POS interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-pointtopoint-grouping;
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-pos;
        leaf crc {
          tailf:cli-full-command;
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode ";
            }
            enum 32 {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }
    container POS-subinterface {
      tailf:cli-drop-node-name;
      list POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-subif;
        key id;
        leaf id {
          tailf:info "POS sub-interface id";
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
        uses ncs_rpc_notif_interface-pointtopoint-grouping;
      }
    }
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "BVI interface id";
        type uint16 {
          tailf:info <1-65535>;
          range "1..65535";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Vlan interface id";
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-ip interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-pointtopoint-grouping;
      container tunnel {
        tailf:info "Configure GRE tunnel parameters";
        container mode {
          tailf:info "Tunnel encapsulation method (default: gre ipv4)";
          leaf gre {
            tailf:info "IP over GRE encapsulation";
            type enumeration {
              enum ipv4 {
                tailf:info "GRE over IPV4 encapsulation";
              }
              enum ipv6 {
                tailf:info "GRE over IPV6 encapsulation";
              }
            }
          }
        }
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Ip Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPV6 address of the tunnel destination";
            }
          }
        }
      }
    }
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-te interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      container bfd {
        tailf:info "Configure BFD parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-bfd;
        presence true;
        leaf multiplier {
          tailf:info "Detect multiplier";
          type uint8 {
            tailf:info "3-10;;Detect multiplier (default 3)";
            range "3..10";
          }
        }
        container fast-detect {
          tailf:info "Enable BFD fast detection";
          tailf:cli-delete-when-empty;
          presence true;
          leaf sbfd {
            tailf:info "Enable SBFD";
            type empty;
          }
        }
        leaf minimum-interval {
          tailf:info "Hello interval";
          type uint16 {
            tailf:info "3-30000;;Hello interval in milliseconds (default 100)";
            range "3..30000";
          }
        }
        container dampening {
          tailf:info "Configure dampening intervals to bring tunnel up";
          leaf maximum-wait {
            tailf:info "Maximum delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 600000)";
              range "1..518400000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 20000)";
              range "1..518400000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 16000)";
              range "1..518400000";
            }
          }
        }
        leaf bringup-timeout {
          tailf:info "Timeout before BFD session bring up on new LSP is aborted";
          type uint16 {
            tailf:info "<10-3600>;;Wait for session to come up in seconds (default 60)";
            range "10..3600";
          }
        }
        container lsp-ping {
          tailf:info "Configure periodic LSP ping";
          choice lsp-ping-choice {
            leaf disable {
              tailf:info "Disable periodic LSP Ping";
              type empty;
            }
            leaf interval {
              tailf:info "Periodic LSP ping interval";
              type uint16 {
                tailf:info "<60-3600>;;Periodic LSP Ping interval in seconds (default 120)";
                range "60..3600";
              }
            }
          }
        }
      }
      leaf load-share {
        tailf:info "Specify tunnel load-sharing metric";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Loadshare value. Scale is the same as bandwidths.";
          range "1..4294967295";
        }
      }
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-autobw;
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          uses ncs_rpc_notif_interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container underflow {
          tailf:info "Configuring the tunnel underflow detection";
          uses ncs_rpc_notif_interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger adjustment";
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Bandwidth change percent to trigger adjustment";
              range "1..100";
            }
          }
          leaf min {
            tailf:info "Set the bandwidth change value to trigger adjustment";
            type uint32 {
              tailf:info "<10-4294967295>;;Bandwidth change value to trigger adjustment (kbps)";
              range "10..4294967295";
            }
          }
        }
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";
        container metric {
          tailf:info "Specify MPLS tunnel metric";
          choice metric-choice {
            leaf absolute {
              tailf:info "Set metric mode absolute";
              type uint32 {
                tailf:info "<1-2147483647>;;Absolute metric";
                range "1..2147483647";
              }
            }
            leaf relative {
              tailf:info "Set metric mode relative";
              type int8 {
                tailf:info "<-10,+10>;;Relative metric";
                range "-10..10";
              }
            }
          }
        }
        container announce {
          tailf:info "Announce tunnel to IGP";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-if-tunte-aa;
          presence true;
          container metric {
            tailf:info "Specify MPLS tunnel metric";
            choice metric-choice {
              leaf constant {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2147483647>;;Set constant metric";
                  range "1..2147483647";
                }
              }
              leaf absolute {
                tailf:info "Set metric mode absolute";
                type uint32 {
                  tailf:info "<1-2147483647>;;Absolute metric";
                  range "1..2147483647";
                }
              }
              leaf relative {
                tailf:info "Set metric mode relative";
                type int8 {
                  tailf:info "<-10,+10>;;Relative metric";
                  range "-10..10";
                }
              }
            }
          }
        }
        list destination {
          tailf:info "Adds static route to destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key addr;
          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Address of static route to add";
            }
          }
        }
      }
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }
      leaf forward-class {
        tailf:info "Specify tunnel forward class for policy based routing";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
          range "1..7";
        }
      }
      leaf policy-class {
        tailf:info "Specify classs for policy-based tunnel selection";
        type union {
          type enumeration {
            enum default {
              tailf:info "Default class for policy-based tunnel selection";
            }
          }
          type uint8 {
            tailf:info "<1-7>;;Tunnel policy class";
            range "1..7";
          }
        }
      }
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container affinity {
        tailf:info "Link attributes for links traversed by tunnel";
        container affinity-value {
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-drop-node-name;
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity value";
              pattern 0x[0-9a-fA-F]+;
            }
          }
          leaf mask {
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity mask value";
              pattern 0x[0-9a-fA-F]+;
            }
          }
        }
        list include {
          tailf:info "Affinity to include in the loose sense";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
        list include-strict {
          tailf:info "Affinity to include in the strict sense";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
        list exclude {
          tailf:info "Affinity to exclude";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
      }
      leaf path-protection {
        tailf:info "Enable the path protection feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container path-selection {
        tailf:info "Path Selection Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-path-sel;
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }
        container segment-routing {
          tailf:info "Segment-routing path-selection options";
          leaf adjacency {
            tailf:info "Segment-routing adjacency path-selection type";
            type enumeration {
              enum protected {
                tailf:info "Use only protected adjacencies";
              }
              enum unprotected {
                tailf:info "Use only unprotected adjacencies";
              }
            }
          }
        }
      }
      container priority {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf setup {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-7>;;Setup Priority";
            range "0..7";
          }
        }
        leaf hold-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;Hold Priority";
          }
        }
      }
      leaf signalled-name {
        tailf:info "The signaling name to assign to tunnel";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;The name to be included in signaling";
        }
      }
      container signalled-bandwidth {
        tailf:info "Tunnel bandwidth requirement to be signalled";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf sub-pool {
          tailf:info "Specify sub-pool bandwidth";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf bandwidth {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
          }
        }
        leaf class-type {
          when "not(../sub-pool)" {
            tailf:xpath-root 3;
            tailf:dependency "../sub-pool";
          }
          tailf:info "Specify the bandwidth class type";
          type uint8 {
            tailf:info "<0-1>;;Class type number";
            range "0..1";
          }
        }
      }
      leaf fast-reroute {
        tailf:info "Specify MPLS tunnel can be fast-rerouted";
        tailf:cli-full-command;
        type empty;
      }
      leaf record-route {
        tailf:info "Record the route used by the tunnel";
        tailf:cli-full-command;
        type empty;
      }
      uses ncs_rpc_notif_interface-tunnel-path-option-grouping;
      container pce {
        tailf:info "Config PCE parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-pce;
        presence true;
        leaf delegation {
          tailf:info "Enable PCE delegation";
          type empty;
        }
      }
    }
    list tunnel-tp {
      tailf:info "MPLS Transport Protocol Tunnel interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-tp interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list tunnel-mte {
      tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-mte interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      list destination {
        tailf:info "Specify a destination to an endpoint of the tunnel";
        tailf:cli-mode-name config-if-p2mp-dest;
        key addr;
        leaf addr {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination address";
          }
        }
        uses ncs_rpc_notif_interface-tunnel-path-option-grouping;
      }
    }
    list tunnel-ipsec {
      tailf:info "IPSec Tunnel interface(s)";
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-ipsec interface id";
        type uint32 {
          tailf:info <0-4294967295>;
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
    }
    list ATM {
      tailf:info "ATM Network Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "ATM Network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-atm-grouping;
    }
    container ATM-subinterface {
      tailf:cli-drop-node-name;
      list ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "ATM Network sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        choice mode-choice {
          leaf l2transport {
            tailf:info "Treat as an attachment circuit";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf point-to-point {
            tailf:info "Treat as a point-to-point link";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
        uses ncs_rpc_notif_interface-atm-grouping;
      }
    }
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Multilink interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-pointtopoint-grouping;
      uses ncs_rpc_notif_interface-multilink-grouping;
    }
    container Multilink-subinterface {
      tailf:cli-drop-node-name;
      list Multilink {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Multilink sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
        uses ncs_rpc_notif_interface-pointtopoint-grouping;
        uses ncs_rpc_notif_interface-multilink-grouping;
      }
    }
    list SRP {
      tailf:info "SRP interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      container threshold {
        tailf:info "Commands to set the threshold for the appropriate Bit Error Rate";
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
    }
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Serial network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      uses ncs_rpc_notif_interface-pointtopoint-grouping;
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-multilink;
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }
      container serial {
        tailf:info "Modify Serial parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-serial;
        leaf crc {
          tailf:info "Set the Encapsulation of this PVC";
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode (default)";
            }
            enum 32 {
              tailf:info "32-bit CRC mode";
            }
          }
        }
        leaf scramble {
          tailf:info "Enable payload scrambling on Serial interface";
          type empty;
        }
      }
    }
    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-subif;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:info "Serial network sub-interface id";
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses ncs_rpc_notif_interface-common-grouping;
        uses ncs_rpc_notif_interface-bfd-grouping;
        uses ncs_rpc_notif_subinterface-common-grouping;
        uses ncs_rpc_notif_interface-pointtopoint-grouping;
        leaf subinterface {
          tailf:info "Do not SET, internal testing leaf only";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
    list CEM {
      tailf:info "Circuit Emulation interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Circuit Emulation interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_interface-common-grouping;
      uses ncs_rpc_notif_interface-bfd-grouping;
      uses ncs_rpc_notif_non-subinterface-common-grouping;
      container cem {
        tailf:info "Global CEM interface configuration subcommands";
        leaf class-attach {
          tailf:info "Attach a CEM class to this interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;CEM class name";
          }
        }
        leaf dejitter {
          tailf:info "Configure dejitter buffer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-500>;;buffer size in milliseconds";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_bgp-address-family-pre-grouping {
    container label {
      tailf:info "Label-related configuration";
      container mode {
        tailf:info "Select label mode";
        choice mode-choice {
          leaf per-ce {
            tailf:info "Set per CE label mode";
            type empty;
          }
          leaf per-prefix {
            tailf:info "Set per perfix label mode";
            type empty;
          }
          leaf per-vrf {
            tailf:info "Set per VRF label mode";
            type empty;
          }
          leaf route-policy {
            tailf:info "Use a route policy to select prefixes for label allocation mode";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }
      }
    }
    leaf table-policy {
      tailf:info "Configure policy for installation of routes to RIB";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }
      container route-target {
        tailf:info "Accept received updates with the specified route targets";
        choice route-target-choice {
          leaf all {
            tailf:info "Accept received updates containing at least one route target";
            type empty;
          }
          leaf route-policy {
            tailf:info "Accept received updates accepted by the specified policy";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update generation configuration";
      container limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
        }
      }
    }
    container additional-paths {
      tailf:info "Additional paths configuration";
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }
      leaf send {
        tailf:info "Additional paths Send capability";
        tailf:cli-full-command;
        type empty;
      }
      container selection {
        tailf:info "Additional paths selection";
        list route-policy {
          tailf:info "Route-policy for additional paths selection";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
        }
      }
    }
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum reset-on-import {
            tailf:info "Reset weight of paths on import";
          }
        }
        type uint32 {
          tailf:info "<0-65535>;;default weight";
          range "0..65535";
        }
      }
    }
    container advertise {
      tailf:info "Advertise BGP path";
      leaf best-external {
        tailf:info "Advertise best-external path";
        type empty;
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses ncs_rpc_notif_router-bgp-af-advertise-grouping;
        }
      }
      container vpnv6 {
        tailf:info "Vpnv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses ncs_rpc_notif_router-bgp-af-advertise-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses ncs_rpc_notif_router-bgp-af-advertise-grouping;
        }
      }
    }
    container bgp {
      tailf:info "BGP Commands";
      leaf attribute-download {
        tailf:info "Configure attribute download for this address-family";
        tailf:cli-full-command;
        type empty;
      }
      container dampening {
        tailf:info "Enable route-flap dampening";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice dampening-choice {
          case a {
            leaf half-life {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-45>;;Half-life time for the penalty";
                range "1..45";
              }
            }
            leaf reuse {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start reusing a route";
                range "1..20000";
              }
            }
            leaf suppress {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start suppressing a route";
                range "1..20000";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Maximum duration to suppress a stable route";
                range "1..255";
              }
            }
          }
          case b {
            leaf route-policy {
              tailf:info "Route policy to specify criteria for dampening";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }
      }
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        container reflection {
          tailf:info Reflection;
          leaf disable {
            tailf:info Disable;
            type empty;
          }
        }
      }
    }
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";
      container eibgp {
        tailf:info eiBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
      container ebgp {
        tailf:info eBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
      container ibgp {
        tailf:info iBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths (limit includes backup path)";
          }
        }
        leaf unequal-cost {
          tailf:info "Allow multipaths to have different BGP nexthop IGP metrics";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
    }
    container distance {
      tailf:info "Define an administrative distance";
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf external {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
    }
    container nexthop {
      tailf:info Nexthop;
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value (only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container trigger-delay {
        tailf:info "Processing trigger delay";
        leaf critical {
          tailf:info "For critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
        leaf non-critical {
          tailf:info "For non-critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
      }
    }
    leaf domain-distinguisher {
      tailf:info "Globally unique identifier for IGP domain";
      tailf:cli-full-command;
      type string {
        tailf:info "<1-4294967295>:;;4 octet ASN";
      }
    }
  }

  grouping ncs_rpc_notif_bgp-address-family-post-grouping {
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key prefix;
      leaf prefix {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 Aggregate address and mask or masklength";
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf as-confed-set {
        tailf:info "Generate AS confed set path information";
        type empty;
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      container route-policy {
        tailf:info "Policy to condition advertisement, suppression,and attributes";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute OSPF internal routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf external {
          tailf:info "Redistribute OSPF external routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf external-type {
          tailf:cli-drop-node-name;
          when "../external" {
            tailf:xpath-root 3;
          }
          type enumeration {
            enum 1 {
              tailf:info "Redistribute external type 1 routes";
            }
            enum 2 {
              tailf:info "Redistribute external type 2 routes";
            }
          }
        }
        leaf nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf nssa-external-type {
          tailf:cli-drop-node-name;
          when "../nssa-external" {
            tailf:xpath-root 3;
          }
          type enumeration {
            enum 1 {
              tailf:info "Redistribute NSSA external type 1 routes";
            }
            enum 2 {
              tailf:info "Redistribute NSSA external type 2 routes";
            }
          }
        }
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:info "Redistribute routes from the specified ISIS levels";
          type enumeration {
            enum 1 {
              tailf:info "Redistribute ISIS level 1 routes";
            }
            enum 1-inter-area {
              tailf:info "Redistribute ISIS level 1 inter-area routes";
            }
            enum 2 {
              tailf:info "Redistribute ISIS level 2 ISIS routes";
            }
          }
        }
        uses ncs_rpc_notif_router-af-redistribute-grouping;
      }
    }
    container allocate-label {
      tailf:info "Allocate label for selected prefixes";
      choice allocate-label-choice {
        leaf all {
          tailf:info "Allocate labels for all prefixes";
          type empty;
        }
        leaf route-policy {
          tailf:info "Use a route policy to select prefixes for label allocation";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          // NCS drop tailf-common:non-strict-leafref statement
        }
      }
    }
  }

  grouping ncs_rpc_notif_bgp-address-family-ipv4-grouping {
    uses ncs_rpc_notif_bgp-address-family-pre-grouping;
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    uses ncs_rpc_notif_bgp-address-family-post-grouping;
  }

  grouping ncs_rpc_notif_bgp-address-family-ipv6-grouping {
    uses ncs_rpc_notif_bgp-address-family-pre-grouping;
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    uses ncs_rpc_notif_bgp-address-family-post-grouping;
  }

  grouping ncs_rpc_notif_bgp-address-family-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv6 {
        tailf:info "VPNv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
        }
      }
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-pre-grouping;
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-bgp-neighbor-af-grouping {
    leaf multipath {
      tailf:info "Paths from this neighbor is eligible for multipath";
      tailf:cli-full-command;
      type empty;
    }
    list route-policy {
      tailf:info "Apply route policy to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply route policy to inbound routes";
          }
          enum out {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:meta-data string-remove-quotes {
          tailf:meta-value "route-policy <STRING>";
        }
        // NCS drop tailf-common:non-strict-leafref statement
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
    leaf encapsulation-type {
      tailf:info "Specify encapsulation type";
      tailf:cli-full-command;
      type enumeration {
        enum mpls {
          tailf:info "MPLS encapsulation";
        }
        enum vxlan {
          tailf:info "VxLAN encapsulation";
        }
      }
    }
    container remove-private-AS {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-delete-when-empty;
      presence true;
      leaf entire-aspath {
        tailf:info "remove only if all ASes in the path are private";
        type empty;
      }
    }
    container soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      container inbound {
        tailf:info "Allow inbound soft reconfiguration for this neighbor";
        tailf:cli-compact-syntax;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum always {
              tailf:info "Always use soft reconfig, even if route refresh is supported";
            }
            enum inheritance-disable {
              tailf:info "Prevent soft-reconfiguration from being inherited from the parent";
            }
          }
        }
      }
    }
    container allowas-in {
      tailf:info "Allow as-path with my AS present in it";
      leaf as-occurrence-number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurences of AS number";
          range "1..10";
        }
      }
    }
    leaf site-of-origin {
      tailf:info "Site-of-Origin extended community associated with the neighbor";
      type string {
        tailf:info "WORD;;AS number or IPV4 address:index";
      }
    }
    container import {
      tailf:info "Import options for neighbor address-family routes";
      choice import-choice {
        container stitching-rt {
          tailf:info "Import routes using stitching RTs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          choice re-originate-choice {
            leaf re-originate {
              tailf:info "Reoriginate imported routes";
              type empty;
            }
            leaf reoriginate {
              tailf:info "Reoriginate imported routes, version 5.3.x";
              type empty;
            }
          }
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
        container re-originate {
          tailf:info "Re-originate imported routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
      }
    }
    container accept-own {
      tailf:info "Handle self-originated routes with Accept-Own community";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent item being inherited from a parent group";
        type empty;
      }
    }
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Restart time interval";
        type uint16 {
          tailf:info "<1-65535>;;Time interval (min) after which peering session will be reestablished";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the parent";
        type empty;
      }
    }
    container next-hop-unchanged {
      tailf:info "Do not overwrite next hop before advertising to eBGP peers";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-unchanged from being inherited from the parent";
        type empty;
      }
    }
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-policy {
        tailf:info "Route policy to specify criteria to originate default";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited from the parent";
        type empty;
      }
    }
    container send-extended-community-ebgp {
      tailf:info "Send extended community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-extended-community-ebgp from being inherited from the parent";
        type empty;
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an af-group";
        tailf:cli-full-command;
        type string;
      }
    }
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf prefix {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum both {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to this neighbor";
            }
            enum none {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_bgp-neighbor-grouping {
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern "[0-9]+\\.[0-9]+";
        }
      }
    }
    container local {
      tailf:info "Configure local parameter";
      container address {
        tailf:info "use configured local address for bgp peering";
        leaf ip {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;address";
          }
        }
      }
    }
    container local-as {
      tailf:info "Specify local AS number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice local-as-choice {
        leaf inheritance-disable {
          tailf:info "Prevent local AS from being inherited from parent";
          type empty;
        }
        case as-number-case {
          leaf as-number {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
            }
          }
          leaf no-prepend {
            tailf:info "Do not prepend local AS to announcements from this neighbor";
            type empty;
          }
          leaf replace-as {
            tailf:info "Prepend only local AS to announcements to this neighbor";
            type empty;
          }
          leaf dual-as {
            tailf:info "Dual-AS mode";
            type empty;
          }
        }
      }
    }
    uses ncs_rpc_notif_bfd-common-parameters-grouping;
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-compact-syntax;
      leaf ttl-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
      leaf mpls {
        tailf:info "Disable BGP MPLS forwarding";
        type empty;
      }
    }
    container enforce-first-as {
      tailf:info "Enforce the first AS for EBGP routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Do not enforce the first AS for EBGP routes";
        type empty;
      }
    }
    container advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-600>;;time in seconds";
          range "0..600";
        }
      }
      leaf milliseconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-999>;;time in milliseconds";
          range "0..999";
        }
      }
    }
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }
    container ttl-security {
      tailf:info "Enable EBGP TTL security";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent ttl-security from being inherited from the parent";
        type empty;
      }
    }
    container update {
      tailf:info "BGP Update configuration";
      container in {
        tailf:info "Inbound update message handling";
        container filtering {
          tailf:info "Inbound update message filtering";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-vrf-nbr-upd-filter;
          container attribute-filter {
            tailf:info "Attribute-filter configuration";
            leaf group {
              tailf:info "Attribute-filter group configuration";
              type string {
                tailf:info "WORD;;Attribute-filter group name";
              }
            }
          }
        }
      }
    }
    container update-source {
      tailf:info "Source of routing updates";
      uses ncs_rpc_notif_interface-name-grouping;
    }
    container ignore-connected-check {
      tailf:info "Ignore check for directly connected peer";
      presence true;
    }
    leaf cluster-id {
      tailf:info "Enter cluster id for this neighbor";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
        }
        type inet:host {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
        }
      }
    }
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      presence true;
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }
    container capability {
      tailf:info "Advertise capability to the peer";
      container suppress {
        tailf:info "Suppress advertising capability to the peer ";
        container four-byte-as {
          tailf:alt-name 4-byte-as;
          tailf:info "4-byte-as capability";
          presence true;
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being inherited from the parent";
            type empty;
          }
        }
      }
    }
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv4-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses ncs_rpc_notif_bgp-address-family-ipv6-grouping;
          uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
        }
      }
    }
    leaf keychain {
      tailf:info "Set keychain based authentication";
      type string {
        tailf:info "WORD;;The Key Chain name";
      }
      // NCS drop tailf-common:non-strict-leafref statement
    }
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf group-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration from an af-group";
        type string {
          tailf:info "WORD;;AF-group name";
        }
      }
      leaf neighbor-group {
        tailf:info "Inherit configuration from a neighbor-group";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      leaf session-group {
        tailf:info "Inherit address-family independent config from a session-group";
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
    }
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      presence true;
    }
  }

  grouping ncs_rpc_notif_router-bgp-vrf-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Holdtime (0 Disable keepalives/hold time)";
            range "0|3..65535";
          }
        }
        leaf min-neighbor-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor (0to disable)";
            range "0|3..65535";
          }
        }
      }
    }
    container bgp {
      tailf:info "BGP specific commands";
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay is enforced";
          type empty;
        }
      }
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        type empty;
      }
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence true;
        tailf:cli-display-separated;
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-4095>;;Max time (seconds)";
            range "1..4095";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
        leaf purge-time {
          tailf:info "Time before stale routes are purged.";
          type uint16 {
            tailf:info "<1-6000>;;Max time (seconds)";
            range "1..6000";
          }
        }
        leaf graceful-reset {
          tailf:info "Reset gracefully if configuration change forces a peer reset";
          type empty;
        }
      }
      container bestpath {
        tailf:info "Change default route selection criteria";
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }
        container med {
          tailf:info "MED related";
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }
          leaf confed {
            tailf:info "Compare MED among confederation paths";
            tailf:cli-full-command;
            type empty;
          }
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }
        container as-path {
          tailf:info "AS path length";
          leaf ignore {
            tailf:info "Ignore as-path length";
            type empty;
          }
        }
      }
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          tailf:info "Log neighbor state info";
          leaf changes {
            tailf:info "Log neighbor up/down and reset reason";
            type enumeration {
              enum detail {
                tailf:info "Include extra detail in change messages";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
      container default {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }
      container auto-policy-soft-reset {
        tailf:info "Enable automatic soft peer reset on policy reconfiguration";
        leaf disable {
          tailf:info "Disable automatic soft peer reset on policy reconfiguration";
          type empty;
        }
      }
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container import-delay {
        tailf:info "Specify delay for import processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly connected external peer goes down";
        leaf disable {
          tailf:info Disable;
          type empty;
        }
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }
    container mpls {
      tailf:info "Enable mpls parameters";
      container activate {
        tailf:info "Enter mpls interfaces in BGP mpls activate mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-bgp-mpls;
        list interface {
          tailf:info "Interface to enable mpls";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); default is 512 MB";
          range "16..2048";
        }
      }
    }
    container ibgp {
      tailf:info "Set options for iBGP peers";
      container policy {
        tailf:info "Set options for route-policy";
        container out {
          tailf:info "Set options for outbound policy";
          leaf enforce-modifications {
            tailf:info "Allow policy to modify all attributes";
            type empty;
          }
        }
      }
    }
    uses ncs_rpc_notif_bgp-address-family-grouping;
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name config-bgp-afgrp;
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 Address Family";
          }
          enum ipv6 {
            tailf:info "IPv6 Address Family";
          }
          enum l2vpn {
            tailf:info "L2VPN Address Family";
          }
          enum vpnv4 {
            tailf:info "VPNv4 Address Family";
          }
          enum vpnv6 {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum labeled-unicast {
            tailf:info "Address Family modifier";
          }
          enum mdt {
            tailf:info "Address Family modifier";
          }
          enum multicast {
            tailf:info "Address Family modifier";
          }
          enum mvpn {
            tailf:info "Address Family modifier";
          }
          enum rt-filter {
            tailf:info "Address Family modifier";
          }
          enum tunnel {
            tailf:info "Address Family modifier";
          }
          enum unicast {
            tailf:info "Address Family modifier";
          }
          enum vpls-vpws {
            tailf:info "Address Family modifier";
          }
        }
      }
      uses ncs_rpc_notif_router-bgp-neighbor-af-grouping;
    }
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name config-bgp-nbrgrp;
      key name;
      leaf name {
        tailf:info "Neighbor-group name";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses ncs_rpc_notif_bgp-neighbor-grouping;
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name config-bgp-nbr;
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      leaf activate {
        tailf:cli-hide-in-submode;
        type empty;
      }
      uses ncs_rpc_notif_bgp-neighbor-grouping;
    }
    container socket {
      tailf:info "set socket parameters";
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-bgp-grouping {
    container nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable non-stop-routing support for all neighbors";
        type empty;
      }
    }
    uses ncs_rpc_notif_router-bgp-vrf-grouping;
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name config-bgp-sngrp;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }
      container use {
        tailf:info "Inherit configuration from a group";
        leaf session-group {
          tailf:info "Inherit address-family independent config from a session-group";
          type string {
            tailf:info "WORD;;Session group name";
          }
        }
      }
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;maximum hop count";
          }
        }
        leaf mpls {
          tailf:info "Disable BGP MPLS forwarding";
          type empty;
        }
      }
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              tailf:info "Prevent local AS from being inherited from parent";
              type empty;
            }
          }
          case b {
            leaf as-number {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
              }
            }
            leaf no-prepend {
              tailf:info "Do not prepend local AS to announcements from this neighbor";
              type empty;
            }
            leaf replace-as {
              tailf:info "Prepend only local AS to announcements to this neighbor";
              type empty;
            }
            leaf dual-as {
              tailf:info "Dual-AS mode";
              type empty;
            }
          }
        }
      }
      container password {
        tailf:info "Set a password";
        choice password-choice {
          leaf clear {
            tailf:info "Specifies an unencrypted password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an encrypted password will follow";
            type string {
              tailf:info "WORD;;The ENCRYPTED neighbor password string";
            }
          }
          leaf inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
            type empty;
          }
        }
      }
      leaf description {
        tailf:info "Neighbor specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this neighbor";
        }
      }
      container update-source {
        tailf:info "Source of routing updates";
        uses ncs_rpc_notif_interface-name-grouping;
      }
      leaf session-open-mode {
        tailf:info "Establish BGP session using this TCP open mode";
        type enumeration {
          enum active-only {
            tailf:info "Active only";
          }
          enum both {
            tailf:info "Prevent session-open-mode being inherited from the parent";
          }
          enum passive-only {
            tailf:info "Passive only";
          }
        }
      }
      leaf send-buffer-size {
        tailf:info "Set socket and BGP send buffer size";
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
        }
      }
      leaf receive-buffer-size {
        tailf:info "Set socket and BGP receive buffer size";
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
        }
      }
      uses ncs_rpc_notif_bfd-common-parameters-grouping;
    }
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name config-bgp-vrf;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
        }
      }
      leaf label-allocation-mode {
        tailf:info "Set MPLS/VPN label allocation mode";
        tailf:cli-full-command;
        type enumeration {
          enum per-ce {
            tailf:info "Set per CE label mode";
          }
          enum per-vrf {
            tailf:info "Set per VRF label mode";
          }
        }
      }
      container label {
        leaf mode {
          tailf:info "Select label mode";
          type enumeration {
            enum per-ce {
              tailf:info "Set per CE label mode";
            }
            enum per-vrf {
              tailf:info "Set per VRF label mode";
            }
          }
        }
      }
      uses ncs_rpc_notif_router-bgp-vrf-grouping;
    }
  }

  grouping ncs_rpc_notif_police-set-grouping {
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum 1 {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }
    leaf forward-class {
      tailf:info "Set forward class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-7>;;Forward class value";
        range "1..7";
      }
    }
    leaf srp-priority {
      tailf:info "Set SRP priority";
      type uint8 {
        tailf:info "<0-7>;;SRP priority value";
        range "0..7";
      }
    }
  }

  grouping ncs_rpc_notif_police-action-grouping {
    leaf child-conform-aware {
      tailf:cli-break-sequence-commands;
      tailf:info "Enable coupled policing";
      type empty;
    }
    container conform-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses ncs_rpc_notif_police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses ncs_rpc_notif_police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses ncs_rpc_notif_police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_policy-map-class-grouping {
    leaf type {
      tailf:info "The type of classmap";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic classmap";
        }
      }
    }
    leaf drop {
      tailf:info "Drop the packet";
      type empty;
    }
    container redirect {
      tailf:info "Configure PBF redirect feature";
      container nexthop {
        tailf:info "Forward to specified nexthop";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vrf {
          tailf:info "Enter specific VRF Name for this nexthop";
          tailf:cli-optional-in-sequence;
          type vrf-type;
        }
        choice nexthop-choice {
          leaf IPv4-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Input IPv4 Nexthop address";
            }
          }
          leaf IPv6-address {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "X:X::X%zone;;Input IPv6 Nexthop address";
            }
          }
          leaf route-target {
            tailf:info "Enter specific route-target string";
            type string {
              tailf:info "WORD;;IPAddress:index or 2-byte ASN or 4-byte ASN";
            }
          }
        }
      }
    }
    container shape {
      tailf:info "Configure shaping for this class";
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bps {
                  tailf:info "Bits per second (default)";
                }
                enum cellsps {
                  tailf:info "Cells per second";
                }
                enum gbps {
                  tailf:info "Gigabits per second";
                }
                enum kbps {
                  tailf:info "Kilobits per second";
                }
                enum mbps {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-drop-node-name;
          type union {
            type police-burst-units-type;
            type enumeration {
              enum cells {
                tailf:info Cells;
              }
            }
          }
        }
      }
    }
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf units {
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }
    choice police-choice {
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-pmap-c-police;
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in percentage of link bandwidth";
                      range "1..100";
                    }
                  }
                }
              }
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range 1-10,000,000,000";
                  range "1..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:xpath-root 3;
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              uses ncs_rpc_notif_police-action-grouping;
            }
          }
        }
      }
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-pmap-c-police;
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            uses ncs_rpc_notif_police-action-grouping;
          }
        }
      }
    }
    container set {
      tailf:info "Configure marking for this class";
      uses ncs_rpc_notif_police-set-grouping;
    }
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-3>;;Priority level";
          range "1..3";
        }
      }
    }
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf queue-limit-value {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Max Threshold for tail drop";
          range "1..4294967295";
        }
      }
      leaf queue-limit-unit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum bytes {
            tailf:info Bytes;
          }
          enum kbytes {
            tailf:info Kilobytes;
          }
          enum mbytes {
            tailf:info Megabytes;
          }
          enum ms {
            tailf:info Milliseconds;
          }
          enum packets {
            tailf:info "Packets (default)";
          }
          enum us {
            tailf:info Microseconds;
          }
        }
      }
    }
    container service-function-path {
      tailf:info "Configure NSH service function action";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Service function path id";
          range "1..16777215";
        }
      }
      leaf index {
        tailf:info "Specify service path index";
        type uint8 {
          tailf:info "<1-255>;;Service function path index";
          range "1..255";
        }
      }
      leaf metadata {
        tailf:info "service-function metadata";
        type string {
          tailf:info "WORD;;Specify metadata name";
        }
      }
    }
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum accounting {
            tailf:info "Accounting policymap";
          }
          enum control {
            tailf:info "Control policy-map";
          }
          enum none {
            tailf:info "Untyped policymap";
          }
          enum pbr {
            tailf:info "PBR policymap";
          }
          enum performance-traffic {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum qos {
            tailf:info "QoS policymap (default)";
          }
          enum redirect {
            tailf:info "Redirect policymap";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the child service policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
    }
    container random-detect {
      tailf:info "Enable Random Early Detection";
      leaf default {
        tailf:info "Enable RED with default min and max thresholds";
        tailf:cli-full-command;
        type empty;
      }
      list cos {
        tailf:info "COS based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;COS value";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      list dei {
        tailf:info "DEI based WRED";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-1>;;DEI value";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info
              "<0-63>;;Differentiated services codepoint value
               af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43
               cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental valueand ',' for ranges";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info
              "<0-7>;;Precedence value
               critical,flash,flash-override,immediate,
               internet,network,priority,routine and ',' for ranges";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      list discard-class {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type uint8 {
            tailf:info "<0-7>;;Discard Class  value";
            range "0..7";
          }
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
      container default-values {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses ncs_rpc_notif_class-random-detect-grouping;
      }
    }
  }

  grouping ncs_rpc_notif_performance-mgmt-grouping {
    choice case-choice {
      container AverageCpuUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses ncs_rpc_notif_average-cpu-used-grouping;
      }
      container AverageCPUUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses ncs_rpc_notif_average-cpu-used-grouping;
      }
    }
    leaf sample-size {
      tailf:info "Number of samples to be taken";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Number of samples";
        range "1..60";
      }
    }
    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }

  grouping ncs_rpc_notif_ipv4-ipv6-common-grouping {
    leaf conflict-policy {
      tailf:info "ip address conflict algorithm selection";
      tailf:cli-full-command;
      type enumeration {
        enum highest-ip {
          tailf:info "Keeps the highest ip address in the conflict set UP";
        }
        enum longest-prefix {
          tailf:info "Keeps the longest prefix match in the conflict set UP";
        }
        enum static {
          tailf:info "Keeps the existing interface UP across new address configs";
        }
      }
    }
    list prefix-list {
      tailf:info "Prefix-list command";
      tailf:cli-mode-name config-ipv_pfx;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of a prefix list - maximum 32 characters";
          length "1..32";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info
              "deny;;Specify packets to reject
               permit;;Specify packets to forward
               remark;;Comment for access list";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "Encapsulation type ARPA";
          }
          enum SRP {
            tailf:info "Encapsulation type SRP";
          }
          enum SRPA {
            tailf:info "Encapsulation type SRPA";
          }
          enum SRPB {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum ipv6 {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum no-limit {
              tailf:info "No limit to number of allowable tftp server processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }

  grouping ncs_rpc_notif_telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 configuration";
          }
          enum ipv6 {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf dscp {
        tailf:info dscp;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;dscp value";
        }
      }
      container server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-servers {
          tailf:info "Set number of allowable telnet sessions";
          type uint8 {
            tailf:info "<1-100>;;Set number of allowable telnet sessions";
            range "1..100";
          }
        }
        leaf access-list {
          tailf:info "Access list for telnet server";
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value vrf;
        type inet:host {
          tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
        }
      }
      leaf ip-version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
          range "1..4";
        }
      }
      leaf minpoll {
        tailf:info "Configure minimum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Minimum poll rate, default 6, less than maxpoll";
          range "4..17";
        }
      }
      leaf maxpoll {
        tailf:info "Configure maximum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Maximum poll rate, default 10, greater than minpoll";
          range "4..17";
        }
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
      leaf burst {
        tailf:info "Use burst mode";
        type empty;
      }
      leaf iburst {
        tailf:info "Use initial burst mode";
        type empty;
      }
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses ncs_rpc_notif_interface-name-grouping;
      }
      leaf key {
        tailf:info "Configure peer authentication key";
        type uint16 {
          tailf:info "<1-65535>;;Peer key number";
          range "1..65535";
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-static-options-grouping {
    leaf bfd {
      tailf:info "Configure BFD paramenters";
      type enumeration {
        enum fast-detect {
          tailf:info "Enable Fast detection";
        }
      }
    }
    leaf minimum-interval {
      when "../bfd" {
        tailf:xpath-root 3;
      }
      tailf:info "Hello interval";
      type uint16 {
        tailf:info "<3-30000>;;interval in milli-seconds";
        range "3..30000";
      }
    }
    leaf multiplier {
      when "../bfd" {
        tailf:xpath-root 3;
      }
      tailf:info "Detect multiplier";
      type uint8 {
        tailf:info "<1-10>;;Detect multiplier";
        range "1..10";
      }
    }
    choice metric-choice {
      leaf metric {
        tailf:info "Distance metric for this route";
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-254>;;Distance metric for this route";
          range "1..254";
        }
      }
      container metric2 {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf metric {
          tailf:info "Set metric for this route";
          type uint32 {
            tailf:info "<1-16777214>;;Set metric for this route";
            range "1..16777214";
          }
        }
      }
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Set tag for this route";
      }
    }
    leaf permanent {
      tailf:info "Permanent route";
      type empty;
    }
    leaf vrflabel {
      tailf:info "VRF label";
      type uint32 {
        tailf:info "<0-4294967295>;;VRF label";
      }
    }
    leaf tunnel-id {
      tailf:info "Tunnel ID";
      type uint32 {
        tailf:info "<0-4294967295>;;Tunnel ID";
      }
    }
    leaf description {
      tailf:info "description of the static route";
      type string {
        tailf:info "WORD;;short description of static route";
      }
    }
  }

  grouping ncs_rpc_notif_router-static-grouping {
    container maximum {
      tailf:info "Limit the number of static paths which may be configured";
      container path {
        tailf:info "Limit the number of static paths which may be configured";
        leaf ipv4 {
          tailf:info "IPv4 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
        leaf ipv6 {
          tailf:info "IPv6 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
      }
    }
    container address-family {
      tailf:info "Static route address family configuration subcommands";
      container ipv4 {
        tailf:info "IPv4 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-static-afi;
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-static-afi;
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses ncs_rpc_notif_router-static-options-grouping;
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-igmp-grouping {
    list interface {
      tailf:info "IGMP interface configuration subcommands";
      tailf:cli-mode-name config-igmp-default-if;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }
      container explicit-tracking {
        tailf:info "IGMPv3 explicit host tracking";
        presence true;
      }
      leaf version {
        tailf:info "IGMP version";
        type uint8 {
          tailf:info "<1-3>;;version number";
        }
      }
      leaf router {
        tailf:info "Enable/Disable Router side functionality in IGMP";
        type enumeration {
          enum disable {
            tailf:info "Disable Router side functionality in IGMP";
          }
          enum enable {
            tailf:info "Enable Router side functionality in IGMP";
          }
        }
      }
      list join-group {
        tailf:info "IGMP join multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        choice source-choice {
          leaf source-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to include";
            }
          }
          leaf exclude {
            tailf:info "Exclude the only following source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to exclude";
            }
          }
        }
      }
      list static-group {
        tailf:info "IGMP static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        leaf source-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address to join";
          }
        }
      }
    }
    container explicit-tracking {
      tailf:info "IGMPv3 explicit host tracking";
      presence true;
    }
    leaf version {
      tailf:info "IGMP version";
      type uint8 {
        tailf:info "<1-3>;;version number";
        range "1..3";
      }
    }
    leaf access-group {
      tailf:info "IGMP group access group";
      type string {
        tailf:info "WORD;;IP Named Standard Access list";
      }
    }
    leaf query-interval {
      tailf:info "IGMP host query interval";
      type uint16 {
        tailf:info "<1-3600>;;Query interval in seconds";
        range "1..3600";
      }
    }
    leaf query-max-response-time {
      tailf:info "IGMP max query response value";
      type uint8 {
        tailf:info "<1-12>;;query response value in seconds";
        range "1..12";
      }
    }
    leaf robustness-count {
      tailf:info "IGMP robustness variable";
      type uint8 {
        tailf:info "<2-10>;;Robustness variable count";
        range "2..10";
      }
    }
  }

  grouping ncs_rpc_notif_key-grouping {
    leaf encryption {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum 0 {
          tailf:info "Specifies an UNENCRYPTED key will follow";
        }
        enum 7 {
          tailf:info "Specifies an ENCRYPTED key will follow";
        }
      }
    }
    leaf key {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value 0|7;
      tailf:meta-data secret-password;
      type string {
        tailf:info "LINE;;The UNENCRYPTED key";
      }
    }
  }

  grouping ncs_rpc_notif_l2vpn-bridge-domain-mac-grouping {
    container learning {
      tailf:info "MAC learning";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable MAC learning";
        type empty;
      }
    }
    container limit {
      tailf:info "MAC-Limit configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-l2vpn-bg-bd-ac-mac-limit;
      leaf maximum {
        tailf:info "Number of MAC addresses after which MAC limit action is taken";
        type uint32 {
          tailf:info "<1-512000>;;Number of MAC addresses after which MAC limit action is taken";
          range "1..512000";
        }
      }
      leaf action {
        tailf:info "MAC address limit enforcement action";
        type enumeration {
          enum flood {
            tailf:info "Stop learning but continue flooding";
          }
          enum no-flood {
            tailf:info "Stop learning and stop flooding";
          }
          enum none {
            tailf:info "No action";
          }
          enum shutdown {
            tailf:info "Stop forwarding";
          }
        }
      }
      leaf notification {
        tailf:info "MAC address limit notification action";
        type enumeration {
          enum both {
            tailf:info "Generate syslog message and SNMP trap";
          }
          enum none {
            tailf:info "No notification";
          }
          enum syslog {
            tailf:info "Generate syslog message";
          }
          enum trap {
            tailf:info "Generate SNMP trap";
          }
        }
      }
    }
    container secure {
      tailf:info "MAC Secure configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-l2vpn-bg-bd-mac-secure;
      leaf action {
        tailf:info "MAC secure enforcement action";
        type enumeration {
          enum none {
            tailf:info "Forward the violating packet and allow the MAC to be relearned";
          }
          enum shutdown {
            tailf:info "Shutdown the violating bridge port";
          }
        }
      }
      leaf logging {
        tailf:info "Enable Logging";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_freqsync-quality-grouping {
    choice quality-type {
      leaf exact {
        tailf:info "Specify the exact QL value to use";
        type empty;
      }
      leaf highest {
        tailf:info "Specify the highest acceptable QL value";
        type empty;
      }
      leaf lowest {
        tailf:info "Specify the lowest acceptable QL value";
        type empty;
      }
    }
    container itu-t {
      tailf:info "ITU-T QL options";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf option {
        tailf:info "ITU-T QL options";
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
      leaf generation {
        tailf:info "ITU-T QL option 2 generation";
        tailf:cli-incomplete-command;
        when "../option = '2'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 2, generation 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2, generation 2";
          }
        }
      }
      leaf ql1 {
        tailf:cli-drop-node-name;
        when "../option = '1'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum PRC;
          enum SSU-A;
          enum SSU-B;
          enum SEC;
          enum DNU;
        }
      }
      leaf ql2 {
        tailf:cli-drop-node-name;
        when "../option = '2'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum DUS {
            tailf:info "This signal should not be used for synchronization";
          }
          enum PRS {
            tailf:info "ITU-T Option 2, Primary reference source";
          }
          enum SMC {
            tailf:info "ITU-T Option 2, SONET clock self timed";
          }
          enum ST2 {
            tailf:info "ITU-T Option 2, Stratum 2";
          }
          enum ST3 {
            tailf:info "ITU-T Option 2, Stratum 3";
          }
          enum ST3E {
            tailf:info "ITU-T Option 2, Stratum 3E";
          }
          enum STU {
            tailf:info "ITU-T Option 2, Synchronized - traceability unknown";
          }
          enum TNC {
            tailf:info "ITU-T Option 2, Transit node clock";
          }
          enum ST4;
          enum PROV;
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-hsrp-group-grouping {
    leaf name {
      tailf:info "MGO session name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session name";
      }
    }
    leaf authentication {
      tailf:info "Authentication string";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Authentication string";
      }
    }
    container timers {
      tailf:info "Set hello and hold timers";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      container hello {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hello-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hello time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify hellotime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Hellotime in msecs";
              range "100..3000";
            }
          }
        }
      }
      container hold {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hold-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hold time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify holdtime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Holdtime in msecs";
              range "100..3000";
            }
          }
        }
      }
    }
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }
    container preempt {
      tailf:info "Force active if higher priority";
      tailf:cli-delete-when-empty;
      presence true;
      leaf delay {
        tailf:info "Wait before preempting";
        type uint16 {
          tailf:info "<0-3600>;;Number of seconds to delay";
          range "0..3600";
        }
        default 0;
      }
    }
    leaf priority {
      tailf:info "Priority level";
      type uint8 {
        tailf:info "<0-255>;;Priority value";
      }
    }
    list track {
      tailf:info "Configure tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type ifname;
      }
      leaf priority-decrement {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Priority decrement";
          range "1..255";
        }
        default 10;
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-delete-when-empty;
        presence true;
        container peer {
          tailf:info "Information about HSRP peer for BFD monitoring";
          container ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses ncs_rpc_notif_interface-name-grouping;
            }
          }
          container ipv6 {
            tailf:info "BFD peer interface IPv6 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X::X;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses ncs_rpc_notif_interface-name-grouping;
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-hsrp-ipv4-group-grouping {
    leaf address {
      tailf:info "Enable hot standby protocol for IP";
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
        type enumeration {
          enum learn {
            tailf:info "Learn virtual IP address from peer";
          }
        }
      }
    }
    uses ncs_rpc_notif_router-hsrp-group-grouping;
  }

  grouping ncs_rpc_notif_router-hsrp-ipv6-group-grouping {
    uses ncs_rpc_notif_router-hsrp-group-grouping;
    container address {
      tailf:info "Enable hot standby protocol for IP";
      leaf-list global {
        tailf:info "Global HSRP IPv6 address";
        tailf:cli-list-syntax;
        type inet:ipv6-address {
          tailf:info "X:X::X;;Set Global HSRP IPv6 address";
        }
      }
      container linklocal {
        tailf:info "HSRP IPv6 linklocal address";
        choice linklocal-choice {
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv6-address {
              tailf:info "X:X::X;;HSRP IPv6 linklocal address";
            }
          }
          container autoconfig {
            tailf:info "Autoconfigure the HSRP IPv6 linklocal address";
            tailf:cli-delete-when-empty;
            presence true;
            leaf legacy-compatible {
              tailf:info "Autoconfigure for Legacy compatibility (with IOS/NX-OS)";
              type empty;
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-atm-grouping {
    container atm {
      tailf:info "Global ATM interface configuration subcommands";
      container mcpt-timers {
        tailf:info "Configure Maximum cell Packing Timeout Values";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf timer-1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer1 value in microsecond (CEoP min value is 101)";
            range "50..4095";
          }
        }
        leaf timer-2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer2 value in microsecond";
            range "50..4095";
          }
        }
        leaf timer-3 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<60-4095>;;MCPT timer3 value in microsecond";
            range "60..4095";
          }
        }
      }
      container ilmi-keepalive {
        tailf:info "ILMI keepalive configuration";
        presence true;
      }
    }
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name config-atm-l2transport-pvc;
      key vpi-vci;
      leaf vpi-vci {
        type string {
          tailf:info "WORD;;VPI/VCI";
        }
      }
      uses ncs_rpc_notif_interface-service-policy-grouping;
      container shape {
        tailf:info "ATM Traffic Shaping";
        container vbr-nrt {
          tailf:info "Variable Bit Rate - Non Real Time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf peak-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Peak output rate in kbps (max:OC12 599040; OC3 149760; T1 1544; T3 44736)";
            }
          }
          leaf sustained-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Sustained output rate (kbps)";
            }
          }
          leaf burst-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-8192>;;Burst size (cells)";
            }
          }
        }
      }
      leaf encapsulation {
        tailf:info "Configure encapsulation on this PVC";
        tailf:cli-full-command;
        type enumeration {
          enum aal0 {
            tailf:info "Use aal0 encapsulation on this PVC";
          }
          enum aal5 {
            tailf:info "Use aal5 encapsulation on this PVC";
          }
          enum aal5mux {
            tailf:info "Use aal5mux encapsulation on this PVC";
          }
          enum aal5nlpid {
            tailf:info "Use aal5nlpid encapsulation on this PVC";
          }
          enum aal5snap {
            tailf:info "Use aal5snap encapsulation on this PVC";
          }
        }
      }
      container oam {
        tailf:info "Configure ATM OAM VC commands";
        container retry {
          tailf:info "Enter OAM to configure retry freq";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf up-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as up";
            }
          }
          leaf down-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as down";
            }
          }
          leaf retry-frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1000>;;OAM retry polling frequency in seconds";
            }
          }
        }
      }
      container oam-pvc {
        tailf:info "Enter OAM to generate OAM cells  ";
        container manage {
          tailf:info "OAM PVC management";
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable OAM PVC management";
            tailf:cli-reset-container;
            tailf:cli-full-command;
            type empty;
          }
          leaf frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-600>;;OAM loopback frequency (seconds)";
              range "0..600";
            }
          }
        }
      }
      container cell-packing {
        tailf:info "Configure L2VPN cell packing parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf cells {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<2-255>;;Maximum number of cells to be packed in a packet";
            range "2..255";
          }
        }
        leaf timer {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-3>;;Which cell packing timer to use";
            range "1..3";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_ipsla-operation-type-grouping {
    leaf tag {
      tailf:info "Add a tag for this operation";
      type string {
        tailf:info "WORD;;Tag string";
      }
    }
    leaf timeout {
      tailf:info "Probe/Control timeout interval";
      type uint32 {
        tailf:info "<1-604800000>;;Probe/Control timeout in ms (default 5000 ms)";
        range "1..604800000";
      }
    }
    leaf vrf {
      tailf:info "Configure IPSLA for a VPN Routing/Forwarding instance";
      type string {
        tailf:info "WORD;;VPN Routing/Forwarding instance name";
      }
    }
    container source {
      tailf:info "Address/port of the source device";
      leaf address {
        tailf:info "IPv4 address of the source device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the source device";
        }
      }
      leaf port {
        tailf:info "Port number on source device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }
    container destination {
      tailf:info "Address/port of the target device";
      leaf address {
        tailf:info "IPv4 address of the target device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the target device";
        }
      }
      leaf port {
        tailf:info "Port number on target device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }
    container statistics {
      tailf:info "Statistics collection parameters for this operation";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-ipsla-op-stats;
      tailf:cli-incomplete-command;
      leaf hourly {
        tailf:info "Statistics collection aggregated over an hour";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf buckets {
        tailf:info "Number of Hours for which statistics are kept";
        type uint8 {
          tailf:info "<0-25>;;Specify number of hours (default 2)";
          range "0..25";
        }
      }
    }
    container packet {
      tailf:info "Probe packet configuration parameters";
      leaf count {
        tailf:info "Number of packets to be transmitted during a probe";
        type uint16 {
          tailf:info "<1-60000>;;Packet count (default 10)";
          range "1..60000";
        }
      }
      leaf interval {
        tailf:info "Inter packet interval";
        type uint16 {
          tailf:info "<1-60000>;;Packet interval (default 20 ms)";
          range "1..60000";
        }
      }
    }
    leaf tos {
      tailf:info "Type of service setting in probe packet";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Type of service number";
      }
    }
    container datasize {
      tailf:info "Protocol data size in payload of probe packets";
      leaf request {
        tailf:info "Payload size in request probe packet";
        type uint16 {
          tailf:info "<16-1500>;;Enter request datasize in byte";
        }
      }
    }
    container target {
      tailf:info "Target for the MPLS LSP operation";
      container traffic-eng {
        tailf:info "Traffic engineering target";
        leaf tunnel {
          tailf:info "TE tunnel interface";
          type uint16 {
            tailf:info "<0-65535>;;Tunnel interface number";
          }
        }
      }
      container pseudowire {
        tailf:info "Pseudowire target";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Target address";
          }
        }
        leaf pw-id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Virtual Circuit ID";
          }
        }
      }
      leaf ipv4 {
        tailf:info "Target specified as an IPv4 address";
        tailf:cli-full-command;
        type ipv4-prefix {
          tailf:info "A.B.C.D/prefix;;Target FEC address with mask";
        }
      }
    }
    leaf frequency {
      tailf:info "Frequency of the probing";
      type uint32 {
        tailf:info "<1-604800>;;Probe interval in seconds (default 60)";
        range "1..604800";
      }
    }
    container statistics-interval {
      tailf:cli-drop-node-name;
      container statistics {
        tailf:info "Statistics collection parameters for this operation";
        list interval {
          tailf:info "Statistics collection over specified time interval";
          tailf:cli-mode-name config-ipsla-op-stats;
          key seconds;
          leaf seconds {
            type uint16 {
              tailf:info "<1-3600>;;Interval in seconds";
              range "1..3600";
            }
          }
          leaf buckets {
            tailf:info "Maximum number of buckets to keep";
            type uint8 {
              tailf:info "<1-100>;;Buckets of enhanced statistics kept";
              range "1..100";
            }
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_storm-control-grouping {
    container storm-control {
      tailf:info "Storm Control";
      container broadcast {
        tailf:info "Broadcast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container multicast {
        tailf:info "Multicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container unknown-unicast {
        tailf:info "Unknown-unicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_vrf-af-ipv4-grouping {
    container import {
      tailf:info "VRF import";
      leaf route-policy {
        tailf:info "Use route-policy for import filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container route-target {
        tailf:info "Specify import route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-vrf-import-rt;
        uses ncs_rpc_notif_vrf-route-target-grouping;
      }
      container from {
        tailf:info "Import routes from a VRF";
        container vrf {
          tailf:info "VRF import";
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PEs";
            type empty;
          }
        }
        container default-vrf {
          tailf:info "Import routes from the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for import filtering";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PE";
            type empty;
          }
        }
      }
    }
    container export {
      tailf:info "VRF export";
      leaf route-policy {
        tailf:info "Use route-policy for export filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        // NCS drop tailf-common:non-strict-leafref statement
      }
      container route-target {
        tailf:info "Specify export route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-vrf-export-rt;
        uses ncs_rpc_notif_vrf-route-target-grouping;
      }
      container to {
        tailf:info "Export routes to a VRF";
        container vrf {
          tailf:info "VRF export";
          leaf allow-imported-vpn {
            tailf:info "Allow export of imported VPN routes to non-default VRF";
            type empty;
          }
        }
        container default-vrf {
          tailf:info "Export routes to the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for export";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf allow-imported-vpn {
            tailf:info "Export imported VPN routes to default VRF";
            type empty;
          }
        }
      }
    }
    container maximum {
      tailf:info "Set maximum prefix limit";
      container prefix {
        tailf:info "Set table's maximum prefix limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-5000000>;;Maximum table's prefix limit";
            range "32..5000000";
          }
        }
        leaf mid-thresh {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;mid-thresh (% of max)";
            range "1..100";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_snmp-server-host-grouping {
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type string {
          tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
        }
      }
      leaf informs {
        tailf:info "Send Inform messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf traps {
        tailf:info "Send Trap messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 1 {
            tailf:info "WORD  Use 1 for SNMPv1";
          }
          enum 2c {
            tailf:info "WORD;;Use 2c for SNMPv2c";
          }
          enum 3 {
            tailf:info "WORD;;Use 3 for SNMPv3";
          }
        }
      }
      leaf security-level {
        when "../version = 3" {
          tailf:xpath-root 3;
          tailf:dependency "../version";
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum auth {
            tailf:info "Using authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Using noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Using authPriv Security Level";
          }
        }
      }
      leaf enc {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum clear {
            tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }
      leaf community-string {
        tailf:cli-drop-node-name;
        mandatory true;
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf udp-port {
        tailf:info "udp port to which notifications should be sent";
        tailf:cli-optional-in-sequence;
        type uint16;
      }
    }
  }

  grouping ncs_rpc_notif_multicast-routing-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mcast-default-ipv4;
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name config-mcast-default-ipv4-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          choice status-choice {
            leaf enable {
              tailf:info "Enable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf boundary {
            tailf:info "Boundary for administratively scoped multicast addresses";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Access list specifying scoped multicast groups";
            }
          }
        }
        container interface-inheritance {
          tailf:info "Knob to separate enabling/disabling multicast routing & forwarding";
          leaf disable {
            tailf:info "Disable inheriting En/Dis config";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf nsf {
          tailf:cli-full-command;
          type empty;
        }
        leaf log-traps {
          tailf:info "Enable logging trap events";
          type empty;
        }
        container mdt {
          tailf:info "MVPN configuration";
          leaf mtu {
            tailf:info "MDT mtu configuration";
            type uint16 {
              tailf:info "<1401-65535>;;MTU value";
              range "1401..65535";
            }
          }
          container source {
            tailf:info "Interface used to set MDT source address";
            uses ncs_rpc_notif_interface-name-grouping;
          }
          container data {
            tailf:info "Data MDT configuration";
            container address {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf mdt-group-address {
                tailf:cli-drop-node-name;
                type ipv4-prefix {
                  tailf:info "A.B.C.D/length;;Data MDT group IP address/prefix length";
                }
              }
              leaf threshold {
                tailf:info "Traffic rate threshold in Kbps to trigger Data MDT";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-4294967295>;;Threshold value (kbps). Default 1kbps";
                }
                default 1;
              }
              leaf acl-name {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value threshold;
                type string {
                  tailf:info "WORD;;ACL for Customer VRF groups allowed to do Data MDT";
                }
              }
            }
            container p2mp-te {
              tailf:info "P2MPTE Data MDT core";
              choice max-or-rp-choice {
                container max-number {
                  tailf:cli-drop-node-name;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf value {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-255>;;Maximum number of data-mdts to be triggered";
                    }
                  }
                }
                leaf route-policy {
                  tailf:info "Route policy to select data mdt core";
                  type string {
                    tailf:info "WORD;;Route policy name";
                  }
                  // NCS drop tailf-common:non-strict-leafref statement
                }
              }
            }
          }
          container default {
            tailf:info "MDT Default distribution tree";
            leaf ipv4 {
              tailf:info "IPv4 encapsulated MDT";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address MDT default group";
              }
            }
            container mldp {
              tailf:info "mLDP default distribution tree";
              list ipv4 {
                tailf:info "MP2MP core-tree with IPv4 Root Address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key address;
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Root address";
                  }
                }
                container partitioned {
                  tailf:info "mLDP Partitioned MDT";
                  leaf bidir {
                    tailf:info "Enable Exclusive Partitioned MDT for Bidir";
                    type empty;
                  }
                }
              }
            }
            container p2mp-te {
              tailf:info "P2MP-TE default distribution tree";
              tailf:cli-delete-when-empty;
              presence true;
              leaf attribute-set {
                tailf:info "The Attribute Set template to be used with the TE tunnel request";
                type string {
                  tailf:info "WORD;;Name of template describing the Attribute Set";
                }
              }
              container static {
                tailf:info "Static P2MP-TE Tunnel";
                leaf tunnel-mte {
                  tailf:cli-allow-join-with-value {
                    tailf:cli-display-joined;
                  }
                  type uint16 {
                    tailf:info "<0-65535>;;MPLS Traffic Engineering P2MP Tunnel interface(s)";
                  }
                }
              }
            }
          }
        }
        container bgp {
          tailf:info "Enable BGP MVPN Discovery";
          container auto-discovery {
            tailf:info "Enable BGP Auto-Discovery";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-mcast-vrf-ipv4-bgp-ad;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            leaf ad-tree {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type enumeration {
                enum ingress-replication {
                  tailf:info "IR core tree";
                }
                enum mldp {
                  tailf:info "mLDP core tree";
                }
                enum p2mp-te {
                  tailf:info "RSVP P2MP-TE core tree";
                }
                enum pim {
                  tailf:info "PIM core tree";
                }
              }
            }
            leaf inter-as {
              tailf:info "Inter-AS MVPN";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf leaf-info-required {
              tailf:info "Explicit tracking of S-PMSI core trees";
              type empty;
            }
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          tailf:cli-delete-when-empty;
          presence true;
          leaf hash {
            tailf:info "Enter a hashing algorithm";
            type enumeration {
              enum source {
                tailf:info "Enable source based multipath hashing (Compatible with IOS versions)";
              }
              enum source-group {
                tailf:info "Enable source, group based multipath hashing";
              }
              enum source-nexthop {
                tailf:info "Enable source with next-hop multipath hashing (better distribution)";
              }
            }
          }
        }
        container ssm {
          tailf:info "Configure a group range for Source-Specific use";
          leaf range {
            tailf:info "Provide ACL that specifies non-standard SSM range";
            type string {
              tailf:info "WORD;;Access list specifying SSM group range";
            }
            // NCS drop tailf-common:non-strict-leafref statement
          }
          leaf allow-override {
            tailf:info "Allow SSM ranges to be overridden by more specific ranges";
            type empty;
          }
        }
        container oom-handling {
          tailf:info "Enable out-of-memory handling";
          presence true;
        }
        leaf rate-per-route {
          tailf:info "Enable/disable per (S,G) rate calculation";
          tailf:cli-full-command;
          type empty;
        }
        container accounting {
          tailf:info "Enable/disable Accounting";
          container per-prefix {
            tailf:info "Enable per (S,G) accounting.";
            presence true;
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv6;
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name config-mcast-default-ipv6-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf enable {
            tailf:info "Enable IP multicast";
            tailf:cli-full-command;
            type empty;
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          presence true;
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-mld-grouping {
    leaf version {
      tailf:info "MLD version";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-2>;;version number";
        range "1..2";
      }
    }
    list interface {
      tailf:info "MLD interface configuration subcommands";
      tailf:cli-mode-name config-mld-default-if;
      key name;
      leaf name {
        type ifname;
      }
      leaf router {
        tailf:info "Enable/Disable Router side functionality in MLD";
        tailf:cli-full-command;
        type enumeration {
          enum enable {
            tailf:info "Enable Router side functionality in MLD";
          }
          enum disable {
            tailf:info "Disable Router side functionality in MLD";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-pim-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "Enter ipv4 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv4;
        leaf hello-interval {
          tailf:info "Inherited by all interfaces : Hello interval in seconds";
          type uint16 {
            tailf:info "<1-3600>;;Hello interval in seconds";
            range "1..3600";
          }
        }
        container rpf {
          tailf:info "RPF commands";
          container topology {
            tailf:info "Select RPF topology";
            leaf route-policy {
              tailf:info "Route policy to select RPF topology";
              type string {
                tailf:info "WORD;;Name of the policy";
              }
              // NCS drop tailf-common:non-strict-leafref statement
            }
          }
        }
        container mdt {
          tailf:info "Multicast Distribution Tree commands";
          container c-multicast-routing {
            tailf:info "MVPN customer routing commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-pim-default-ipv4-mdt-cmcast;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            choice protocol-choice {
              leaf bgp {
                tailf:info "BGP customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
              leaf pim {
                tailf:info "PIM customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
            }
            container unicast-reachability {
              tailf:info "Control addition of Extended Communities to Unicast VPN-IP routes";
              tailf:cli-compact-syntax;
              leaf connector {
                tailf:info "Enable/Disable Connector";
                type enumeration {
                  enum disable {
                    tailf:info "Disable Connector Attribute";
                  }
                  enum enable {
                    tailf:info "Enable Connector Attribute";
                  }
                }
              }
            }
          }
        }
        container auto-rp {
          tailf:info "Auto-RP Commands";
          container listen {
            tailf:info "RP discovery through AUTORP protocol";
            leaf disable {
              tailf:info "Disable RP discovery through the AUTORP protocol";
              type empty;
            }
          }
        }
        list rp-address {
          tailf:info "Configure Rendezvous Point";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type inet:host {
              tailf:info "IP name or address of Rendezvous Point";
            }
          }
          leaf group-access-list {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Access list of groups that should map to given RP";
            }
          }
          leaf override {
            tailf:info "Static RP config overrides auto-rp and BSR";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf bidir {
            tailf:info "Specify keyword bidir to configure a bidir RP";
            type empty;
          }
        }
        leaf accept-register {
          tailf:info "Registers accept filter";
          type string {
            tailf:info "WORD;;IP named access list";
          }
        }
        container spt-threshold {
          tailf:info "Configure threshold for switching to SPT on last-hop";
          container infinity {
            tailf:info "Always stay on shared-tree";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf group-list {
              tailf:info "Only stay on the shared-tree for specified groups";
              type string {
                tailf:info "WORD;;Access-list of threshold limited groups";
              }
            }
          }
        }
        container neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }
        container neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }
        container nsf {
          tailf:info "Configure Non-stop forwarding (NSF) options(cisco-support)";
          leaf lifetime {
            tailf:info "Override default maximum lifetime for PIM NSF mode";
            type uint16 {
              tailf:info "<10-600>;;Maximum time for PIM NSF mode in seconds";
              range "10..600";
            }
          }
        }
        container log {
          tailf:info "Enable PIM logging";
          container neighbor {
            tailf:info "Enable PIM neighbor logging";
            leaf changes {
              tailf:info "Enable PIM neighbor state logging";
              type empty;
            }
          }
        }
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name config-pim-ipv4-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          uses ncs_rpc_notif_bfd-common-parameters-grouping;
          choice status-choice {
            leaf enable {
              tailf:info "Enable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf dr-priority {
            tailf:info "PIM Hello DR priority";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Hello DR priority, preference given to larger value";
            }
          }
        }
        container maximum {
          tailf:info "Maximum state limits";
          container routes {
            tailf:info "PIM Routes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000>;;Maximum PIM routes";
                range "1..200000";
              }
            }
            leaf threshold {
              tailf:info "Set threshold to print warning";
              type uint32 {
                tailf:info "<1-200000>;;Threshold value";
                range "1..200000";
              }
            }
          }
        }
      }
      container ipv6 {
        tailf:info "Enter ipv6 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv6;
        leaf neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }
        leaf neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name config-pim-ipv6-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interace Name";
            }
          }
          leaf enable {
            tailf:info "Enable PIM processing on this interface";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-rip-redistribute-grouping {
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      // NCS drop tailf-common:non-strict-leafref statement
    }
  }

  grouping ncs_rpc_notif_router-rip-grouping {
    list interface {
      tailf:cli-mode-name config-rip-if;
      key name;
      leaf name {
        type ifname;
      }
      leaf passive-interface {
        tailf:info "Suppress routing updates on this interface";
        tailf:cli-full-command;
        type empty;
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<5-50000>;;Interval between updates";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Invalid";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Holddown";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-250000>;;Flush";
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container static {
        tailf:info Static;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses ncs_rpc_notif_router-rip-redistribute-grouping;
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        uses ncs_rpc_notif_router-rip-redistribute-grouping;
      }
    }
  }

  grouping ncs_rpc_notif_router-vrrp-if-af-vrrp-grouping {
    leaf priority {
      tailf:info "Set priority level";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority value";
      }
    }
    container preempt {
      tailf:info "Preempt Master router if higher priority";
      choice preempt-choice {
        leaf delay {
          tailf:info "Wait before preempting";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-3600>;;Number of seconds to delay";
            range "1..3600";
          }
        }
        leaf disable {
          tailf:info "Disable preemption";
          type empty;
        }
      }
    }
    container timer {
      tailf:info "Set advertisement timer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice timer-choice {
        leaf time-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Advertisement time in seconds";
          }
        }
        leaf msec {
          tailf:info "Configure in milliseconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-3000>;;Advertisement time in milliseconds (100-3000)";
          }
        }
      }
      leaf force {
        tailf:info "Force the configured values to be used (required for msec)";
        type empty;
      }
    }
    container track {
      tailf:info "Track an item, reducing priority if it goes down";
      list interface {
        tailf:info "Track an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-254>;;Priority decrement";
            range "1..254";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-bgp-af-advertise-grouping {
    container re-originated {
      tailf:info "Advertise Re-orignated routes only";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }
    container local {
      tailf:info "Advertisement of local routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }
    leaf disable {
      tailf:info "Disable Advertisement of selected SAFI";
      tailf:cli-full-command;
      type empty;
    }
    container imported-from-vrf {
      tailf:info "VRF extranet imported routes";
      leaf disable {
        tailf:info "Disable advertisement of VRF extranet imported routes";
        type empty;
      }
    }
    container imported-from-default-vrf {
      tailf:info "Default VRF imported routes";
      leaf disable {
        tailf:info "Disable advertisement of default VRF imported routes";
        type empty;
      }
    }
  }

  grouping ncs_rpc_notif_controller-dwdm-grouping {
    list dwdm {
      tailf:info "DWDM controller(s)";
      tailf:cli-allow-join-with-key;
      key id;
      leaf id {
        type string {
          tailf:info "dwdm Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      leaf proactive {
        tailf:info "Enable Proactive Protection Feature";
        tailf:cli-full-command;
        type empty;
      }
      container proactive-conf {
        tailf:cli-drop-node-name;
        container proactive {
          tailf:info "Enable Proactive Protection Feature";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container revert {
            tailf:info "Configure Revert thresholds";
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>;;Bit error rate coefficient (x of xE-y) (Revert threshold cannot be > 1E-3";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<3-10>;;Bit error rate power (y of xE-y) (Revert threshold cannot be > 1E-3)";
                  range "3..10";
                }
              }
            }
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<500-100000>;;Integration window for FRR revert in MS";
                range "500..100000";
              }
            }
          }
          container trigger {
            tailf:info "Configure trigger threshold";
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>  Bit error rate coefficient (x of xE-y) (Trigger threshold cannot be > 1E-2)";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<2-9>;;Bit error rate power (y of xE-y) (Trigger threshold cannot be > 1E-3)";
                  range "2..9";
                }
              }
            }
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<10-10000>;;Integration window for FRR trigger in MS";
                range "10..10000";
              }
            }
          }
        }
      }
      container g709 {
        tailf:info "Configure G709 parameters";
        leaf enable {
          tailf:info "Enable G709 function";
          tailf:cli-full-command;
          type empty;
        }
        container fec {
          tailf:info "Configure FEC mode";
          choice fec-choice {
            leaf ci-bch {
              tailf:info "Continuously Interleaved BCH FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf enhanced {
              tailf:info "Enhanced FEC mode";
              type enumeration {
                enum "i.4" {
                  tailf:info "efec i.4";
                }
                enum "i.7" {
                  tailf:info "efec i.7";
                }
              }
            }
            leaf high-gain-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf high-gain-multivendor-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC) Multivendor Interoperable";
              type empty;
            }
            leaf high-gain-sd-fec {
              tailf:info "7% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf long-haul-hd-fec {
              tailf:info "20% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf long-haul-sd-fec {
              tailf:info "20% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf standard {
              tailf:info "Standard FEC mode";
              type empty;
            }
          }
        }
        leaf framing {
          tailf:info "Configure Framing mode";
          type enumeration {
            enum opu1e {
              tailf:info "opu1e framing mode";
            }
            enum opu2e {
              tailf:info "opu2e framing mode";
            }
          }
        }
        container odu {
          tailf:info "Configure ODU parameters";
          container overhead {
            tailf:info "Configure ODU overhead";
            container tti {
              tailf:info "Configure ODU Trail Trace Identifier buffer";
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
        }
        container otu {
          tailf:info "Configure OTU parameters";
          container overhead {
            tailf:info "Configure OTU overhead";
            container tti {
              tailf:info "Configure OTU Trail Trace Identifier buffer";
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
          container threshold {
            tailf:info "Configure OTU threshold value";
            leaf sf-ber {
              tailf:info "Set Signal Failure BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n)";
                range "1..9";
              }
            }
          }
        }
        leaf tti-processing {
          tailf:info "Enable Trail Trace Identifier processing";
          tailf:cli-full-command;
          type empty;
        }
      }
      leaf loopback {
        tailf:info "Configure loopback mode";
        tailf:cli-full-command;
        type enumeration {
          enum internal {
            tailf:info "Select internal loopback mode";
          }
          enum line {
            tailf:info "Select line loopback mode";
          }
        }
      }
      container wavelength {
        tailf:info "Configure ITU Channel, Wavelength and Frequency";
        choice wave-length-choice {
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-89";
              range "1..100";
            }
          }
          leaf frequency {
            tailf:info "Configure Frequency and Map to ITU Channel";
            type uint16 {
              tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
              range "19115..19610";
            }
          }
        }
      }
      leaf admin-state {
        tailf:info "Configure the transport admin state of the controller";
        type enumeration {
          enum in-service {
            tailf:info "change the admin-state to In-service (IS)";
          }
          enum maintenance {
            tailf:info "change the admin-state to Out-of-service-Maintenance (OOS-MT)";
          }
          enum out-of-service {
            tailf:info "change the admin-state to Out-of-service (OOS)";
          }
          enum in-service-config-allowed {
            tailf:info "change the admin-state to In-service-config-allowed (IS-CFG)";
          }
        }
      }
      leaf transmit-power {
        tailf:info "Configure transponder transmit power ";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+10>;;Select power level (in units of 0.1dBm)";
          range "-190..10";
        }
      }
    }
  }

  grouping ncs_rpc_notif_controller-grouping {
    uses ncs_rpc_notif_controller-dwdm-grouping;
    list MgmtMultilink {
      tailf:info "Controller for the management of multilink interfacess";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-mgmtmultilink;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      list bundle {
        tailf:info "Configure a multilink bundle interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-999999999>;;Bundle Id";
          }
        }
      }
    }
    list T1 {
      tailf:info "T1 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-t1;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
        }
      }
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum esf {
            tailf:info "esf framing: default";
          }
          enum sf {
            tailf:info "sf framing mode";
          }
        }
      }
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
        }
      }
      container carrier-delay {
        tailf:info "Set the carrier delay on a T1/E1 controller";
        choice carrier-delay-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-60>;;Carrier Transitions delay in seconds";
              range "0..60";
            }
          }
          leaf msec {
            tailf:info "Set time in milliseconds";
            type uint16 {
              tailf:info "<0-1000>;;Carrier Transitions delay in milliseconds";
              range "0..1000";
            }
          }
        }
      }
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name config-t1-channel_group;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-23>;;channel group number";
            range "0..23";
          }
        }
        leaf speed {
          tailf:info "speed of the ds0 channel";
          tailf:cli-full-command;
          type enumeration {
            enum 56 {
              tailf:info "56 Kbits";
            }
            enum 64 {
              tailf:info "64 Kbits";
            }
          }
        }
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 24. (:) indicates individual timeslot and (-) represent range";
          }
        }
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
      container bert {
        tailf:info "Configure BERT parameters";
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum 0s {
              tailf:info "All 0's test pattern";
            }
            enum 1in8 {
              tailf:info "1 in 8 test pattern";
            }
            enum 1s {
              tailf:info "All 1's test pattern";
            }
            enum 2e11 {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum 2e15 {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum 2e20 {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum 2e20-QRSS {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum 2e23 {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum 2e9 {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum 3in24 {
              tailf:info "3 in 24 test pattern";
            }
            enum 55Daly {
              tailf:info "55 Daly test pattern";
            }
            enum 55Octet {
              tailf:info "55 Octect test pattern";
            }
            enum alt-0-1 {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      container loopback {
        tailf:info "Configure T1 loopback mode";
        leaf local {
          tailf:cli-full-command;
          tailf:info "Put near end in local loopback";
          type empty;
        }
        leaf network {
          tailf:info "Network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Put line network loopback";
            }
            enum payload {
              tailf:info "Put payload network loopback";
            }
          }
        }
        container remote {
          tailf:info "Remote loopback (put far end in loopback)";
          tailf:cli-compact-syntax;
          choice line-payload {
            container line {
              tailf:info "Put far end line loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum ansi {
                    tailf:info "loopback using ansi fdl";
                  }
                  enum bellcore {
                    tailf:info "loopback using Bellcore fdl (SmartJack loopback)";
                  }
                }
              }
              leaf inband {
                tailf:info "loopback using inband code";
                tailf:cli-full-command;
                type empty;
              }
            }
            container payload {
              tailf:info "Put far end payload loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum ansi {
                    tailf:info "loopback using ansi fdl";
                  }
                }
              }
            }
          }
        }
      }
    }
    list T3 {
      tailf:info "T3 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-t3;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }
      container dsu {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-t3-dsu;
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<75-44210>;;DSU subrate bandwidth range";
            range "75..44210";
          }
        }
        leaf mode {
          tailf:info "Configure DSU mode";
          tailf:cli-full-command;
          type enumeration {
            enum adtran {
              tailf:info "Set DSU mode to Adtran";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
            enum larscom {
              tailf:info "Set DSU mode to Larscom";
            }
            enum verilink {
              tailf:info "Set DSU mode to Verilink";
            }
          }
        }
        leaf remote {
          tailf:info "Specify commands associated with the remote end";
          tailf:cli-full-command;
          type enumeration {
            enum disable {
              tailf:info "Deny incoming remote requests to reset bandwidth to fullrate";
            }
            enum fullrate {
              tailf:info "Request that the farend set its bandwidth to fullrate";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        type enumeration {
          enum auto-detect {
            tailf:info "Application Identification Channel Signal";
          }
          enum c-bit {
            tailf:info "C-bit framing (T3 default)";
          }
          enum m23 {
            tailf:info "M23 Framing Format";
          }
        }
      }
      container delay {
        leaf trigger {
          tailf:info "trigger time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-60000>;;time in msec to soak before declaring the alarm";
            range "0..60000";
          }
        }
      }
      leaf cablelength {
        tailf:info "Length of the T3/E3 cable in feet";
        type uint16 {
          tailf:info "<0-450>;;Length of the cable in feet";
          range "0..450";
        }
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
      container bert {
        tailf:info "Configure BERT parameters";
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum 0s {
              tailf:info "All 0's test pattern";
            }
            enum 1in8 {
              tailf:info "1 in 8 test pattern";
            }
            enum 1s {
              tailf:info "All 1's test pattern";
            }
            enum 2e11 {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum 2e15 {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum 2e20 {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum 2e20-QRSS {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum 2e23 {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum 2e9 {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum 3in24 {
              tailf:info "3 in 24 test pattern";
            }
            enum 55Daly {
              tailf:info "55 Daly test pattern";
            }
            enum 55Octet {
              tailf:info "55 Octect test pattern";
            }
            enum alt-0-1 {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      container loopback {
        tailf:info "Configure T3 loopback mode";
        leaf local {
          tailf:info "Put near end in local loopback";
          tailf:cli-full-command;
          type empty;
        }
        leaf network {
          tailf:info "Put near end in network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Put line network loopback";
            }
            enum payload {
              tailf:info "Put payload network loopback";
            }
          }
        }
        leaf remote {
          tailf:info "Remote loopback (put far end in loopback by sending FEAC)";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Remote line loopback";
            }
            enum payload {
              tailf:info "Remote payload loopback";
            }
          }
        }
      }
    }
    list E1 {
      tailf:info "E1 Port controller(s)";
      tailf:cli-mode-name config-e1;
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      container cem-group {
        tailf:info "Configure CEM interface on T1/E1";
        leaf unframed {
          tailf:info "Configure a unframed CEM interface on T1/E1";
          type empty;
        }
        list framed {
          tailf:info "Configure a framed CEM interface on T1/E1";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-30>;;CEM group number";
            }
          }
          leaf timeslots {
            tailf:info "List of timeslots in the CEM group";
            type string {
              tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. (:) indicates individual timeslot and (-) represent range";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum crc4 {
            tailf:info "E1 with CRC: default";
          }
          enum no-crc4 {
            tailf:info E1;
          }
          enum unframed {
            tailf:info unframed;
          }
        }
      }
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum hdb3 {
            tailf:info "high-density bipolar 3";
          }
        }
      }
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name config-e1-channel_group;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;channel group number";
            range "0..30";
          }
        }
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. (:) indicates individual timeslot and (-) represent range";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure t1e1 controller into down-when-looped mode";
        type empty;
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list E3 {
      tailf:info "E3 Port controller(s)";
      tailf:cli-mode-name config-e3;
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        tailf:cli-full-command;
        type enumeration {
          enum g751 {
            tailf:info "E3 Framing G.751 (E3 default)";
          }
          enum g832 {
            tailf:info "E3 Framing G.832";
          }
        }
      }
      container dsu {
        tailf:info "Configure T3/E3 subrate(dsu)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-e3-dsu;
        leaf mode {
          tailf:info "Configure DSU mode";
          type enumeration {
            enum cisco {
              tailf:info "Set DSU mode to Cisco";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
          }
        }
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          type uint16 {
            tailf:info "<300-34010>;;DSU subrate bandwidth range";
            range "300..34010";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure T3/E3 controller into down-when-looped mode";
        tailf:cli-full-command;
        type empty;
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list SONET {
      tailf:info "SONET/SDH Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-sonet;
      key id;
      leaf id {
        tailf:cli-case-insensitive;
        type string {
          tailf:info "WORD;;SONET Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses ncs_rpc_notif_description-grouping;
      leaf ais-shut {
        tailf:info "Enable sending SONET/SDH LAIS when shutdown";
        tailf:cli-full-command;
        type empty;
      }
      container line {
        tailf:info "Configure SONET/SDH line parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sonet-line;
        container delay {
          tailf:info "alarm soaking";
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }
      container path {
        tailf:info "Configure SONET/SDH path parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sonet-path;
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }
        }
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH PAIS when shutdown";
          type empty;
        }
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
        leaf scrambling {
          tailf:info "Configure SONET/SDH SPE scrambling";
          type enumeration {
            enum disable;
            enum enable;
          }
        }
        container threshold {
          tailf:info "Configure SONET/SDH path BER threshold values";
          leaf b3-tca {
            tailf:info "Set B3 BER Threshold Crossing Alert (TCA) threshold";
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure SONET/SDH framing";
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
            tailf:info "Select SDH framing";
          }
          enum sonet {
            tailf:info "Select SONET framing (default)";
          }
        }
      }
      container report {
        tailf:info "Configure SONET/SDH section/line alarm reporting";
        leaf lais {
          tailf:info "Set Line Alarm Indication Signal reporting status";
          type empty;
        }
        leaf sd-ber {
          tailf:info "Set LBIP BER in excess of SD threshold reporting status";
          type empty;
        }
      }
      container overhead {
        tailf:info "Configure SONET/SDH SOH/LOH byte/bit values";
        leaf j0 {
          tailf:info "Specify STS identifier (J0/C1) byte";
          type uint8 {
            tailf:info "<0-255>;;J0/C1 byte value (default 0x01)";
            range "0..255";
          }
        }
        leaf s1s0 {
          tailf:info "Specify bits s1 and s0 of H1 byte";
          type uint8 {
            tailf:info "<0-3>;;s1 & s0 bits value (default 0x0)";
            range "0..3";
          }
        }
      }
      list sts {
        tailf:info "Configure SONET path parameters";
        tailf:cli-mode-name config-stsPath;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-48>;;Possible range is 1-3 for OC3, 1-12 for OC12.";
          }
        }
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural sts boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }
        container mode {
          tailf:info "Configure mode for the path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum pos {
                tailf:info "Configure pos mode for the path";
              }
              enum t3 {
                tailf:info "sonet path carrying T3";
              }
              enum vt15 {
                tailf:info "sonet path carrying VT15";
              }
              enum vt15-t1 {
                tailf:info "sonet path carrying VT15 T1";
              }
              enum vt2 {
                tailf:info "sonet path carrying VT2";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'" {
              tailf:xpath-root 3;
            }
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }
      container threshold {
        tailf:info "Configure SONET/SDH section/line BER threshold values";
        leaf sf-ber {
          tailf:info "Set Signal Fail BER threshold";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
            range "3..9";
          }
        }
        leaf b1-tca {
          tailf:info "Set B1 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure SONET/SDH controller into down-when-looped mode";
        type empty;
      }
      list au {
        tailf:info "Configure SDH path parameters";
        tailf:cli-mode-name config-auPath;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-48>;;au3 or au4 path range";
            range "1..48";
          }
        }
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural au boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }
        container mode {
          tailf:info "Configure mode for the au path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum c11 {
                tailf:info "au3 path carrying c11";
              }
              enum c11-t1 {
                tailf:info "au3 path carrying c11 t1";
              }
              enum c12 {
                tailf:info "au3 path carrying c12";
              }
              enum c12-e1 {
                tailf:info "au3 path carrying c12 e1";
              }
              enum e3 {
                tailf:info "au3 path carrying E3";
              }
              enum pos {
                tailf:info "Configure pos mode for au path";
              }
              enum t3 {
                tailf:info "au3 path carrying T3";
              }
              enum tug3 {
                tailf:info "au4 path carries TUG3";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'" {
              tailf:xpath-root 3;
            }
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }
        list tug3 {
          tailf:info "Configure tug3 path parameters";
          tailf:cli-mode-name config-tug3Path;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug3 number range";
              range "1..3";
            }
          }
          container mode {
            tailf:info "Configure mode for the tug3 path";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf carrying {
              tailf:cli-drop-node-name;
              type enumeration {
                enum c11 {
                  tailf:info "tug3 path carrying TU-11";
                }
                enum c11-t1 {
                  tailf:info "tug3 path carrying TU-11 to t1";
                }
                enum c12 {
                  tailf:info "tug3 path carrying TU-12";
                }
                enum c12-e1 {
                  tailf:info "tug3 path carrying TU-12 to e1";
                }
                enum e3 {
                  tailf:info "au3 or all tug3 path carrying E3";
                }
                enum t3 {
                  tailf:info "au3 or all tug3 path carrying T3";
                }
              }
            }
          }
        }
      }
      container clock {
        tailf:info "Configure SONET/SDH port clock";
        leaf source {
          tailf:info "Configure SONET/SDH port TX clock source";
          type enumeration {
            enum internal {
              tailf:info "Select internal clock";
            }
            enum line {
              tailf:info "Select clock recovered from line (default)";
            }
          }
        }
      }
      container s1byte {
        tailf:info "Configure SONET/SDH controller to s1byte ignore mode";
        leaf ignore {
          tailf:info "Ignore S1 byte";
          type empty;
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list wanphy {
      tailf:info "WANPHY controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-wanphy;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container lanmode {
        tailf:info "Configure Lan Mode On/Off";
        leaf on {
          tailf:info "Turn LanMode On";
          type empty;
        }
      }
      container wanmode {
        tailf:info "Configure Wan Mode On/Off";
        leaf on {
          tailf:info "Turn WanMode On";
          type empty;
        }
      }
    }
  }

  grouping ncs_rpc_notif_set-list-grouping {
    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key value;
      leaf value {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value end-set|abort|exit;
        type string {
          tailf:info "WORD;;extcommunity-set line";
          pattern ".*[^,]";
        }
      }
    }
  }

  grouping ncs_rpc_notif_ipsla-reaction-operation-react-grouping {
    container action {
      tailf:info "Type of action to be taken on threshold violation(s)";
      leaf logging {
        tailf:info "Generate a syslog alarm on threshold violation";
        type empty;
      }
      leaf trigger {
        tailf:info "Generate trigger to active reaction triggered operation(s)";
        type empty;
      }
    }
    container threshold {
      tailf:info "Configure threshold parameters on monitored element";
      container type {
        tailf:info "Threshold type";
        choice type-choice {
          leaf immediate {
            tailf:info "Take action immediately upon threshold violation";
            type empty;
          }
          leaf consecutive {
            tailf:info "Take action after a number of consecutive violations";
            type uint8 {
              tailf:info "<1-16>;;Number of consecutive violations";
              range "1..16";
            }
          }
          leaf average {
            tailf:info "Take action on average values violate threshold";
            type uint8 {
              tailf:info "<1-16>;;Number of probes to average over";
              range "1..16";
            }
          }
        }
      }
      container limit {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-limit {
          tailf:info "Threshold lower limit";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold lower limit value";
            range "1..4294967295";
          }
        }
        leaf upper-limit {
          tailf:info "Threshold upper limit";
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold upper limit value";
            range "1..4294967295";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_interface-tunnel-te-auto-bw-threshold-grouping {
    container threshold {
      tailf:info "Set the bandwidth change percent to trigger an underflow/overflow";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf percentage {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Bandwidth change percent to trigger an overflow";
          range "1..100";
        }
      }
      leaf min {
        tailf:info "Set the bandwidth change value to trigger an overflow";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<10-4294967295>;;Bandwidth change value to trigger an overflow (kbps)";
          range "10..4294967295";
        }
      }
      leaf limit {
        tailf:info "Set the number of consecutive collections exceeding threshold";
        type uint8 {
          tailf:info "<1-10>;;Number of consecutive collections exceeding threshold";
          range "1..10";
        }
      }
    }
  }

  grouping ncs_rpc_notif_router-ospf-domain-id-grouping {
    leaf type {
      tailf:info "OSPF domain ID type in Hex format";
      tailf:cli-incomplete-command;
      type enumeration {
        enum 0005 {
          tailf:info "Type 0x0005";
        }
        enum 0105 {
          tailf:info "Type 0x0105";
        }
        enum 0205 {
          tailf:info "Type 0x0205";
        }
        enum 8005 {
          tailf:info "Type 0x8005";
        }
      }
    }
    leaf value {
      tailf:info "OSPF domain ID value in Hex format";
      type string {
        tailf:info "WORD;;OSPF domain ID ext. community value in Hex (6 octets)";
      }
    }
  }

  grouping ncs_rpc_notif_explicit-path-index-list-grouping {
    list index {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key index-id;
      leaf index-id {
        type uint16 {
          tailf:info "<1-65535>;;Index number";
          range "1..65535";
        }
      }
      leaf keyword {
        tailf:cli-drop-node-name;
        type enumeration {
          enum exclude-address {
            tailf:info "Specify the next address to be excluded ";
          }
          enum exclude-srlg {
            tailf:info "Specify an IP Addr to get SRLGs from for exclusion";
          }
          enum next-address {
            tailf:info "Specify the next (adjacent) address in the path";
          }
          enum next-label {
            tailf:info "Specify the next (adjacent) address in the path";
          }
        }
      }
      leaf hop-type {
        when "../keyword = 'next-address'" {
          tailf:xpath-root 3;
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type enumeration {
          enum loose {
            tailf:info "Specify the next address in the path as a loose hop";
          }
          enum strict {
            tailf:info "Specify the next address in the path as a strict hop";
          }
        }
      }
      leaf label {
        when "../keyword = 'next-label'" {
          tailf:xpath-root 3;
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type uint32;
      }
      container ipv4 {
        tailf:info "Specify the address AFI";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf unicast {
          tailf:info "Specify the address SAFI";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter IP address (A.B.C.D)";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_route-target-import-export-grouping {
    container route-target {
      tailf:info "Route Target";
      list route-target-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Two or Four Byte AS number or IP:nn";
          }
        }
      }
      leaf-list import {
        tailf:info "Import Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
      leaf-list export {
        tailf:info "Export Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
    }
  }

  grouping ncs_rpc_notif_username-grouping {
    list username {
      tailf:info "Configure user name";
      tailf:cli-mode-name config-un;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;User name";
        }
      }
      list group {
        tailf:info "User group in which this user will be a member of";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 7 {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf privilege {
        tailf:info "Set user privilege level";
        type uint8 {
          tailf:info "<0-15>;;User privilege level";
          range "0..15";
        }
      }
      container secret {
        tailf:info "Specify the secure password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 5 {
              tailf:info "Specifies that an encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The user password string";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_clock-grouping {
    container clock {
      tailf:info "Configure time-of-day clock";
      tailf:cli-explicit-exit;
      leaf calendar-valid {
        tailf:info "Calendar time is authoritative";
        type empty;
      }
      container summer-time {
        tailf:info "Configure summer (daylight savings) time";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;name of time zone in summer";
          }
        }
        choice summer {
          case a {
            container date {
              tailf:info "Configure absolute summer time";
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to start";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                pattern [0-9][0-9]:[0-9][0-9];
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to end";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf end-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf end-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf end-time {
              tailf:cli-drop-node-name;
              type string {
                pattern [0-9][0-9]:[0-9][0-9];
              }
            }
          }
        }
      }
      container timezone {
        tailf:info "Configure time zone";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;name of time zone";
          }
        }
        leaf hours-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<-23 - 23>;;Hours offset from UTC";
            range "-23..23";
          }
        }
        leaf minutes-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<0-59>;;Minutes offset from UTC";
            range "0..59";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_exception-grouping {
    container exception {
      tailf:info "Coredump configuration commands";
      tailf:cli-explicit-exit;
      container exception-filepath {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf choice {
          tailf:info "Preference for the following dump location";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-3>;;Order of preference";
            range "1..3";
          }
        }
        leaf compress {
          tailf:info "Compress the dump files";
          tailf:cli-incomplete-command;
          type enumeration {
            enum off {
              tailf:info "Do not compress core files dumped on this path";
            }
            enum on {
              tailf:info "Compress core files dumped on this path";
            }
          }
        }
        container filename {
          tailf:info "Dump file name";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Filename";
            }
          }
          leaf limit {
            tailf:cli-drop-node-name;
            type string {
              tailf:info lowlimit-highlimit;
            }
          }
        }
        leaf filepath {
          tailf:info "Give the dump location next";
          type string {
            tailf:info "WORD;;Protocol and directory";
          }
        }
      }
      leaf sparse {
        tailf:info "control sparse core dump";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable sparse core dump";
          }
          enum on {
            tailf:info "Enable sparse core dump by default";
          }
        }
      }
      leaf sprsize {
        tailf:info "Switch to sparse core dump at this size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
          range "1..4095";
        }
      }
      leaf coresize {
        tailf:info "Only print out stack trace and create no core file beyond this size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4095>;;Core file size max limit in MB";
          range "1..4095";
        }
      }
      leaf pakmem {
        tailf:info "control pakmem in core";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable dump of packet memory by default";
          }
          enum on {
            tailf:info "Dump packet memory for all process";
          }
        }
      }
    }
  }

  grouping ncs_rpc_notif_average-cpu-used-grouping {
    leaf op {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type operator-type;
    }
    leaf threshold {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-100>;;Threshold value";
        range "0..100";
      }
    }
    leaf percent {
      tailf:info "Specify that threshold value is percent of previous sample";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    container rearm {
      tailf:info "Specify Rearm parameters (default - always)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      choice rearm-choice {
        leaf toggle {
          tailf:info "Rearm after the first period when condition is not met";
          type empty;
        }
        leaf window {
          tailf:info "Rearm after the window of sampling periods";
          type uint8 {
            tailf:info "<1-100>;;Rearm window size";
            range "1..100";
          }
        }
      }
    }
  }

  grouping description-grouping {
    leaf description {
      tailf:info "Description text";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description";
      }
    }
  }

  grouping banner-grouping {
    leaf start-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;delimitting start character";
        length 1;
      }
    }
    leaf message {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      type string {
        tailf:info "WORD;;quoted banner message";
      }
    }
    leaf end-marker {
      tailf:cli-drop-node-name;
      tailf:cli-no-value-on-delete;
      must "../end-marker = ../start-marker" {
        tailf:xpath-root 3;
        tailf:dependency "../start-marker";
        tailf:dependency "../end-marker";
      }
      type string {
        tailf:info "WORD;;delimitting end character";
        length 1;
      }
    }
  }

  grouping vrf-route-target-grouping {
    list address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key name;
      leaf name {
        type string {
          tailf:info
            "<1-65535>:<0-4294967295>;;ASN2:index
             <65536-4294967295>:<0-65535>;;ASN4:index
             <IP address>:<0-65535>;;IPAddress:index (hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
    }
    list stitching-address-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      key name;
      leaf name {
        type string {
          tailf:info
            "<1-65535>:<0-4294967295>;;ASN2:index
             <65536-4294967295>:<0-65535>;;ASN4:index
             <IP address>:<0-65535>;;IPAddress:index (hex or decimal format)";
          pattern "[0-9]+.*";
        }
      }
      leaf stitching {
        tailf:info "These are stitching RTs";
        type empty;
      }
    }
  }

  grouping router-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
          tailf:xpath-root 3;
        }
      }
    }
  }

  grouping router-ospf-af-redistribute-grouping {
    leaf metric {
      tailf:info "Metric for redistributed routes";
      type uint32 {
        tailf:info "<0-4294967295>;;Default metric";
      }
    }
    leaf tag {
      tailf:info "Set tag for routes redistributed into OSPF";
      type uint32 {
        tailf:info "<0-4294967295>;;32-bit tag value";
      }
    }
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum 1 {
          tailf:info "Set OSPF External Type 1 metrics";
        }
        enum 2 {
          tailf:info "Set OSPF External Type 2 metrics";
        }
      }
    }
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
          tailf:xpath-root 3;
        }
      }
    }
  }

  grouping router-isis-af-redistribute-grouping {
    leaf level {
      tailf:cli-drop-node-name;
      type enumeration {
        enum level-1 {
          tailf:info "Redistribute routes into level 1 only";
        }
        enum level-1-2 {
          tailf:info "Redistribute routes into both levels";
        }
        enum level-2 {
          tailf:info "Redistribute routes into level 2 only (the default)";
        }
      }
    }
    uses router-af-redistribute-grouping;
    leaf metric-type {
      tailf:info "Metric type for redistributed routes";
      type enumeration {
        enum external {
          tailf:info "External metric type";
        }
        enum internal {
          tailf:info "Internal metric type";
        }
        enum rib-metric-as-external {
          tailf:info "External metric type and use RIB metric";
        }
        enum rib-metric-as-internal {
          tailf:info "Internal metric type and use RIB metric";
        }
      }
    }
  }

  grouping router-ospf-authentication-grouping {
    container authentication {
      tailf:info "Enable authentication";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      choice authentication-choice {
        container message-digest {
          tailf:info "Use message-digest authentication";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf keychain {
            tailf:info "Specify keychain name";
            type string {
              tailf:info "WORD;;The keychain name";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
                tailf:xpath-root 3;
              }
            }
          }
        }
        leaf null {
          tailf:info "Use no authentication";
          type empty;
        }
      }
    }
    list message-digest-key {
      tailf:info "Message digest authentication password (key)";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      key id;
      leaf id {
        tailf:info "Key ID";
        tailf:cli-suppress-range;
        type uint8 {
          tailf:info "<1-255>;;Key ID";
          range "1..255";
        }
      }
      container md5 {
        tailf:info "Use MD5 algorithm";
        tailf:cli-compact-syntax;
        choice md5-choice {
          leaf key {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf clear {
            tailf:info "Specifies an UNENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an ENCRYPTED password (key) will follow";
            type string {
              tailf:info "LINE;;The ENCRYPTED password (key)";
            }
          }
        }
      }
    }
  }

  grouping bfd-common-parameters-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf minimum-interval {
        tailf:info "Hello interval";
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "Prevent bfd settings from being inherited from the parent";
          type empty;
        }
      }
      leaf multiplier {
        tailf:info "Detect multiplier";
        type uint8 {
          tailf:info "<2-50>;;Detect multiplier";
          range "2..50";
        }
      }
    }
  }

  grouping router-ospf-common-area-grouping {
    leaf cost {
      tailf:info "Interface cost";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-65535>;;Cost";
        range "1..65535";
      }
    }
    container passive {
      tailf:info "Enable/Disable passive";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:info "Enable/Disable passive mode";
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable passive";
          }
          enum enable {
            tailf:info "Enable passive";
          }
        }
      }
    }
    leaf priority {
      tailf:info "Router priority";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Priority";
      }
    }
    container mtu-ignore {
      tailf:info "Enable/Disable ignoring of MTU in DBD packets";
      presence true;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      leaf mode {
        tailf:cli-drop-node-name;
        type enumeration {
          enum disable {
            tailf:info "Disable ignoring of MTU in DBD packets";
          }
          enum enable {
            tailf:info "Ignores the MTU in DBD packets";
          }
        }
      }
    }
    leaf dead-interval {
      tailf:info "Dead interval time";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
    container fast-reroute {
      tailf:info "IP Fast Reroute";
      choice per-link-or-prefix {
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }
        container per-link {
          tailf:info "Per-link Computation";
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          presence true;
          leaf enable {
            type empty;
          }
        }
        leaf per-prefix {
          tailf:info "Per-prefix Computation";
          type empty;
        }
      }
      container per-prefix-conf {
        tailf:cli-drop-node-name;
        container per-prefix {
          tailf:info "Per-prefix Computation";
          tailf:cli-incomplete-no;
          tailf:cli-incomplete-command;
          container remote-lfa {
            tailf:info "Remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              leaf mpls-ldp {
                tailf:info "MPLS LDP tunnel";
                type empty;
              }
            }
          }
        }
      }
    }
    leaf hello-interval {
      tailf:info "Time between HELLO packets";
      type uint16 {
        tailf:info "<1-65535>;;Seconds";
      }
    }
  }

  grouping router-ospf-area-grouping {
    uses bfd-common-parameters-grouping;
    uses router-ospf-common-area-grouping;
    uses router-ospf-authentication-grouping;
    leaf network {
      tailf:info "Network type";
      tailf:cli-full-command;
      type enumeration {
        enum broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
        }
        enum non-broadcast {
          tailf:info "Specify OSPF NBMA network";
        }
        enum point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
        }
        enum point-to-point {
          tailf:info "Specify OSPF point-to-point network";
        }
      }
    }
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        container sync {
          tailf:info "Enable LDP IGP synchronization on interfaces";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync";
            type empty;
          }
        }
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          tailf:cli-full-command;
          type empty;
        }
        container sync-igp-shortcuts {
          tailf:info "LDP sync for igp-shortcut tunnels";
          presence true;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          leaf disable {
            tailf:info "Disable MPLS LDP sync igp-shortcuts";
            type empty;
          }
        }
      }
      leaf traffic-eng {
        tailf:info "Configure an ospf area to run MPLS Traffic Engineering";
        type empty;
      }
    }
    container prefix-sid {
      tailf:info "Prefix SID Configuration";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      choice prefix-sid-choice {
        leaf absolute {
          tailf:info "SID value";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<16000-1048575>;;SID label";
            range "16000..1048575";
          }
        }
        leaf index {
          tailf:info "SID Index";
          tailf:cli-reset-container;
          type uint32 {
            tailf:info "<0-1048575>;;SID Index";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Force penultimate hop to send explicit-null label";
        type empty;
      }
    }
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Neighbor address (name)";
        }
      }
      leaf priority {
        tailf:info "OSPF priority of non-broadcast neighbor";
        type uint8 {
          tailf:info "<0-255>;;Priority";
        }
      }
    }
    container nssa {
      tailf:info "Specify area as a NSSA area";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf no-redistribution {
        tailf:info "No redistribution into this NSSA area";
        type empty;
      }
      leaf default-information-originate {
        tailf:info "Originate Type 7 default into NSSA area";
        type empty;
      }
      leaf metric {
        tailf:info "OSPF default metric";
        when "../default-information-originate" {
          tailf:xpath-root 3;
        }
        type uint32 {
          tailf:info "<0-16777214>;;OSPF metric";
          range "0..16777214";
        }
      }
      leaf metric-type {
        tailf:info "OSPF metric type for default routes";
        when "../default-information-originate" {
          tailf:xpath-root 3;
        }
        type uint8 {
          tailf:info "<1-2>;;Link State metric type";
          range "1..2";
        }
      }
      leaf no-summary {
        tailf:info "Do not send summary LSA into NSSA";
        type empty;
      }
    }
  }

  grouping router-ospfvx-common-pre-grouping {
    leaf nsr {
      tailf:info "Enable NSR for all VRFs in this process";
      tailf:cli-full-command;
      type empty;
    }
    leaf router-id {
      tailf:info "Specify the router-id for this OSPF process";
      tailf:cli-full-command;
      type inet:ipv4-address {
        tailf:info "A.B.C.D;;OSPF router-id in IPv4 address format";
      }
    }
    uses router-ospf-common-area-grouping;
    container log {
      tailf:info "Log ospf info";
      container adjacency {
        tailf:info "Log adjacency state info";
        container changes {
          tailf:info "Log changes";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf changes-state {
            tailf:info "Log all state changes or disable logging";
            tailf:cli-drop-node-name;
            type enumeration {
              enum detail {
                tailf:info "Log all state changes";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container throttle {
        tailf:info "OSPF throttle timers";
        container lsa {
          tailf:info "LSA throttle timers";
          container all {
            tailf:info "For all types of OSPF LSAs";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf delay {
              tailf:info "Delay to generate first occurrence of LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<0-600000>;;Delay to generate first occurrence of LSA in milliseconds";
                range "0..600000";
              }
            }
            leaf min-delay {
              tailf:info "Minimum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-600000>;;Minimum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
            leaf max-delay {
              tailf:info "Maximum delay between originating the same LSA in milliseconds";
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-600000>;;Maximum delay between originating the same LSA in milliseconds";
                range "1..600000";
              }
            }
          }
        }
        container spf {
          tailf:info "OSPF SPF throttle timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf delay {
            tailf:info "Delay between receiving a change to SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between receiving a change to SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf min-delay {
            tailf:info "Delay between first and second SPF calculation in milliseconds";
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<1-600000>;;Delay between first and second SPF calculation in milliseconds";
              range "1..600000";
            }
          }
          leaf max-delay {
            tailf:info "Maximum wait time in milliseconds for SPF calculations";
            tailf:cli-drop-node-name;
            type uint32 {
              tailf:info "<1-600000>;;Maximum wait time in milliseconds for SPF calculations";
              range "1..600000";
            }
          }
        }
      }
      container lsa {
        tailf:info "OSPF global LSA timers";
        leaf min-arrival {
          tailf:info "OSPF MinLSArrival timer";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-600000>;;The minimum interval in millisec between accepting the same LSA";
            range "0..600000";
          }
        }
      }
      container pacing {
        tailf:info "OSPF pacing timers";
        leaf flood {
          tailf:info "OSPF flood pacing timer";
          type uint8 {
            tailf:info "<5-100>;;Interval in msec to pace flooding on all interfaces";
            range "5..100";
          }
        }
      }
    }
    container auto-cost {
      tailf:info "Calculate OSPF interface cost according to bandwidth";
      tailf:cli-delete-when-empty;
      presence true;
      leaf reference-bandwidth {
        tailf:info "Specify reference bandwidth for OSPF cost computations";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967>;;The reference bandwidth in terms of Mbits per second";
          range "1..4294967";
        }
      }
    }
    container maximum {
      tailf:info "Set OSPF limits";
      leaf paths {
        tailf:info "Limit number of paths";
        type uint8 {
          tailf:info "<1-64>;;Maximum number of paths per route";
          range "1..64";
        }
      }
      leaf interfaces {
        tailf:info "Limit number of interfaces";
        type uint32 {
          tailf:info "<1-4294967295>;;Maximum number of interfaces";
        }
      }
      container redistributed-prefixes {
        tailf:info "Limit number of redistributed prefixes";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Maximum number of prefixes redistributed into OSPF";
          }
        }
        leaf threshold-value {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type uint8 {
            tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
            range "1..100";
          }
        }
        leaf warning-only {
          tailf:info "Only give warning messsage when limit is exceeded";
          type empty;
        }
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-full-command;
        type empty;
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-30000>;;hello interval in milli-seconds";
          range "0..30000";
        }
      }
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-30>;;Detect multiplier";
        }
      }
    }
    container network {
      tailf:info "Network type";
      choice network-choice {
        leaf broadcast {
          tailf:info "Specify OSPF broadcast multi-access network";
          type empty;
        }
        leaf non-broadcast {
          tailf:info "Specify OSPF NBMA network";
          type empty;
        }
        container point-to-multipoint {
          tailf:info "Specify OSPF point-to-multipoint network";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf non-broadcast {
            tailf:info "Specify OSPF non-broadcast point-to-multipoint network";
            type empty;
          }
        }
        leaf point-to-point {
          tailf:info "Specify OSPF point-to-point network";
          type empty;
        }
      }
    }
    container domain-id {
      tailf:info "Specify domain id";
      container primary {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }
      container secondary {
        tailf:info "OSPF secondary domain-id";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses router-ospf-domain-id-grouping;
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        leaf always {
          tailf:info "Always advertise default route";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }
    container spf {
      tailf:info "SPF configuration";
      container prefix-priority {
        tailf:info "Configure SPF prefix priority route policy";
        leaf route-policy {
          tailf:info "Specify the route-policy to prioritize route install";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    container distance {
      tailf:info "Define an administrative distance";
      leaf weight {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Administrative distance";
          range "1..255";
        }
      }
      list distance-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key "ip-address wildcard-mask";
        leaf weight {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Administrative distance";
            range "1..255";
          }
        }
        leaf ip-address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Source address";
          }
        }
        leaf wildcard-mask {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Wild Card bits";
          }
        }
        leaf access-list-name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Access list";
          }
        }
      }
      container ospf {
        tailf:info "OSPF distance";
        container external {
          tailf:info "External type 5 and type 7 routes";
          leaf distance {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Distance for external type 5 and type 7 routes";
              range "1..255";
            }
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          tailf:info "AS number in 2-byte, 4-byte asdot and asplain";
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        leaf preserve-med {
          tailf:info "Preserve med of BGP routes";
          type empty;
        }
        uses router-ospf-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-ospf-af-redistribute-grouping;
      }
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:cli-drop-node-name;
          type enumeration {
            enum level-1 {
              tailf:info "Redistribute routes into level 1 only";
            }
            enum level-1-2 {
              tailf:info "Redistribute routes into both levels";
            }
            enum level-2 {
              tailf:info "Redistribute routes into level 2 only (the default)";
            }
          }
        }
        uses router-ospf-af-redistribute-grouping;
      }
    }
  }

  grouping router-ospfvx-common-post-grouping {
    list area {
      tailf:info "Enter the OSPF area configuration submode";
      tailf:cli-mode-name config-ospf-ar;
      key id;
      leaf id {
        tailf:info "Area id";
        tailf:cli-suppress-range;
        type ospf-area-type;
      }
      uses router-ospf-area-grouping;
      container stub {
        tailf:info "Specify the area as a stub area";
        tailf:cli-delete-when-empty;
        presence true;
        leaf no-summary {
          tailf:info "Do not send summary LSA into stub area";
          type empty;
        }
      }
      list multi-area-interface {
        tailf:info "Enable multi-area adjacency on this interface";
        tailf:cli-mode-name config-ospf-ar-mif;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }
      list interface {
        tailf:info "Enable routing on an interface";
        tailf:cli-mode-name config-ospf-ar-if;
        key name;
        leaf name {
          tailf:info "Interface Name";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        uses router-ospf-area-grouping;
      }
    }
  }

  grouping router-ospf-grouping {
    uses router-ospfvx-common-pre-grouping;
    list distribute-list {
      tailf:info "Filter networks in routing updates";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-remove-before-change;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Filter incoming routing updates";
          }
          enum out {
            tailf:info "Filter outgoing routing updates";
          }
        }
      }
      leaf route-policy {
        tailf:info "Route Policy to filter OSPF prefixes";
        tailf:cli-prefix-key;
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf access-list {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type string {
          tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    container distribute-list-proto {
      tailf:cli-drop-node-name;
      list distribute-list {
        tailf:info "Filter networks in routing updates";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        key direction;
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:cli-disallow-value out;
          type string {
            tailf:info "WORD;;Access-list name. disable-inheritance means use no access list";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf direction {
          type enumeration {
            enum out {
              tailf:info "Filter outgoing routing updates";
            }
          }
        }
        leaf connected {
          tailf:cli-break-sequence-commands;
          tailf:info Connected;
          type empty;
        }
        leaf static {
          tailf:info "Static routes";
          type empty;
        }
        leaf bgp {
          tailf:info "Border Gateway Protocol (BGP)";
          type union {
            type uint32 {
              tailf:info "<1-4294967295>;;Autonomous system number";
              range "1..4294967295";
            }
            type string {
              tailf:info "<1.0-XX.YY>;;Autonomous system number";
              pattern "[0-9]+\\.[0-9]+";
            }
          }
        }
        leaf ospf {
          tailf:info "Open Shortest Path First (OSPF)";
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
      }
    }
    uses router-ospfvx-common-post-grouping;
    container nsf {
      tailf:info "Enable Cisco Non Stop Forwarding";
      container ietf {
        tailf:info "Enable ietf graceful restart";
        tailf:cli-display-separated;
        presence true;
        container helper {
          tailf:info "router's helper support level";
          leaf disable {
            tailf:info "router's helper support disabled";
            type empty;
          }
        }
      }
      container cisco {
        tailf:info "Enable Cisco Non Stop Forwarding";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        container enforce {
          tailf:info "Cancel NSF restart when non-NSF-aware neighbors detected";
          leaf global {
            tailf:info "For the whole OSPF process";
            type empty;
          }
        }
      }
    }
    container queue {
      tailf:info "Adjust OSPF input queue";
      container limit {
        tailf:info "High watermark for incoming priority events";
        leaf low {
          tailf:info "High watermark for incoming low priority events (DBD/LSUpd/Req)";
          type uint16 {
            tailf:info "<1000-30000>;;DBD/LS Update/Req packets are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        leaf high {
          tailf:info "High watermark for incoming high priority events (hello)";
          type uint16 {
            tailf:info "<1000-30000>;;Hello events are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
        leaf medium {
          tailf:info "High watermark for incoming medium priority events (LSA ACK)";
          type uint16 {
            tailf:info "<1000-30000>;;LSA ACKs are dropped when incoming event queue exceeds this value";
            range "1000..30000";
          }
        }
      }
    }
    container ignore {
      tailf:info "Do not complain about specific event";
      container lsa {
        tailf:info "Do not complain upon receiving LSA of the specified type";
        leaf mospf {
          tailf:info "MOSPF Type 6 LSA";
          type empty;
        }
      }
    }
    container segment-routing {
      tailf:info "Segment Routing configuration";
      container global-block {
        tailf:info "MPLS label range for SID allocation";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }
      choice mpls-disable-choice {
        leaf mpls {
          tailf:info "SR using MPLS dataplane";
          type empty;
        }
        leaf disable {
          tailf:info "Disable Segment Routing";
          type empty;
        }
      }
      leaf forwarding {
        tailf:info "Enable Segment-routing forwarding on interfaces";
        type enumeration {
          enum disable {
            tailf:info "Disable advertising loopback as a stub network";
          }
          enum mpls {
            tailf:info "Use MPLS for Segment-routing forwarding";
          }
        }
      }
      container sr-prefer {
        tailf:info "Prefer segment routing labels over LDP labels";
        presence true;
        leaf prefix-list {
          tailf:info "Filter prefixes for which SR preference is applied";
          type string {
            tailf:info "WORD;;Prefix-list name";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/prefix-list/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      container prefix-sid-map {
        tailf:info "Configuring segment routing mapping server";
        container receive {
          tailf:info "Control the usage of remote mapping server advertisements";
          presence true;
          leaf disable {
            tailf:info "Disable the usage of remote mapping server advertisements";
            type empty;
          }
        }
        leaf advertise-local {
          tailf:info "Advertise and use local mapping server entries";
          type empty;
        }
      }
    }
    container address-family {
      tailf:info "OSPF address family";
      container ipv4 {
        tailf:info "IPV4 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
    container max-metric {
      tailf:info "Set maximum metric";
      container router-lsa {
        tailf:info "Maximum metric in self-originated router-LSAs";
        tailf:cli-compact-syntax;
        leaf on-startup {
          tailf:info "On startup";
          tailf:cli-optional-in-sequence;
          type union {
            type uint32 {
              tailf:info "<5-86400>;;Time in seconds to originate router-LSA with max-metric";
              range "5..86400";
            }
            type enumeration {
              enum wait-for-bgp {
                tailf:info "Let BGP decide when to originate router-LSA with normal metric";
              }
            }
          }
        }
        leaf include-stub {
          tailf:info "Set maximum metric for stub links in router-LSAs";
          type empty;
        }
        choice external-lsa-choice {
          container external-lsa-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf external-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in external-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf external-lsa {
            tailf:info "Override external-lsa metric with max-metric";
            type empty;
          }
        }
        choice summary-lsa-choice {
          container summary-lsa-container {
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf summary-lsa {
              type uint32 {
                tailf:info "<1-16777215>;;Overriding metric in summary-LSAs (default 16711680)";
                range "1..16777215";
              }
            }
          }
          leaf summary-lsa {
            tailf:info "Override summary-lsa metric with max-metric value";
            type empty;
          }
        }
      }
    }
  }

  grouping router-ospfv3-grouping {
    container graceful-restart {
      tailf:info "Enable Graceful-Restart";
      presence true;
    }
    uses router-ospfvx-common-pre-grouping;
    uses router-ospfvx-common-post-grouping;
    container address-family {
      tailf:info "OSPF address family";
      container ipv6 {
        tailf:info "IPV6 address family";
        tailf:cli-delete-when-empty;
        presence true;
        leaf unicast {
          tailf:info "unicast topology";
          type empty;
        }
      }
    }
  }

  grouping router-isis-common-af-grouping {
    leaf metric {
      tailf:info "Configure metric";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
          range "1..16777214";
        }
        type enumeration {
          enum maximum {
            tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
          }
        }
      }
    }
    container metric-level {
      tailf:cli-drop-node-name;
      list metric {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key level;
        leaf level {
          tailf:info "Set metric for one level only";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Set metric at this level only";
            range "1..2";
          }
        }
        leaf value {
          tailf:cli-prefix-key;
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric: <1-63> for narrow, <1-16777214> for wide";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum wide metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
      }
    }
    container fast-reroute {
      tailf:info "Configure Fast ReRoute";
      choice fast-reroute-choice {
        leaf disable {
          tailf:info "Disable IP Fast Reroute";
          type empty;
        }
        container per-prefix {
          tailf:info "Prefix dependent computation";
          tailf:cli-display-separated;
          presence true;
          leaf-list level {
            tailf:info "Configure FRR for one level only";
            tailf:cli-list-syntax;
            type uint8 {
              tailf:info "<1-2>;;Level";
              range "1..2";
            }
          }
          container remote-lfa {
            tailf:info "Enable remote LFA computation";
            container tunnel {
              tailf:info "Enable remote LFA computation using tunnels";
              container mpls-ldp {
                tailf:info "Use MPLS LDP tunnel to reach the remote LFA node";
                tailf:cli-display-separated;
                presence true;
              }
            }
          }
          container ti-lfa {
            tailf:info "Enable TI LFA computation";
            presence true;
          }
        }
      }
    }
    container mpls {
      tailf:info "Configure MPLS routing protocol parameters";
      container ldp {
        tailf:info "Configure LDP parameters";
        leaf auto-config {
          tailf:info "Enable LDP IGP interface auto-configuration";
          type empty;
        }
        container sync {
          tailf:info "Configure LDP ISIS synchronization";
          presence true;
          leaf level {
            type uint8 {
              tailf:info "<1-2>;;Set LDP synchronization at this level only";
              range "1..2";
            }
          }
        }
      }
      container traffic-eng {
        tailf:info "Routing protocol commands for MPLS Traffic Engineering";
        leaf level {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type enumeration {
            enum level-1 {
              tailf:info "Enable mpls traffic-eng at level 1";
            }
            enum level-1-2 {
              tailf:info "Enable mpls traffic-eng at both level 1 and 2";
            }
            enum level-2-only {
              tailf:info "Enable mpls traffic-eng at level 2";
            }
          }
        }
        container router-id {
          tailf:info "Traffic Engineering stable IP address for system";
          uses interface-name-grouping;
        }
        leaf multicast-intact {
          tailf:info "Install non-TE nexthops in the RIB for use by multicast";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
    container monitor-convergence {
      tailf:info "Enables convergence monitoring";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-isis-af-rcmd;
      tailf:cli-delete-when-empty;
      presence true;
      leaf track-ip-frr {
        tailf:info "Enables Tracking IP-Frr Convergence";
        type empty;
      }
    }
    leaf tag {
      tailf:info "Set interface tag";
      type uint32 {
        tailf:info "<1-4294967295>;;Interface tag";
      }
    }
  }

  grouping router-isis-af-grouping {
    container advertise {
      tailf:info "Control the advertisement of prefixes in LSPs";
      leaf passive-only {
        tailf:info "advertise prefixes of passive interfaces only";
        type empty;
      }
    }
    leaf ispf {
      tailf:info "Use incremental SPF (ISPF) to calculate network topology";
      type empty;
    }
    container ispf-conf {
      tailf:cli-drop-node-name;
      container ispf {
        tailf:info "Use incremental SPF (ISPF) to calculate network topology";
        tailf:cli-incomplete-command;
        tailf:cli-incomplete-no;
        leaf-list level {
          tailf:info "Enable ISPF for one level only";
          tailf:cli-list-syntax;
          type uint8 {
            tailf:info "<1-2>;;Enable ISPF for this level onl";
            range "1..2";
          }
        }
      }
    }
    container spf-interval {
      tailf:info "Route calculation scheduling parameters (FSPF, ISPF, PRC)";
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      leaf maximum-wait {
        tailf:info "Maximum delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf initial-wait {
        tailf:info "Initial delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
      leaf secondary-wait {
        tailf:info "Secondary delay before running a route calculation";
        type uint32 {
          tailf:info "<0-120000>;;Delay in milliseconds";
          range "0..120000";
        }
      }
    }
    leaf single-topology {
      tailf:info "Run IPv6 Unicast using the standard (IPv4 Unicast) topology";
      type empty;
    }
    container adjacency-check {
      tailf:info "Suppress checking of consistent AF support on received IIHs";
      leaf disable {
        tailf:info "Disable adjacency-checking";
        type empty;
      }
    }
    container spf {
      tailf:info "SPF configuration";
      list prefix-priority {
        tailf:info "Configure a prefix priority list";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key priority;
        leaf priority {
          type enumeration {
            enum critical {
              tailf:info "Specify critical priority prefixes";
            }
            enum high {
              tailf:info "Specify critical priority prefixes";
            }
            enum medium {
              tailf:info "Specify critical priority prefixes";
            }
          }
        }
        choice priority-type {
          leaf access-list {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Access-list name";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ethernet-services/access-list/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf tag {
            tailf:info "Specify a tag to indicate priority";
            type uint32 {
              tailf:info "<1-4294967295>;;The tag to indicate priority";
            }
          }
        }
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      container originate {
        tailf:info "Distribute a default route";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf external {
          tailf:info "Originate default prefix as an external route";
          type empty;
        }
        leaf route-policy {
          tailf:info "Route policy reference";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    leaf maximum-paths {
      tailf:info "Maximum number of active parallel paths per route";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<1-64>;;Number of paths";
        range "1..64";
      }
    }
    container propagate {
      tailf:info "Propagate routes between IS-IS levels";
      list level {
        tailf:info "Source level";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key "from level";
        leaf from {
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf into {
          tailf:info into;
          tailf:cli-prefix-key {
            tailf:cli-before-key 2;
          }
          type empty;
        }
        leaf level {
          tailf:info "Destination level";
          tailf:cli-expose-key-name;
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf route-policy {
          tailf:info "Propagate only specified routes";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    container microloop {
      tailf:info "Enable microloop protection feature";
      container avoidance {
        tailf:info "Enable local microloop avoidance";
        leaf rib-update-delay {
          tailf:info "Delay in milliseconds";
          type uint16 {
            tailf:info "<1000-65535>;;Set value of delay";
            range "1000..65535";
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static route";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-isis-af-redistribute-grouping;
      }
      list isis {
        tailf:info IS-IS;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "IS-IS instance identifier";
          }
        }
        uses router-isis-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum external {
              tailf:info "Redistribute OSPF external routes";
            }
            enum internal {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum nssa-external {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }
      list ospfv3 {
        tailf:info "Open Shortest Path First (OSPFv3)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF process ID";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type enumeration {
            enum external {
              tailf:info "Redistribute OSPF external routes";
            }
            enum internal {
              tailf:info "Redistribute OSPF internal routes";
            }
            enum nssa-external {
              tailf:info "Redistribute OSPF NSSA external routes";
            }
          }
        }
        uses router-isis-af-redistribute-grouping;
      }
    }
    container segment-routing {
      tailf:info "Enable Segment Routing Feature";
      container mpls {
        tailf:info "Enable Segment Routing Feature using MPLS encapsulation";
        presence true;
      }
      container prefix-sid-map {
        tailf:info "Enable prefix-sid-map";
        container receive {
          tailf:info "Use remote mapping server advertisements";
          presence true;
        }
        leaf advertise-local {
          tailf:info "Advertise active local prefix-SID mappings";
          type empty;
        }
      }
    }
  }

  grouping router-isis-common-grouping {
    leaf metric-style {
      tailf:info "Use old-style (ISO 10589) or new-style packet formats";
      tailf:cli-full-command;
      type enumeration {
        enum narrow {
          tailf:info "Use old style of TLVs with narrow metric";
        }
        enum transition {
          tailf:info "Send and accept both styles of TLVs during transition";
        }
        enum wide {
          tailf:info "Use new style of TLVs to carry wider metric";
        }
      }
    }
    container metric-style-list {
      tailf:cli-drop-node-name;
      list metric-style {
        tailf:info "Use old-style (ISO 10589) or new-style packet formats";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-sequence-commands;
        key level;
        leaf level {
          tailf:cli-expose-key-name;
          tailf:info "Set metric-style for one level only";
          type uint8 {
            tailf:info "<1-2>;;Level";
            range "1..2";
          }
        }
        leaf style {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum narrow {
              tailf:info "Use old style of TLVs with narrow metric";
            }
            enum transition {
              tailf:info "Send and accept both styles of TLVs during transition";
            }
            enum wide {
              tailf:info "Use new style of TLVs to carry wider metric";
            }
          }
        }
      }
    }
  }

  grouping router-isis-if-af-grouping {
    container prefix-sid {
      tailf:info "Specify the Prefix Segment ID";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice value-choice {
        leaf absolute {
          tailf:info "Specify the absolute value of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
        leaf index {
          tailf:info "Specify the index of Prefix Segement ID";
          type uint32 {
            tailf:info "<0-1048575>;;The Prefix Segment ID value";
            range "0..1048575";
          }
        }
      }
      leaf explicit-null {
        tailf:info "Upstream neighbor must replace prefix-sid with explicit null label";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf n-flag-clear {
        tailf:info "Clear N-flag for the prefix-SID ";
        type empty;
      }
    }
  }

  grouping vty-pool-grouping {
    leaf first-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;First VTY number";
      }
    }
    leaf last-vty {
      tailf:cli-drop-node-name;
      type uint16 {
        tailf:info "<5-99>;;Last VTY number";
      }
    }
    leaf line-template {
      tailf:info "Line template to configure VTYs";
      tailf:cli-optional-in-sequence;
      type string {
        tailf:info "WORD;;Name of line template";
      }
    }
  }

  grouping line-grouping {
    container flowcontrol {
      tailf:info "Configure flow control.";
      container hardware {
        tailf:info "Hardware flow control.";
        leaf direction {
          tailf:cli-drop-node-name;
          type enumeration {
            enum in {
              tailf:info "Inbound flow control.";
            }
            enum none {
              tailf:info "No flow control.";
            }
            enum out {
              tailf:info "Outbound flow control.";
            }
          }
        }
      }
    }
    leaf parity {
      tailf:info "Set the parity used.";
      type enumeration {
        enum even {
          tailf:info "Even parity.";
        }
        enum none {
          tailf:info "No parity.";
        }
        enum odd {
          tailf:info "Odd parity.";
        }
      }
    }
    leaf databits {
      tailf:info "Set the number of databits.";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<5-8>;;Number of databits the serial connection should use.";
      }
    }
    leaf stopbits {
      tailf:info "Set the stopbits used.";
      tailf:cli-full-command;
      type enumeration {
        enum 1 {
          tailf:info "One stopbit.";
        }
        enum 2 {
          tailf:info "Two stopbits.";
        }
      }
    }
    container access-class {
      tailf:info "Filter connections based on an IP access list";
      leaf egress {
        tailf:info "Filter outgoing connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
      leaf ingress {
        tailf:info "Filter incoming connections";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;IP access list name";
        }
      }
    }
    container secret {
      tailf:info "Provide a secure one way encrypted password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf type {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type enumeration {
          enum 0 {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum 5 {
            tailf:info "Specifies an ENCRYPTED secret will follow";
          }
        }
      }
      leaf secret {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
        }
      }
    }
    container password {
      tailf:info "Specify the password for the user";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf encryption {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 0 {
            tailf:info "Specifies that an UNENCRYPTED password will follow";
          }
          enum 7 {
            tailf:info "Specifies that an encrypted password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The UNENCRYPTED (cleartext) user password";
        }
      }
    }
    container users {
      tailf:info "Users characteristics";
      list group {
        tailf:info "Group to which the user will belong";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
    }
    container accounting {
      tailf:info "Accounting parameters";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default accounting list";
            }
          }
          type string {
            tailf:info "WORD;;Use an accounting list with this name";
          }
        }
      }
    }
    container authorization {
      tailf:info "Authorization parameters";
      leaf commands {
        tailf:info "For exec (shell) commands";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
      leaf exec {
        tailf:info "For starting an exec (shell)";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    container timeout {
      tailf:info "Timeouts for the line";
      container login {
        tailf:info "Timeouts related to the login sequence";
        leaf response {
          tailf:info "Timeouts for any user input during login sequence";
          type uint16 {
            tailf:info "<0-300>;;Timeout in seconds (default 30 seconds)";
            range "0..300";
          }
        }
      }
    }
    container timestamp {
      tailf:info "To enable timestamp printing before each command.";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf disable {
        tailf:info "To disable timestamp printing before each command.";
        type empty;
      }
    }
    container transport {
      tailf:info "Define transport protocols for line";
      leaf-list input {
        tailf:info "Define which protocols to use when connecting to the terminal server";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
          enum lat;
          enum pad {
            tailf:info "X.3 PAD";
          }
          enum udptn {
            tailf:info "UDPTN async via UDP protocol";
          }
          enum rlogin {
            tailf:info "Unix rlogin protocol";
          }
        }
      }
      leaf-list output {
        tailf:info "Define which protocols to use for outgoing connections";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        tailf:cli-no-value-on-delete;
        type enumeration {
          enum all {
            tailf:info "All protocols";
          }
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "TCP/IP SSH protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
      leaf preferred {
        tailf:info "Specify the preferred protocol to use";
        tailf:cli-full-command;
        type enumeration {
          enum none {
            tailf:info "No protocols";
          }
          enum ssh {
            tailf:info "Unix ssh protocol";
          }
          enum telnet {
            tailf:info "TCP/IP Telnet protocol";
          }
        }
      }
    }
    container exec-timeout {
      tailf:info "Set the EXEC timeout";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Timeout in minutes";
          range "0..35791";
        }
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-2147483>;;Timeout in seconds";
          range "0..2147483";
        }
      }
    }
    leaf length {
      tailf:info "Set number of lines on a screen.";
      type uint16 {
        tailf:info "<0-512>;;Number of lines on screen (0 for no pausing).";
        range "0..512";
      }
    }
    leaf width {
      tailf:info "Set width of the display terminal.";
      type uint16 {
        tailf:info "<0-512>;;Number of characters on a screen line.";
        range "0..512";
      }
    }
    container login {
      tailf:info "Enable password checking";
      leaf authentication {
        tailf:info "Authentication parameters";
        type union {
          type enumeration {
            enum default {
              tailf:info "Use the default authorization list";
            }
          }
          type string {
            tailf:info "WORD;;Use an authorization list with this name";
          }
        }
      }
    }
    leaf session-limit {
      tailf:info "Set the number of outgoing connections";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-20>;;Number of outgoing connections";
        range "0..20";
      }
    }
    leaf absolute-timeout {
      tailf:info "Set absolute timeout for line disconnection.";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-10000>;;Absolute timeout interval in minutes.";
        range "0..10000";
      }
    }
    container telnet {
      tailf:info "Telnet protocol-specific configuration";
      leaf transparent {
        tailf:info "Send a CR as a CR followed by a NULL instead of a CR followed by a LF";
        type empty;
      }
    }
    container session-timeout {
      tailf:info "Set interval for closing connection when there is no input traffic";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf minutes {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<0-35791>;;Session timeout interval in minutes";
          range "0..35791";
        }
      }
      leaf output {
        tailf:info "Include output traffic as well as input traffic";
        type empty;
      }
    }
    leaf escape-character {
      tailf:info "Change the current line template's escape character";
      type string {
        tailf:info "WORD;;Escape character or its ASCII decimal equivalent";
      }
    }
  }

  grouping lpts-grouping {
    list flow {
      tailf:info "lpts flow type";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      tailf:cli-incomplete-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;flow type";
        }
      }
      leaf ospf-type {
        when "../name = 'ospf'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum multicast {
            tailf:info Multicast;
          }
          enum unicast {
            tailf:info Unicast;
          }
        }
      }
      leaf ldp-type {
        when "../name = 'ldp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum tcp {
            tailf:info TCP;
          }
          enum udp {
            tailf:info UDP;
          }
        }
      }
      leaf rsvp-type {
        when "../name = 'rsvp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum udp {
            tailf:info UDP;
          }
        }
      }
      leaf raw-type {
        when "../name = 'raw'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum listen {
            tailf:info Listen;
          }
        }
      }
      leaf udp-tcp-type {
        when "../name = 'udp' or ../name = 'tcp'" {
          tailf:xpath-root 3;
          tailf:dependency "../name";
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum configured {
            tailf:info "Config peer";
          }
          enum listen {
            tailf:info Listen;
          }
        }
      }
      leaf icmp-type {
        when "../name = 'icmp'" {
          tailf:xpath-root 3;
        }
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum application {
            tailf:info "Specific application packets";
          }
          enum control {
            tailf:info "Control packets";
          }
          enum generic {
            tailf:info "Generic application packets";
          }
          enum local {
            tailf:info "Local interest packets";
          }
        }
      }
      leaf which {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        tailf:cli-incomplete-command;
        type enumeration {
          enum default {
            tailf:info Default;
          }
          enum known {
            tailf:info Known;
          }
        }
      }
      leaf rate {
        tailf:info "Rate in PPS";
        type uint32 {
          tailf:info "<0-4294967295>;;Packets Per Second";
        }
      }
    }
  }

  grouping class-random-detect-grouping {
    leaf min-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Minimum threshold";
        range "0..1073741823";
      }
    }
    leaf min-threshold-unit {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type police-burst-units-type;
    }
    leaf max-threshold {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type uint32 {
        tailf:info "<0-1073741823>;;Maximum threshold";
        range "0..1073741823";
      }
    }
    leaf max-threshold-unit {
      tailf:cli-drop-node-name;
      type police-burst-units-type;
    }
  }

  grouping class-map-match-grouping {
    container access-group {
      tailf:info "Match access group";
      leaf ipv4 {
        tailf:info "IPv4 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf ipv6 {
        tailf:info "IPv6 access list";
        tailf:cli-remove-before-change;
        type string {
          tailf:info "WORD;;Access list name - maximum 32 characters";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv6/access-list/named-acl/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    leaf any {
      tailf:info "Any packets";
      type empty;
    }
    container cos {
      tailf:info "Match based on IEEE 802.1Q/ISL Class Of Service value";
      leaf-list cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf-list inner {
        tailf:info "Match inner cos values (Upto 8 values)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    container destination-address {
      tailf:info "Match based on destination address";
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
    leaf-list destination-port {
      tailf:info "Match based on destination port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }
    leaf-list discard-class {
      tailf:info "Match based on discard class (upto 8 Ids)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-7>;;Discard Class Id";
        range "0..7";
      }
    }
    container dscp {
      tailf:info "Match based on IP DSCP value (upto 8 values or ranges)";
      leaf-list dscp-list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      leaf-list ipv4 {
        tailf:info "IPV4 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
      leaf-list ipv6 {
        tailf:info "IPV6 DSCP";
        tailf:cli-flat-list-syntax;
        tailf:cli-full-command;
        ordered-by user;
        type dscp-type;
      }
    }
    container fr-de {
      tailf:info "Match on Frame-relay DE bit";
      tailf:cli-delete-when-empty;
      tailf:cli-reset-container;
      presence true;
      leaf fr-de-value {
        tailf:cli-drop-node-name;
        type enumeration {
          enum 1 {
            tailf:info "<1-1>;;FR DE value";
          }
        }
      }
    }
    container frame-relay {
      tailf:info "Match based on frame-relay specific criteria";
      leaf-list dlci {
        tailf:info "Match frame-relay dlci value(s)";
        tailf:cli-flat-list-syntax;
        type uint16 {
          tailf:info "<16-1007>;;DLCI number";
          range "16..1007";
        }
      }
    }
    container mpls {
      tailf:info "Match based on MPLS specific values";
      container experimental {
        tailf:info "Match MPLS experimental values";
        leaf-list topmost {
          tailf:info "Match topmost label (Upto 8 values)";
          tailf:cli-flat-list-syntax;
          type uint8 {
            tailf:info "<0-7>;;MPLS experimental topmost label";
            range "0..7";
          }
        }
      }
    }
    container packet {
      tailf:info "Layer 3 Packet length";
      leaf-list length {
        tailf:info "Layer 3 Packet length";
        tailf:cli-flat-list-syntax;
        type string {
          tailf:info "<0-65535>;;IP packet length, value or range x-y";
        }
      }
    }
    container precedence {
      tailf:info "Match based on IP precedence values";
      leaf-list ipv4 {
        tailf:info "IPV4 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      leaf-list ipv6 {
        tailf:info "IPV6 precedence";
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
      leaf-list list {
        tailf:cli-drop-node-name;
        tailf:cli-flat-list-syntax;
        type precedence-type;
      }
    }
    leaf-list protocol {
      tailf:info "Match based on L3 protocol (Upto 8 values or ranges)";
      tailf:cli-flat-list-syntax;
      max-elements 8;
      type union {
        type uint8 {
          tailf:info "<0-255>;;An IP Protocol Number";
        }
        type string {
          tailf:info "<0-255>-<0-255>;;Lower-Upper limit of protocol range to match";
          pattern "[0-9]+\\-[0-9]+";
        }
        type enumeration {
          enum ahp {
            tailf:info "Authentication Header Protocol";
            value 51;
          }
          enum eigrp {
            tailf:info "Cisco's EIGRP Routing Protocol";
            value 88;
          }
          enum esp {
            tailf:info "Encapsulation Security Payload";
            value 50;
          }
          enum gre {
            tailf:info "Cisco's GRE Tunneling";
            value 47;
          }
          enum icmp {
            tailf:info "Internet Control Message Protocol";
            value 1;
          }
          enum igmp {
            tailf:info "Internet Gateway Message Protocol";
            value 2;
          }
          enum igrp {
            tailf:info "Cisco's IGRP Routing Protocol";
            value 9;
          }
          enum ipinip {
            tailf:info "IP in IP tunneling";
            value 1001;
          }
          enum ipv4 {
            tailf:info "Any IPv4 Protocol";
            value 0;
          }
          enum ipv6 {
            tailf:info "Any IPv6 Protocol";
            value 41;
          }
          enum ipv6icmp {
            tailf:info "IPV6Internet Control Message Protocol";
            value 58;
          }
          enum mpls {
            tailf:info "Any MPLS Packet";
            value 137;
          }
          enum nos {
            tailf:info "KA9Q NOS Compatible IP over IP Tunneling";
            value 94;
          }
          enum ospf {
            tailf:info "OSPF Routing Protocol";
            value 89;
          }
          enum pcp {
            tailf:info "Payload Compression Protocol";
            value 108;
          }
          enum pim {
            tailf:info "Protocol Independent Multicast";
            value 103;
          }
          enum sctp {
            tailf:info "Stream Control Transmission Protocol";
            value 132;
          }
          enum tcp {
            tailf:info "Transport Control Protocol";
            value 6;
          }
          enum udp {
            tailf:info "User Datagram Protocol";
            value 17;
          }
        }
      }
    }
    leaf-list qos-group {
      tailf:info "Match based on QoS Group (upto 8 Ids or ranges)";
      tailf:cli-flat-list-syntax;
      type uint16 {
        tailf:info "<0-63>;;Qos Group Id";
        range "0..63";
      }
    }
    container source-address {
      tailf:info "Match based on source address";
      list ipv4 {
        tailf:info "IPv4 address";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "address mask";
        leaf address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP Address";
          }
        }
        leaf mask {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP subnet mask";
          }
        }
      }
      leaf mac {
        tailf:info "MAC address";
        type string {
          tailf:info "H.H.H;;MAC Address to match";
        }
      }
    }
    leaf-list source-port {
      tailf:info "Match based on source port";
      tailf:cli-flat-list-syntax;
      type string {
        tailf:info "<0-65535>;;Port or range x-y";
      }
    }
    container vlan {
      tailf:info "Match based on Vlan Ids (Upto 8 values or ranges)";
      leaf-list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
      leaf-list inner {
        tailf:cli-range-list-syntax;
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4094>;;Vlan Id";
          range "1..4094";
        }
      }
    }
    container vpls {
      tailf:info "Match based on VPLS fields";
      leaf control {
        tailf:info "VPLS Control";
        tailf:cli-full-command;
        type empty;
      }
      leaf broadcast {
        tailf:info "VPLS Broadcast";
        tailf:cli-full-command;
        type empty;
      }
      leaf known {
        tailf:info "VPLS Known";
        type empty;
      }
      leaf multicast {
        tailf:info "VPLS Multicast";
        type empty;
      }
      leaf unknown {
        tailf:info "VPLS Unknown";
        type empty;
      }
    }
    leaf dei {
      tailf:info "Match based on DEI bit (0/1)";
      type uint8 {
        tailf:info "0-1;;DEI value";
        range "0..1";
      }
    }
  }

  grouping lsp-status-grouping {
    container lsp-status {
      tailf:info "Enable interface LSP state change alarms";
      leaf reoptimize {
        tailf:info "Enable interface LSP REOPT change alarms";
        type empty;
      }
      leaf state {
        tailf:info "Enable interface LSP UP/DOWN change alarms";
        type empty;
      }
      leaf reroute {
        tailf:info "Enable interface LSP REROUTE change alarms";
        type empty;
      }
      leaf insufficient-bandwidth {
        tailf:info "Enable Syslog for setup/reopt failure due to bandwidth";
        type empty;
      }
      leaf bw-change {
        tailf:info "Enable interface LSP BANDWIDTH change alarms";
        type empty;
      }
    }
  }

  grouping interface-ipv6-nd-prefix-list-grouping {
    choice prefix-choices {
      container prefix-lifetime {
        tailf:cli-drop-node-name;
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf valid-lifetime {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Valid Lifetime (secs)";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Valid Lifetime";
              }
            }
          }
        }
        leaf preferred-lifetime {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;Preferred Lifetime (secs) must be <= Valid Lifetime";
              range "0..4294967295";
            }
            type enumeration {
              enum infinite {
                tailf:info "Infinite Preferred Lifetime";
              }
            }
          }
        }
      }
      leaf no-adv {
        tailf:info "Do not advertise prefix";
        tailf:cli-full-command;
        type empty;
      }
      container options {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        leaf no-autoconfig {
          tailf:info "Do not use prefix for autoconfiguration";
          type empty;
        }
        leaf off-link {
          tailf:info "Do not use prefix for onlink determination";
          type empty;
        }
      }
    }
  }

  grouping interface-service-policy-content-grouping {
    container account {
      tailf:info "Turn off layer specific accounting";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-optional-in-sequence;
      choice account-choice {
        leaf nolayer2 {
          tailf:info "Turn off l2 accounting";
          type empty;
        }
        leaf user-defined {
          tailf:info "User defined accounting";
          type int8 {
            tailf:info "<-63,+63>;;Overhead accounting value";
            range "-63..63";
          }
        }
      }
    }
    leaf subscriber-parent {
      tailf:info "Configure an svlan policy";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    leaf resource-id {
      when "../subscriber-parent" {
        tailf:xpath-root 3;
      }
      tailf:info "Configure a resource-id";
      tailf:cli-optional-in-sequence;
      type uint8 {
        tailf:info "<0-3>;;resource-id value";
        range "0..3";
      }
    }
    leaf shared-policy-instance {
      tailf:info "Configure a shared-policy-instance";
      type string {
        tailf:info "WORD;;Name of the shared-policy-instance";
      }
    }
  }

  grouping interface-service-policy-grouping {
    container service-policy {
      tailf:info "Configure QoS Service Policy";
      container input {
        tailf:info "Configure a policy in the input direction";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
              tailf:xpath-root 3;
            }
          }
        }
        uses interface-service-policy-content-grouping;
      }
      container output {
        tailf:info "direction of service policy application";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:info "Name of the service policy";
          tailf:cli-drop-node-name;
          tailf:cli-remove-before-change;
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
              tailf:xpath-root 3;
            }
          }
        }
        uses interface-service-policy-content-grouping;
      }
      container type {
        tailf:info "Enter service policy type (default: qos)";
        container lan-queuing {
          tailf:info "Configure Lan Queuing Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
        }
        container performance-monitor {
          tailf:info "Configure media monitor service-policy type";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container test {
          tailf:info "Configure Test Policy Map";
          leaf input {
            tailf:info "Assign policy-map to the input of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf output {
            tailf:info "Assign policy-map to the output of an interface";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf inline {
            tailf:info "Configure inline Service Policy";
            type enumeration {
              enum input {
                tailf:info "Assign policy-map to the input of an interface";
              }
              enum output {
                tailf:info "Assign policy-map to the output of an interface";
              }
            }
          }
        }
        container pbr {
          tailf:info "Policy based routing Service policy";
          leaf input {
            tailf:info "Configure a policy in the input direction";
            type string {
              tailf:info "WORD;;Name of the service policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
        }
        container control {
          tailf:info "control policy";
          leaf subscriber {
            tailf:info "subscriber policy";
            type string {
              tailf:info "WORD;;Policy name";
            }
          }
        }
      }
    }
  }

  grouping interface-isis-grouping {
    container isis {
      tailf:info "IS-IS commands";
      container authentication {
        tailf:info "ISIS authentication for interface related PDUs";
        container mode {
          tailf:info "Authentication mode for PDUs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          leaf crypt {
            tailf:cli-drop-node-name;
            type enumeration {
              enum md5 {
                tailf:info "Keyed message digest";
              }
              enum text {
                tailf:info "Clear text password";
              }
            }
          }
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
        leaf key-chain {
          tailf:info "Authentication key-chain";
          type string;
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
              tailf:xpath-root 3;
            }
          }
        }
        container send-only {
          tailf:info "Authentication send only, receive ignore";
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf level {
            tailf:cli-drop-node-name;
            type enumeration {
              enum level-1 {
                tailf:info "ISIS authentication for level-1 PDUs";
              }
              enum level-2 {
                tailf:info "ISIS authentication for level-2 PDUs";
              }
            }
          }
        }
      }
      leaf circuit-type {
        tailf:info "Configure circuit type for interface";
        tailf:cli-reset-container;
        type enumeration {
          enum level-1 {
            tailf:info "Level-1 only adjacencies are formed";
          }
          enum level-1-2 {
            tailf:info "Level-1-2 adjacencies are formed";
          }
          enum level-2-only {
            tailf:info "Level-2 only adjacencies are formed";
          }
        }
      }
      container hello {
        tailf:info "Add padding to IS-IS hello packets";
        leaf padding {
          tailf:info "Pad hello packets";
          type empty;
        }
      }
      container metric {
        tailf:info "Configure the metric for interface";
        tailf:cli-reset-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf metric {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<1-16777214>;;Default metric";
              range "1..16777214";
            }
            type enumeration {
              enum maximum {
                tailf:info "Maximum metric. All routers will exclude this link from their SPF";
              }
            }
          }
        }
        leaf delay {
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Delay metric";
              range "1..16777214";
            }
          }
        }
        leaf expense {
          when "../delay != 'level-1' and ../delay != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Expense metric";
              range "1..16777214";
            }
          }
        }
        leaf error {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
            tailf:dependency "../expense";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
            type uint32 {
              tailf:info "<1-16777214>;;Error metric";
              range "1..16777214";
            }
          }
        }
        leaf rest {
          when "../delay != 'level-1' and ../delay != 'level-2' and ../expense != 'level-1' and ../expense != 'level-2'and ../error != 'level-1' and ../error != 'level-2'" {
            tailf:xpath-root 3;
            tailf:dependency "../delay";
            tailf:dependency "../expense";
            tailf:dependency "../error";
          }
          tailf:cli-drop-node-name;
          type union {
            type enumeration {
              enum level-1 {
                tailf:info "Apply metric to level-1 links";
              }
              enum level-2 {
                tailf:info "Apply metric to level-2 links";
              }
            }
          }
        }
      }
    }
  }

  grouping interface-switch-grouping {
    container channel-protocol {
      tailf:info "Select the channel protocol (LACP, PAgP)";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf number {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-512>;;Channel group number";
          range "1..512";
        }
      }
      leaf mode {
        tailf:info "Etherchannel Mode of the interface";
        type enumeration {
          enum active {
            tailf:info "Enable LACP unconditionally";
          }
          enum auto {
            tailf:info "Enable PAgP only if a PAgP device is detected";
          }
          enum desirable {
            tailf:info "Enable PAgP unconditionally";
          }
          enum on {
            tailf:info "Enable Etherchannel only";
          }
          enum passive {
            tailf:info "Enable LACP only if a LACP device is detected";
          }
        }
      }
    }
    container switch {
      tailf:info "Configure switch link";
      container virtual {
        tailf:info "Configure virtual switch values";
        leaf link {
          tailf:info "Configure virtual switch number";
          type uint8 {
            tailf:info "<1-2>;;core switch number";
            range "1..2";
          }
        }
      }
    }
    container switchport-conf {
      tailf:cli-drop-node-name;
      leaf switchport {
        tailf:info "Set switching mode characteristics";
        tailf:cli-boolean-no;
        type boolean;
      }
    }
    container switchport {
      tailf:info "Set switching mode characteristics";
      tailf:cli-incomplete-command;
      tailf:cli-incomplete-no;
      container access {
        tailf:info "Set access mode characteristics of the interface";
        leaf vlan {
          tailf:info "Set VLAN when interface is in access mode";
          type uint16 {
            tailf:info "<1-4094>;;VLAN ID of the VLAN when this port is in access mode";
            range "1..4094";
          }
        }
      }
      container block {
        tailf:info "Disable forwarding of unknown uni/multi cast addresses";
        leaf multicast {
          tailf:info "Block unknown multicast addresses";
          tailf:cli-full-command;
          type empty;
        }
        leaf unicast {
          tailf:cli-full-command;
          tailf:info "Block unknown unicast addresses";
          type empty;
        }
      }
      container mode {
        tailf:info "Set trunking mode of the interface";
        choice mode-choice {
          leaf access {
            tailf:info "Set trunking mode to ACCESS unconditionally";
            type empty;
          }
          leaf dot1q-tunnel {
            tailf:info "set trunking mode to TUNNEL unconditionally";
            type empty;
          }
          leaf dynamic {
            tailf:info "Set trunking mode to dynamically negotiate access or trunk mode";
            type enumeration {
              enum auto {
                tailf:info "Set trunking mode dynamic negotiation parameter to AUTO";
              }
              enum desirable {
                tailf:info "Set trunking mode dynamic negotiation parameter to DESIRABLE";
              }
            }
          }
          leaf trunk {
            tailf:info "Set trunking mode to TRUNK unconditionally";
            type empty;
          }
        }
      }
      leaf nonegotiate {
        tailf:info "Device will not engage in negotiation protocol on this interface";
        type empty;
      }
      container trunk {
        tailf:info "Set trunking characteristics of the interface";
        container allowed {
          tailf:info "Set allowed VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set allowed VLANs when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf all {
                tailf:info "all VLANs";
                type empty;
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
        container native {
          tailf:info "Set trunking native characteristics when interface is in trunking mode";
          leaf vlan {
            tailf:info "Set native VLAN when interface is in trunking mode";
            type union {
              type enumeration {
                enum tag {
                  tailf:info "Set native VLAN tagging state";
                }
              }
              type uint16 {
                tailf:info "<1-4094>;;VLAN ID of the native VLAN when this port is in trunking mode";
                range "1..4094";
              }
            }
          }
        }
        container pruning {
          tailf:info "Set pruning VLAN characteristics when interface is in trunking mode";
          container vlan {
            tailf:info "Set VLANs enabled for pruning when interface is in trunking mode";
            choice vlan-choice {
              leaf-list vlans {
                tailf:cli-range-list-syntax;
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf-list except {
                tailf:info "all VLANs except the following";
                tailf:cli-range-list-syntax;
                type uint16 {
                  tailf:info "WORD;;VLAN IDs of the allowed VLANs when this port is in trunking mode";
                }
              }
              leaf none {
                tailf:info "no VLANs";
                type empty;
              }
            }
          }
        }
      }
    }
    container spanning-tree {
      tailf:info "Spanning Tree Subsystem";
      leaf bpdufilter {
        tailf:info "Don't send or receive BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU filtering for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU filtering for this interface";
          }
        }
      }
      leaf bpduguard {
        tailf:info "Don't accept BPDUs on this interface";
        type enumeration {
          enum disable {
            tailf:info "Disable BPDU guard for this interface";
          }
          enum enable {
            tailf:info "Enable BPDU guard for this interface";
          }
        }
      }
      leaf guard {
        tailf:info "Change an interface's spanning tree guard mode";
        type enumeration {
          enum loop {
            tailf:info "Set guard mode to loop guard on interface";
          }
          enum none {
            tailf:info "Set guard mode to none";
          }
          enum root {
            tailf:info "Set guard mode to root guard on interface";
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
    }
  }

  grouping interface-bundle-grouping {
    container bundle {
      tailf:info "Bundle interface commands";
      leaf wait-while {
        tailf:info "Set the wait-while timeout for members of this bundle";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<0-2000>;;Wait-while timeout in milliseconds (default: 2000)";
          range "0..2000";
        }
      }
      container load-balancing {
        tailf:info "Load balancing commands on a bundle";
        leaf hash {
          tailf:info "Select the hash function used for traffic forwarded over the bundle";
          type enumeration {
            enum dst-ip {
              tailf:info "Use the destination IP as the hash function";
            }
            enum src-ip {
              tailf:info "Use the source IP as the hash function";
            }
          }
        }
        container localize {
          tailf:info "Restrict forwarding to members in the same rack where possible";
          container threshold {
            tailf:info "The threshold below which traffic is no longer localized";
            leaf links {
              tailf:info "Set a threshold of active member links per rack";
              type uint8 {
                tailf:info "<1-64>;;The number of links required on each rack to localize";
                range "1..64";
              }
            }
          }
        }
      }
      container maximum-active {
        tailf:info "Set a limit on the number of links that can be active";
        container links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
              range "1..64";
            }
          }
          leaf hot-standby {
            tailf:info "Hot-standby behaviour (non-standard, only effective on links with LACP enabled)";
            type empty;
          }
        }
      }
      container minimum-active {
        tailf:info "Set the minimum criteria for the bundle to be active";
        leaf links {
          tailf:info "Set the number of active links needed to bring up this bundle";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-64>;;Number of active links needed to bring up this bundle";
          }
        }
      }
    }
    container lacp {
      tailf:info "Bundle interface LACP commands";
      container switchover {
        tailf:info "Modify behavior for switching between links in this bundle";
        leaf suppress-flaps {
          tailf:info "Set the time for which to suppress flaps during a LACP switchover";
          type uint16 {
            tailf:info "<100-65535>;;The longest down flap which should be suppressed (milliseconds)";
            range "100..65535";
          }
        }
      }
    }
    container mlacp {
      tailf:info "Multi-chassis LACP per-interface commands";
      leaf iccp-group {
        tailf:info "ICCP redundancy group related commands for this bundle.";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;The ICCP redundancy group in which this bundle should operate.";
          range "1..4294967295";
        }
      }
      leaf port-priority {
        tailf:info "Set the priority for all member links on this device when running mLACP.";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Priority for member ports. Lower value is higher priority.";
          range "1..65535";
        }
      }
      container switchover {
        tailf:info "Set the parameters for performing a switchover to/from the mLACP peer";
        container maximize {
          tailf:info "Parameters for switchover behavior to maximize operational links/bandwidth";
          container links {
            tailf:info "Compare the number of operational links";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf threshold {
              tailf:info "Set the threshold below which to switch to the peer if it has more links available";
              type uint8 {
                tailf:info "<1-64>;;The number of links below which to switch to the peer if it has more links available";
                range "1..64";
              }
            }
          }
        }
        leaf recovery-delay {
          tailf:info "Specify delay before bundle becoming active after recovery from failure";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-65535>;;Recovery delay in seconds.";
          }
        }
        leaf type {
          tailf:info "Set the type of switchover operation to use";
          tailf:cli-full-command;
          type enumeration {
            enum brute-force {
              tailf:info "Force switchover by disabling all local member links";
            }
            enum revertive {
              tailf:info "Revert based on configured priority values";
            }
          }
        }
      }
    }
  }

  grouping interface-non-bundle-grouping {
    container bundle {
      tailf:info "Link aggregation per-interface commands";
      container id {
        tailf:info "Add the port to an aggregated interface.";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf id-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-65535>;;Identifier of the bundle to add the port to.";
          }
        }
        leaf mode {
          tailf:info "Specify the mode of operation.";
          type enumeration {
            enum active {
              tailf:info "Run LACP in active mode over the port.";
            }
            enum on {
              tailf:info "Do not run LACP over the port.";
            }
            enum passive {
              tailf:info "Run LACP in passive mode over the port.";
            }
          }
        }
      }
      leaf port-priority {
        tailf:info "Priority for this port. Lower value is higher priority.";
        type uint16 {
          tailf:info "<1-65535>;;Priority for this port. Lower value is higher priority.";
          range "1..65535";
        }
      }
    }
    container lacp {
      tailf:info "Link Aggregation Control Protocol per-interface commands";
      container period {
        tailf:info "Configure the rate at which packets are sent or received";
        leaf period-value {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          type uint16 {
            tailf:info "Specify the requested transmission period (in milliseconds) for the partner system (must be multiple of 100; default 1000)";
            range "100..1000";
          }
        }
        container short {
          tailf:info "Configure usage of the LACP short interval";
          tailf:cli-delete-when-empty;
          presence true;
          leaf receive {
            tailf:info "Expected period for rx packets if LACP short is enabled (NOTE: This CLI is deprecated and will be removed in future releases. Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
          leaf transmit {
            tailf:info "Period for tx packets if the peer is using LACP short (NOTE: This CLI is deprecated and will be removed in future releases. Use the CLI 'lacp period <time in milliseconds>' to configure short periods)";
            type uint16 {
              tailf:info "<100-1000>;;Period in milliseconds(must be multiple of 100; default 1000)";
              range "100..1000" {
                tailf:step 100;
              }
            }
          }
        }
      }
    }
  }

  grouping interface-pointtopoint-grouping {
    container keepalive {
      tailf:info "Set the keepalive interval, or disable keepalives";
      choice keepalive-choice {
        container values {
          tailf:cli-drop-node-name;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf interval {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-30>;; Enable keepalives with this interval (default is 10 seconds)";
              range "1..30";
            }
          }
          leaf retry {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Set the keepalive retry count (default is 3 for HDLC, 5 for PPP)";
              range "1..255";
            }
          }
        }
        leaf disable {
          tailf:info "Disable keepalives";
          type empty;
        }
      }
    }
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name config-fr-vc;
      key dlci;
      leaf dlci {
        type uint16 {
          tailf:info "<16-1007>;;DLCI Number";
          range "16..1007";
        }
      }
      uses interface-service-policy-grouping;
      leaf encap {
        tailf:info "Set the Encapsulation of this PVC";
        type enumeration {
          enum cisco {
            tailf:info "Use Cisco encapsulation for this PVC";
          }
          enum ietf {
            tailf:info "Use RFC1490/RFC2427 encapsulation for this PVC";
          }
        }
      }
      container fragment {
        tailf:info "Enable FRF.12 fragmentation and define fragment size";
        tailf:cli-compact-syntax;
        leaf end-to-end {
          tailf:info "Choose end-to-end FRF.12 fragmentation";
          type uint16 {
            tailf:info "<16-1600>;;fragment size in bytes";
            range "16..1600";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable fragmentation counters";
          type empty;
        }
      }
    }
    container ppp {
      tailf:info "Point-to-Point Protocol";
      container multilink {
        tailf:info "Configure PPP Multilink settings";
        container minimum-active {
          tailf:info "Configure the minimum requirements to activate the interface";
          leaf links {
            tailf:info "Configure the minimum number of active links required";
            type uint16 {
              tailf:info "<1-65535>;;Number of links";
              range "1..65535";
            }
          }
        }
      }
    }
  }

  grouping interface-multilink-grouping {
    container multilink {
      tailf:info "Modify Multilink parameters!";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-multilink;
      container fragment-size {
        tailf:info "Fragment size (some fragment sizes may not be supported)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-multilink-frag;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        leaf size {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<64-512>;;Size of fragments";
            range "64..512";
          }
        }
        leaf fragment-counter {
          tailf:info "Enable/Disable the fragmentation counters";
          type empty;
        }
      }
      container fragment {
        tailf:info "Set the fragmentation";
        leaf size {
          tailf:info "Set the fragmentation size";
          type uint16 {
            tailf:info "<64-9216>;;Fragmentation size in bytes";
            range "64..9216";
          }
        }
      }
    }
  }

  grouping interface-ethernet-grouping {
    container carrier-delay {
      tailf:info "Set the carrier delay on an interface";
      tailf:cli-compact-syntax;
      leaf up {
        tailf:info "Set the carrier delay up value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
      leaf down {
        tailf:info "Set the carrier delay down value";
        type uint32 {
          tailf:info "<0-2147483647>;;Delay in milliseconds";
          range "0..2147483647";
        }
      }
    }
    leaf duplex {
      tailf:info "Configure duplex operational mode";
      tailf:cli-full-command;
      type enumeration {
        enum full {
          tailf:info "Full duplex";
          tailf:code-name duplex_full;
        }
        enum half {
          tailf:info "Half duplex";
          tailf:code-name duplex_half;
        }
      }
    }
    container ethernet {
      tailf:info "Ethernet per-interface configuration commands";
      container udld {
        tailf:info "Enable the UniDirectional Link Detection protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-udld;
        leaf mode {
          tailf:info "Set the mode in which to run the UDLD protocol";
          tailf:cli-full-command;
          type enumeration {
            enum aggressive {
              tailf:info "Run UDLD in aggressive mode";
            }
            enum normal {
              tailf:info "Run UDLD in normal mode";
            }
          }
        }
      }
      container cfm {
        tailf:info "802.1ag Connectivity Fault Management configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-cfm;
        container mep {
          tailf:info "CFM Maintenance End Point configuration";
          list domain {
            tailf:info "Specify the Maintenance Domain the MEP operates in";
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Maintenance Domain name";
              }
            }
            leaf service {
              tailf:info "Specify the Maintenance Service the MEP operates in";
              tailf:cli-hide-in-submode;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;Maintenance Service name";
              }
            }
            leaf mep-id {
              tailf:info "Specify the MEP ID to assign to the MEP";
              tailf:cli-hide-in-submode;
              type uint16 {
                tailf:info "<1-8191>;;MEP ID";
                range "1..8191";
              }
            }
            leaf cos {
              tailf:info "Specify CoS bits for messages initiated by this MEP";
              type uint8 {
                tailf:info "<0-7>;;Class of Service";
                range "0..7";
              }
            }
            container sla {
              tailf:info "Service Level Agreement configuration";
              container operation {
                tailf:info "SLA operation configuration";
                list profile {
                  tailf:info "Specify the SLA profile for this operation";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands;
                  key "name mep-id";
                  leaf name {
                    type string {
                      tailf:info "WORD;;Profile name";
                    }
                  }
                  leaf target {
                    tailf:info "Specify the target for the SLA operation";
                    tailf:cli-prefix-key {
                      tailf:cli-before-key 2;
                    }
                    type empty;
                  }
                  leaf mep-id {
                    tailf:cli-expose-key-name;
                    tailf:info "Specify a target MEP";
                    type uint16 {
                      tailf:info "<1-8191>;;Target MEP ID";
                    }
                  }
                }
              }
            }
          }
        }
        container ais {
          tailf:info "CFM Alarm Indication Signal configuration";
          container transmission {
            tailf:info "CFM AIS transmission configuration";
            container up {
              tailf:info "Up configuration";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              presence true;
              leaf cos {
                tailf:info "Specify CoS bits for AIS messages";
                type uint8 {
                  tailf:info "<0-7>;;Class of Service";
                  range "0..7";
                }
              }
              leaf interval {
                tailf:info "Specify the AIS transmission interval";
                type enumeration {
                  enum 1s {
                    tailf:info "Interval of 1 second";
                  }
                  enum 1m {
                    tailf:info "Interval of 1 minute";
                  }
                }
              }
            }
          }
        }
      }
      leaf egress-filter {
        tailf:info "Override default egress-filter configuration on this interface";
        type enumeration {
          enum disable {
            tailf:info "No egress filtering, regardless of the global configuration";
          }
          enum strict {
            tailf:info "Strict egress filtering, regardless of the global configuration";
          }
        }
      }
    }
    container ethernet-services {
      tailf:info "Ethernet related services";
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Access-list name";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ethernet-services/access-list/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    leaf mac-address {
      tailf:info "Set the Mac address(xxxx.xxxx.xxxx) on an interface";
      type string {
        pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
      }
    }
    leaf speed {
      tailf:info "Set the ethernet speed on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum 10 {
          tailf:info "Ethernet is 10Mb";
        }
        enum 100 {
          tailf:info "Ethernet is 100Mb";
        }
        enum 1000 {
          tailf:info "Ethernet is 1Gb";
        }
      }
    }
    container transceiver {
      tailf:info "transceiver commands";
      container permit {
        tailf:info permit;
        container pid {
          tailf:info "Permit pluggable pid (Product ID) all";
          leaf all {
            tailf:info all;
            type empty;
          }
        }
      }
    }
    container nv {
      tailf:info "Network Virtualisation interface configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-nV;
      container edge {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-nV-Edge;
        leaf interface {
          tailf:info "nV Edge inter-rack interconnect interface";
          type empty;
        }
      }
      container satellite-fabric-link {
        tailf:info "Satellite Fabric Link configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-satellite-fabric-link;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf satellite {
          tailf:info "Satellite ID";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        container redundancy {
          tailf:cli-break-sequence-commands;
          tailf:info "Redundancy configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-nV-red;
          leaf iccp-group {
            tailf:info "Redundancy group ID";
            type uint32 {
              tailf:info "<1-4294967295>;;Redundancy group ID";
            }
          }
        }
        container remote-ports {
          tailf:info "Remote ports configuration";
          leaf GigabitEthernet {
            tailf:info "Remote ports type";
            type string {
              tailf:info "Slot/Subslot/Port(s)";
            }
          }
        }
      }
    }
  }

  grouping interface-common-grouping {
    leaf description {
      tailf:info "Set description for this interface";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Description for this interface";
      }
    }
    leaf bandwidth {
      tailf:info "Set the bandwidth of an interface";
      tailf:cli-full-command;
      type uint32 {
        tailf:info "<0-4294967295>;;bandwidth in kbps";
      }
    }
    leaf loopback {
      tailf:info "Set the loopback mode on an interface";
      tailf:cli-full-command;
      type enumeration {
        enum external {
          tailf:info "Enable external loopback (requires loopback connector)";
        }
        enum internal {
          tailf:info "Enable internal loopback";
        }
        enum line {
          tailf:info "Enable line loopback";
        }
      }
    }
    leaf mtu {
      tailf:info "Set the MTU on an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<64-65535>;;MTU size in bytes";
        range "64..65535";
      }
    }
    container negotiation {
      tailf:info "Select autonegotiation mode";
      container auto {
        tailf:info "Perform link autonegotiation";
        tailf:cli-delete-when-empty;
        presence true;
        leaf allow-overrides {
          tailf:info "Allow configured values to override negotiated settings";
          type empty;
        }
      }
    }
    list monitor-session {
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name config-if-mon;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:monitor-session/name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf ethernet {
        tailf:info "Replicate Ethernet traffic";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf direction {
        tailf:info "Specify the direction of traffic to replicate";
        tailf:cli-hide-in-submode;
        type enumeration {
          enum rx-only {
            tailf:info "Replicate only received (ingress) traffic";
          }
          enum tx-only {
            tailf:info "Replicate only transmitted (egress) traffic";
          }
        }
      }
      leaf acl {
        tailf:info "Enable acl based mirroring";
        type empty;
      }
    }
    container encapsulation {
      tailf:info "Set the encapsulation on an (sub)interface";
      choice encapsulation-choice {
        container frame-relay {
          tailf:info "Frame Relay networks";
          tailf:cli-delete-when-empty;
          presence true;
          leaf IETF {
            tailf:info "Use RFC1490/RFC2427 encapsulation";
            type empty;
          }
        }
        leaf hdlc {
          tailf:info "Serial HDLC synchronous";
          tailf:cli-full-command;
          type empty;
        }
        leaf mfr {
          tailf:info "Multilink Frame Relay Member Link";
          tailf:cli-full-command;
          type empty;
        }
        leaf ppp {
          tailf:info "Point-to-Point protocol";
          tailf:cli-full-command;
          type empty;
        }
        leaf default {
          tailf:info "Packets unmatched by other service instances";
          tailf:cli-full-command;
          type empty;
        }
        container untagged {
          tailf:info "Packets with no explicit VLAN tag";
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          presence true;
        }
        container ambiguous {
          tailf:info "Ambiguous L3 VLAN configuration";
          container dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf-list vlan-id {
              tailf:cli-drop-node-name;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
            leaf-list second-dot1q {
              tailf:info "IEEE 802.1Q VLAN-tagged packets";
              tailf:cli-optional-in-sequence;
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type union {
                type uint16 {
                  tailf:info "<1-4094>;;Single VLAN id";
                  range "1..4094";
                }
                type enumeration {
                  enum any {
                    tailf:info "Match any VLAN id";
                  }
                }
              }
            }
          }
        }
        container dot1q {
          tailf:info "IEEE 802.1Q VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf-list second-dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-optional-in-sequence;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          container ingress {
            tailf:info "Perform MAC-based matching";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf source-mac {
              tailf:info "Perform source MAC-based matching";
              type string {
                tailf:info "H.H.H;;MAC Address";
              }
            }
          }
        }
        container dot1ad {
          tailf:info "IEEE 802.1ad VLAN-tagged packets";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf-list vlan-id {
            tailf:cli-drop-node-name;
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
                enum priority-tagged {
                  tailf:info "IEEE 802.1ad priority-tagged packets";
                }
              }
            }
          }
          leaf-list dot1q {
            tailf:info "IEEE 802.1Q VLAN-tagged packets";
            tailf:cli-range-list-syntax;
            tailf:cli-replace-all;
            tailf:cli-optional-in-sequence;
            type union {
              type uint16 {
                tailf:info "<1-4094>;;Single VLAN id";
                range "1..4094";
              }
              type enumeration {
                enum any {
                  tailf:info "Match any VLAN id";
                }
              }
            }
          }
          leaf exact {
            tailf:info "Do not allow further inner tags";
            type empty;
          }
        }
      }
    }
    container pppoe {
      tailf:info "PPP over Ethernet";
      container enable {
        tailf:info "Enable PPPoE on the interface";
        tailf:cli-delete-when-empty;
        presence true;
        leaf bba-group {
          tailf:info "Specify the bba-group to use with the interface";
          type string {
            tailf:info "WORD;;The bba-group to use";
          }
        }
      }
    }
    container frame-relay {
      tailf:info "Frame Relay interface configuration commands";
      container lmi {
        tailf:info "Disable LMI";
        leaf disable {
          tailf:info "Disable LMI";
          type empty;
        }
      }
      container lmi-type {
        tailf:info "Use CISCO-ANSI-CCITT type LMI to select type";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum ansi {
              tailf:info "Use ANSI type LMI";
            }
            enum cisco {
              tailf:info "Use CISCO type LMI";
            }
            enum q933a {
              tailf:info "Use CCITT type LMI";
            }
          }
        }
      }
      container intf-type {
        tailf:info "Use DTE/DCE mode for LMI";
        tailf:cli-delete-when-empty;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum dce;
          }
        }
      }
      container multilink {
        tailf:info "Multilink Frame Relay interface configuration commands";
        leaf bandwidth-class {
          tailf:info "Multilink Frame Relay bandwidth class";
          type enumeration {
            enum a {
              tailf:info "Bandwidth class A";
            }
            enum b {
              tailf:info "Bandwidth class B";
            }
            enum c {
              tailf:info "Bandwidth class C";
            }
          }
        }
      }
    }
    container frequency {
      tailf:info "Frequency Synchronization configuration";
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-freqsync;
        container selection {
          tailf:info "Selection configuration commands";
          leaf input {
            tailf:info "Enable this source for selection";
            type empty;
          }
        }
        leaf priority {
          tailf:info "Source priority";
          type uint8 {
            tailf:info "<1-254>;;Source priority";
            range "1..254";
          }
        }
        leaf wait-to-restore {
          tailf:info "Set the wait-to-restore time";
          type uint8 {
            tailf:info "<0-12>;;Wait-to-restore time, in minutes";
            range "0..12";
          }
        }
        container quality {
          tailf:info "Quality level configuration";
          container receive {
            tailf:info "Adjust the received quality level";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
          container transmit {
            tailf:info "Set the quality level to be transmitted";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            uses freqsync-quality-grouping;
          }
        }
      }
    }
    uses interface-service-policy-grouping;
    leaf vrf {
      tailf:info "Set VRF in which the interface operates";
      tailf:cli-full-command;
      tailf:cli-diff-dependency "/cisco-ios-xr:vrf" {
        tailf:xpath-root 3;
      }
      type vrf-type;
    }
    container aaa {
      tailf:info "AAA configuration";
      container radius {
        tailf:info "AAA radius configuration";
        container attribute {
          tailf:info "AAA radius attribute";
          leaf nas-port-type {
            tailf:info "AAA nas-port-type attribute";
            type union {
              type uint8 {
                tailf:info "<0-44>;;Nas Port Type value";
              }
              type string {
                tailf:info "WORD;;Nas Port Type name";
              }
            }
          }
        }
      }
    }
    container ipv4 {
      tailf:info "IPv4 interface subcommands";
      leaf point-to-point {
        tailf:info "Enable point-to-point handling for this interface.";
        tailf:cli-full-command;
        type empty;
      }
      choice address-choice {
        case no {
          container no-address {
            tailf:cli-drop-node-name;
            leaf address {
              tailf:cli-boolean-no;
              type boolean;
              default true;
            }
          }
        }
        case yes {
          container address {
            tailf:info "Set the IPv4 address of an interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf ip {
              tailf:cli-drop-node-name;
              tailf:cli-remove-before-change;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "A.B.C.D;;IP address";
              }
            }
            leaf mask {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "A.B.C.D or /X;;IP subnet mask or /prefix";
              }
            }
            leaf route-tag {
              tailf:info "Route-tag to be associated with this address";
              type uint32 {
                tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                range "1..4294967295";
              }
            }
          }
          container address-secondary-list {
            tailf:cli-drop-node-name;
            list address {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              key "ip secondary";
              leaf ip {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP address";
                }
              }
              leaf secondary {
                type enumeration {
                  enum secondary {
                    tailf:info "Make this IPv4 address a secondary address";
                  }
                }
              }
              leaf mask {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key {
                  tailf:cli-before-key 2;
                }
                type string {
                  tailf:info "A.B.C.D or /X;;IP subnet mask or /masklength";
                }
              }
              leaf route-tag {
                tailf:info "Route-tag to be associated with this address";
                type uint32 {
                  tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        tailf:cli-remove-before-change;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
              tailf:xpath-root 3;
            }
          }
          type string {
            tailf:info "WORD;;access-list name";
          }
        }
        leaf hardware-count {
          tailf:cli-break-sequence-commands;
          tailf:info "Count packets in hardware";
          type empty;
        }
        leaf interface-statistics {
          tailf:info "Per interface statistics in hardware";
          type empty;
        }
      }
      container helper-address {
        tailf:info "Specify a destination address for UDP broadcasts";
        choice helper-address-choice {
          leaf local {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          leaf global {
            tailf:info "Helper-address is global";
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IP destination address";
            }
          }
          container vrf {
            tailf:info "VRF name for helper-address (if different from interface VRF)";
            tailf:cli-sequence-commands;
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;VPN Routing/Forwarding instance name";
              }
            }
            leaf address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP destination address";
              }
            }
          }
        }
      }
      leaf redirects {
        tailf:info "Enable sending ICMP Redirect messages";
        type empty;
      }
      leaf directed-broadcast {
        tailf:info "Enable forwarding of directed broadcasts";
        type empty;
      }
      leaf mtu {
        tailf:info "Set IPv4 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-65535>;;MTU (bytes)";
          range "68..65535";
        }
      }
      container bgp {
        tailf:info "Enable BGP policy based feature";
        container policy {
          tailf:info "BGP policy";
          container propagation {
            tailf:info "BGP QoS policy propagation";
            container input {
              tailf:info "QPPB on input";
              container qos-group {
                tailf:info "QPPB using Qos Group";
                container destination {
                  tailf:info "QPPB on destination IP address ";
                  presence true;
                }
              }
            }
          }
        }
      }
      container pim {
        tailf:info "PIM interface commands";
        leaf bidir-neighbor-filter {
          tailf:info "PIM bidir capable peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        leaf bsr-border {
          tailf:info "Border of PIM domain";
          type empty;
        }
        leaf dr-priority {
          tailf:info "PIM router DR priority";
          type uint32 {
            tailf:info "<0-4294967294>;;DR priority, preference given to larger value";
            range "0..4294967294";
          }
        }
        leaf nbma-mode {
          tailf:info "Use Non-Broadcast Multi-Access (NBMA) mode on interface";
          type empty;
        }
        leaf neighbor-filter {
          tailf:info "PIM peering filter";
          type union {
            type uint8 {
              tailf:info "<1-99>;;Access list number";
              range "1..99";
            }
            type string {
              tailf:info "WORD;;IP Named Standard Access list";
            }
          }
        }
        container query-interval {
          tailf:info "PIM router query interval";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice interval-choice {
            case secs {
              leaf secs {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "1..65535";
                }
              }
            }
            case msec {
              leaf msecs {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-65535>;;Query interval in seconds or milliseconds";
                  range "100..65535";
                }
                must "../msec" {
                  tailf:xpath-root 3;
                }
              }
              leaf msec {
                type empty;
              }
            }
          }
        }
        choice pim-mode {
          leaf sparse-dense-mode {
            tailf:info "Enable PIM sparse-dense-mode operation";
            type empty;
          }
          container dense-mode {
            tailf:cli-reset-container;
            tailf:info "Enable PIM dense-mode operation";
            presence true;
            container proxy-register {
              tailf:cli-reset-container;
              tailf:info "Send proxy registers";
              choice proxy-mode {
                leaf list {
                  tailf:info "Access list";
                  type union {
                    type uint16 {
                      tailf:info "<100-199>;;Extended access list number";
                      range "100..199";
                    }
                    type uint16 {
                      tailf:info "<2000-2699>;;Extended access list number (expanded range)";
                      range "2000..2699";
                    }
                    type string {
                      tailf:info "WORD;;IP named extended access list";
                    }
                  }
                }
                leaf route-map {
                  tailf:info Route-map;
                  type string {
                    tailf:info "WORD;;Route-map reference";
                  }
                }
              }
            }
          }
          leaf sparse-mode {
            tailf:info "Enable PIM sparse-mode operation";
            type empty;
          }
        }
        container state-refresh {
          tailf:info "PIM DM State-Refresh configuration";
          container origination-interval {
            tailf:info "PIM State-Refresh origination interval";
            tailf:cli-delete-when-empty;
            tailf:cli-reset-container;
            presence true;
            leaf secs {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-100>;;Interval in seconds";
                range "1..100";
              }
            }
          }
        }
      }
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container notification {
            tailf:info "drop-rate notify";
            leaf threshold {
              tailf:info "Urpf NOTIFY drop rate threshold";
              type uint32 {
                tailf:info "<0-4294967295>;;Drop rate in pps triggering notify - 0 is any drops";
                range "0..4294967295";
              }
            }
          }
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-all-siblings;
            }
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-self-ping {
              tailf:cli-break-sequence-commands;
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              type empty;
            }
          }
        }
      }
      container router {
        tailf:info "IP router interface commands";
        container isis {
          tailf:info "IS-IS Routing for IP";
          presence true;
          tailf:cli-reset-container;
          leaf routing-process {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Routing process tag";
            }
          }
        }
      }
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        uses interface-name-grouping;
      }
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }
    leaf proxy-arp {
      tailf:info "Enable proxy ARP";
      tailf:cli-full-command;
      type empty;
    }
    container ipv6 {
      tailf:info "IPv6 interface subcommands";
      leaf mtu {
        tailf:info "Set IPv6 Maximum Transmission Unit";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1280-65535>;;MTU (bytes)";
          range "1280..65535";
        }
      }
      container nd {
        tailf:info "IPv6 interface Neighbor Discovery subcommands";
        leaf cache-limit {
          tailf:info "Set Cache Limit for neighbor entry";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-10000>;;Cache Limit";
            range "1..10000";
          }
        }
        container dad {
          tailf:info "Duplicate Address Detection";
          leaf attempts {
            tailf:info "Set IPv6 Duplicate Address Detection Transmits";
            type uint16 {
              tailf:info "<0-600>;;Number of attempts";
              range "0..600";
            }
          }
        }
        leaf managed-config-flag {
          tailf:info "Hosts should use stateful protocol for address config";
          tailf:cli-full-command;
          type empty;
        }
        leaf ns-interval {
          tailf:info "Set advertised NS retransmission interval";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1000-4294967295>;;Retransmission interval in milliseconds";
            range "1000..4294967295";
          }
        }
        leaf other-config-flag {
          tailf:info "Hosts should use stateful protocol for non-address config";
          tailf:cli-full-command;
          type empty;
        }
        container prefix {
          tailf:info "Configure IPv6 Routing Prefix Advertisement";
          list prefix-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key prefix;
            leaf prefix {
              type union {
                type tailf:ipv6-address-and-prefix-length {
                  tailf:info "X:X::X/<0-128>;;IPv6 prefix x:x::y/<z>";
                }
                type string;
              }
            }
            uses interface-ipv6-nd-prefix-list-grouping;
          }
          container default {
            tailf:info "Specify prefix default parameters";
            uses interface-ipv6-nd-prefix-list-grouping;
          }
        }
        container ra {
          tailf:info "IPv6 interface ND RA subcommands";
          leaf hoplimit {
            tailf:info "IPv6 ND RA hoplimit";
            tailf:cli-full-command;
            type enumeration {
              enum unspecified {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }
          leaf mtu {
            tailf:info "IPv6 ND RA mtu option configuration";
            tailf:cli-full-command;
            type enumeration {
              enum unspecified {
                tailf:info "Unspecified IPv6 ND RA hop-limit value";
              }
            }
          }
        }
        leaf ra-interval {
          tailf:info "Set IPv6 Router Advertisement Interval";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<4-1800>;;Maximum RA Interval (sec)";
            range "4..1800";
          }
        }
        leaf ra-lifetime {
          tailf:info "Set IPv6 Router Advertisement Lifetime";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-9000>;;RA Lifetime (seconds)";
            range "0..9000";
          }
        }
        leaf reachable-time {
          tailf:info "Set advertised reachability time";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<0-3600000>;;Reachability time in milliseconds";
            range "0..3600000";
          }
        }
        leaf redirects {
          tailf:info "Enable sending of ICMP Redirect messages";
          tailf:cli-full-command;
          type empty;
        }
        leaf suppress-ra {
          tailf:info "Suppress IPv6 Router Advertisements";
          tailf:cli-full-command;
          type empty;
        }
      }
      container verify {
        tailf:info "Enable per packet validation";
        container unicast {
          tailf:info "Enable per packet validation for unicast";
          container source {
            tailf:info "Validation of source address";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf reachable-via {
              tailf:info "Specify reachability check to apply to the source address";
              type enumeration {
                enum any {
                  tailf:info "Source is reachable via any interface";
                }
                enum rx {
                  tailf:info "Source is reachable via interface on which packet was received";
                }
              }
            }
            leaf allow-default {
              tailf:info "Allow default route to match when checking source address";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf allow-self-ping {
              tailf:info "Allow router to ping itself (opens vulnerability in verification)";
              type empty;
            }
          }
        }
      }
      container address {
        tailf:info "Configure IPv6 address on interface";
        list prefix-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          key prefix;
          leaf prefix {
            type union {
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;IPv6 prefix";
              }
              type string {
                tailf:info "X:X::X%zone;;IPv6 name or address";
              }
            }
          }
          leaf eui-64 {
            tailf:info "Use eui-64 interface identifier";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf link-local {
            tailf:info "Use link-local address";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf route-tag {
            tailf:info "Route-tag to be associated with this address";
            type uint32 {
              tailf:info "<1-4294967295>;;Route-tag value (default: no tag)";
              range "1..4294967295";
            }
          }
        }
      }
      leaf enable {
        tailf:info "Enable IPv6 on interface";
        tailf:cli-full-command;
        type empty;
      }
      list access-group {
        tailf:info "Specify access control for packets";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key direction;
        leaf direction {
          type enumeration {
            enum egress {
              tailf:info "Filter outgoing packets";
            }
            enum ingress {
              tailf:info "Filter incoming packets";
            }
          }
        }
        leaf name {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;access-list name";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv6/access-list/named-acl/name" {
              tailf:xpath-root 3;
            }
          }
        }
        leaf interface-statistics {
          type empty;
        }
      }
      container unreachables {
        tailf:info "Enable sending ICMP Unreachable messages";
        leaf disable {
          tailf:info "Override sending of ICMP Unreachable messages";
          type empty;
        }
      }
    }
    container lldp {
      tailf:cli-add-mode;
      tailf:cli-mode-name config-lldp;
      container receive {
        tailf:info "Disable LLDP RX on an interface";
        leaf disable {
          tailf:info "Disable LLDP RX on an interface";
          type empty;
        }
      }
      container transmit {
        tailf:info "Disable LLDP TX on an interface";
        leaf disable {
          tailf:info "Disable LLDP TX on an interface";
          type empty;
        }
      }
    }
    container mpls {
      tailf:info "MPLS interface subcommands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-mpls;
      leaf ip {
        tailf:info "Configure dynamic MPLS forwarding for IP";
        type empty;
      }
      container label-security {
        tailf:info "MPLS label-security for the interface";
        leaf rpf {
          tailf:info "MPLS RPF for incoming packets";
          tailf:cli-full-command;
          type empty;
        }
        leaf multi-label-packet {
          tailf:info "Handling incoming packets with multiple labels on the stack";
          tailf:cli-full-command;
          type enumeration {
            enum drop {
              tailf:info "Drop packets with multiple labels on the stack";
            }
          }
        }
      }
      leaf mtu {
        tailf:info "Set the MPLS MTU for the interface";
        type uint16 {
          tailf:info "<68-65535>;;MTU size in bytes";
          range "68..65535";
        }
      }
    }
    container backup-bw {
      tailf:info "Fast-reroute backup bandwidth requirement";
      container unlimited {
        tailf:info "Unlimited backup bandwidth";
        choice unlimited-choice {
          leaf any-class-type {
            tailf:info "Specify any bandwidth class type";
            type empty;
          }
          leaf class-type {
            tailf:info "Specify the bandwidth class type";
            type uint8 {
              tailf:info "<0-1>;;Class type number";
              range "0..1";
            }
          }
        }
      }
    }
    leaf shutdown {
      tailf:info "shutdown the given interface";
      tailf:cli-full-command;
      type empty;
    }
    uses interface-isis-grouping;
    leaf load-interval {
      tailf:info "Specify interval for load calculation for an interface";
      tailf:cli-full-command;
      type uint16 {
        tailf:info "<0-600>;;Number of seconds";
        range "0..600" {
          tailf:step 30;
        }
      }
    }
    container capture {
      tailf:info "capture interface packets (platform)(cisco-support)";
      container software {
        tailf:info "capture software switched packets(cisco-support)";
        leaf packets {
          tailf:info "turns on both ingress and egress (platform)(cisco-support)";
          type empty;
        }
      }
    }
    container transport-mode {
      tailf:info "Set the transport mode on an interface";
      choice transport-mode-choice {
        leaf wan {
          tailf:info "10GBASE-W WAN SONET/SDH (9.95328Gb/s)";
          type empty;
        }
        container otn {
          tailf:info "10GE over Optical Transport Network (G.709)";
          leaf bit-transparent {
            tailf:info "10GBASE-R transparently mapped into OTU-2";
            type enumeration {
              enum opu1e {
                tailf:info "10GBASE-R over OPU1e without fixed stuffing (11.0491Gb/s)";
              }
              enum opu2e {
                tailf:info "10GBASE-R over OPU2e with fixed stuffing (11.0957Gb/s)";
              }
            }
          }
        }
        leaf rx-only {
          tailf:info "10GE UDLR Mode, Receive Only";
          type empty;
        }
        leaf tx-only {
          tailf:info "10GE UDLR Mode, Transmit Only";
          type empty;
        }
      }
    }
    leaf flow-control {
      tailf:info "configure flow-control on the given interface";
      tailf:cli-full-command;
      type enumeration {
        enum bidirectional {
          tailf:info "Enable bidirectional flow-control on an interface";
        }
        enum egress {
          tailf:info "Enable egress flow-control on an interface";
        }
        enum ingress {
          tailf:info "Enable ingress flow-control on an interface";
        }
      }
    }
    list flow {
      tailf:info "Netflow configuration";
      tailf:cli-suppress-mode;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      key "proto monitor direction";
      leaf proto {
        type enumeration {
          enum ipv4 {
            tailf:info "IPV4 netflow configuration";
          }
          enum ipv6 {
            tailf:info "IPV6 netflow configuration";
          }
          enum mpls {
            tailf:info "MPLS netflow configuration";
          }
        }
      }
      leaf monitor {
        tailf:info "Specify a flow monitor for packets";
        tailf:cli-expose-key-name;
        type string {
          tailf:info "WORD;;Flow monitor map name";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:flow/monitor-map/name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf sampler {
        tailf:info "Specify a sampler for packets";
        tailf:cli-prefix-key {
          tailf:cli-before-key 3;
        }
        type string {
          tailf:info "WORD;;Sampler map name";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:sampler-map/name" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf direction {
        type enumeration {
          enum egress {
            tailf:info "Apply flow monitor on outgoing packets";
          }
          enum ingress {
            tailf:info "Apply flow monitor on incoming packets";
          }
        }
      }
    }
    container dampening {
      tailf:info "configure state dampening on the given interface";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      presence true;
      leaf half-life {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-45>;;Decay half life (in minutes)";
          range "1..45";
        }
      }
      leaf reuse {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-20000>;;Reuse threshold";
          range "1..20000";
        }
      }
      leaf suppress {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<1-20000>;;Suppress threshold";
          range "1..20000";
        }
      }
      leaf max-suppress-time {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Max suppress time (in minutes)";
          range "1..255";
        }
      }
    }
    container logging {
      tailf:info "Configure logging for interface";
      container events {
        tailf:info "Interface events";
        leaf bundle-status {
          tailf:info "BUNDLE/UNBUNDLE messages";
          type empty;
        }
        leaf link-status {
          tailf:info "UPDOWN and CHANGE messages";
          type empty;
        }
        leaf nfas-status {
          tailf:info "NFAS D-channel status messages";
          type empty;
        }
        container spanning-tree {
          tailf:info "Spanning-tree Interface events";
          leaf status {
            tailf:info "Spanning-tree state change messages";
            type empty;
          }
        }
        container subif-link-status {
          tailf:info "Sub-interface UPDOWN and CHANGE messages";
          presence true;
          leaf ignore-bulk {
            tailf:info "Do not log messages when the main interface is transitioning";
            type empty;
          }
        }
        leaf trunk-status {
          tailf:info "TRUNK status messages";
          type empty;
        }
        uses lsp-status-grouping;
      }
      container ip {
        tailf:info "IP configuration";
        container access-list {
          tailf:info Access-list;
          container cache {
            tailf:info "Optimized logging";
            leaf in {
              tailf:info "inbound packet logs";
              type empty;
            }
            leaf out {
              tailf:info "outbound packet logs";
              type empty;
            }
          }
        }
      }
    }
    container storm-control {
      tailf:info "storm configuration";
      container action {
        tailf:info "Action to take for storm..control;";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container broadcast {
        tailf:info "Broadcast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container multicast {
        tailf:info "Multicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
      container unicast {
        tailf:info "Unicast address storm control";
        leaf level {
          tailf:info "Set storm suppression level on this interface";
          type decimal64 {
            fraction-digits 2;
            tailf:info "<0-100>;;Enter Integer part of level as percentage of bandwidth";
            range "0..100";
          }
        }
      }
    }
  }

  grouping subinterface-common-grouping {
    container rewrite {
      tailf:info "Set the tag rewriting policy for this EFP";
      container ingress {
        tailf:info "Set the tag rewriting policy for this EFP";
        container tag {
          tailf:info "Set the tag rewriting policy for this EFP";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice tag-choice {
            leaf pop {
              tailf:info "Remove one or more tags";
              type enumeration {
                enum 1 {
                  tailf:info "Remove outer tag only";
                }
                enum 2 {
                  tailf:info "Remove two outermost tags";
                }
              }
            }
            leaf push {
              tailf:info "Push one or more tags";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf translate {
              tailf:info "Replace tags with other tags";
              tailf:cli-incomplete-command;
              type enumeration {
                enum 1-to-1 {
                  tailf:info "Replace the outermost tag with another tag";
                }
                enum 1-to-2 {
                  tailf:info "Replace the outermost tag with two tags";
                }
                enum 2-to-1 {
                  tailf:info "Replace the outermost two tags with one tag";
                }
                enum 2-to-2 {
                  tailf:info "Replace the outermost two tags with two other tags";
                }
              }
            }
          }
          leaf dot1ad {
            when "not(../pop)" {
              tailf:xpath-root 3;
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1ad tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf dot1q {
            when "not(../pop)" {
              tailf:xpath-root 3;
              tailf:dependency "../pop";
            }
            tailf:info "Push a Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf second-dot1q {
            when "(../dot1q and not(../dot1ad))" {
              tailf:xpath-root 3;
              tailf:dependency "../dot1ad";
              tailf:dependency "../dot1q";
            }
            tailf:info "Push another Dot1Q tag";
            tailf:cli-optional-in-sequence;
            type uint16 {
              tailf:info "<1-4094>;;VLAN Id to push";
              range "1..4094";
            }
          }
          leaf mode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum symmetric {
                tailf:info "All rewrites must be symmetric";
              }
            }
          }
        }
      }
    }
    container dot1q {
      tailf:info "802.1Q VLAN configuration";
      container vlan {
        tailf:info "Configure a VLAN ID on the subinterface";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vlan-id {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
        }
        leaf second-dot1q {
          tailf:cli-drop-node-name;
          type union {
            type uint16 {
              tailf:info "<1-4094>;;Configure second (inner 802.1Q) VLAN ID on the subinterface";
              range "1..4094";
            }
            type string;
            type enumeration {
              enum any {
                tailf:info "Match any VLAN id";
              }
            }
          }
        }
      }
    }
    container dot1ad {
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf vlan-id {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<1-4094>;;Single VLAN id";
          range "1..4094";
        }
      }
      leaf second-dot1d {
        tailf:cli-drop-node-name;
        type union {
          type uint16 {
            tailf:info "<1-4094>;;Single VLAN id";
            range "1..4094";
          }
          type string;
          type enumeration {
            enum any {
              tailf:info "Match any VLAN id";
            }
          }
        }
      }
    }
    container l2protocol {
      tailf:info "Layer 2 protocol handling";
      leaf cpsv {
        tailf:info "CDP, PVST+, STP, and VTP protocols";
        type enumeration {
          enum drop {
            tailf:info "Drop these protocol packets";
          }
          enum reverse-tunnel {
            tailf:info "Tunnel at egress";
          }
          enum tunnel {
            tailf:info "Tunnel at ingress";
          }
        }
      }
    }
  }

  grouping interface-bfd-grouping {
    container bfd {
      tailf:info "BFD interface configuration commands";
      container address-family {
        tailf:info "Set configuration for a given address family";
        container ipv4 {
          tailf:info "Set configuration for the IPv4 address family";
          container timers {
            tailf:info "Set the timers that determine when a BFD session defaults to down";
            leaf start {
              tailf:info "The time since starting a BFD session before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
            leaf nbr-unconfig {
              tailf:info "The time since a BFD signalled that a peer sessionis unconfigured before it is considered to have gone down";
              type uint16 {
                tailf:info "<60-3600>;;Time in seconds";
                range "60..3600";
              }
            }
          }
          leaf multiplier {
            tailf:info "Set the preferred multiplier for the BFD session";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-50>;;The preferred multiplier for the BFD session";
              range "2..50";
            }
          }
          leaf destination {
            tailf:info "Set the destination address for the BFD session";
            tailf:cli-full-command;
            type inet:ipv4-address {
              tailf:info "IPv4 destination address for the BFD session";
            }
          }
          leaf fast-detect {
            tailf:info "Enable fast detection using BFD on bundle members";
            tailf:cli-full-command;
            type empty;
          }
          leaf minimum-interval {
            tailf:info "Set the preferred minimum interval for the BFD session";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<15-30000>;;The preferred minimum interval (in ms) for the BFD session";
              range "15..30000";
            }
          }
        }
      }
      leaf echo {
        tailf:info "Use echo adjunct as bfd detection mechanism";
        type empty;
      }
      container interval {
        tailf:info "Transmit interval between BFD packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-reset-container;
        leaf msecs {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf min_rx {
          tailf:info "Minimum receive interval capability";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<750-999>;;Milliseconds";
            range "750..999";
          }
        }
        leaf multiplier {
          tailf:info "Multiplier value used to compute holddown";
          type uint8 {
            tailf:info "<3-50>;;value used to multiply the interval";
            range "3..50";
          }
        }
      }
    }
  }

  grouping non-subinterface-common-grouping {
    container backup {
      tailf:info "Modify backup parameters";
      container interface {
        tailf:info "Configure an interface as a backup";
        uses interface-name-grouping;
      }
    }
    leaf cdp {
      tailf:info "Enable CDP on an interface";
      tailf:cli-full-command;
      type empty;
    }
    container dual-active {
      tailf:info "VS dual-active configuration command";
      leaf fast-hello {
        tailf:info "dual-active fast-hello detection method";
        type empty;
      }
    }
    container l2transport {
      tailf:info "Enable Layer 2 transport and enter its configuration submode";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-if-l2;
      presence true;
      uses interface-service-policy-grouping;
      container l2protocol {
        tailf:info "Layer 2 protocol handling";
        leaf cpsv {
          tailf:info "CDP, PVST+, STP, and VTP protocols";
          type enumeration {
            enum drop {
              tailf:info "Drop these protocol packets";
            }
            enum reverse-tunnel {
              tailf:info "Tunnel at egress";
            }
            enum tunnel {
              tailf:info "Tunnel at ingress";
            }
          }
        }
      }
    }
    container platform {
      tailf:info "platform specific interface configuration";
      container qos {
        tailf:info "qos command keyword";
        leaf channel-consistency {
          tailf:info "enable or disable qos consistency checks";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
    }
    container xconnect {
      tailf:info "Xconnect commands";
      leaf vfi {
        tailf:info "connect to a virtual forwarding instance";
        type string {
          tailf:info "WORD;;VFI name";
        }
      }
    }
    uses interface-switch-grouping;
  }

  grouping interface-tunnel-path-option-grouping {
    list path-option {
      tailf:info "Primary or fallback path setup option";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      tailf:cli-incomplete-command;
      key preference-priority;
      leaf preference-priority {
        type uint16 {
          tailf:info "<1-1000>;;Preference for this path option";
          range "1..1000";
        }
      }
      choice path-option-choice {
        container dynamic {
          tailf:info "Setup based on dynamically allocated path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          presence true;
        }
        container explicit {
          tailf:info "Setup based on preconfigured path";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice path-choice {
            leaf identifier {
              tailf:info "Specify an IP explicit path by number";
              type uint32 {
                tailf:info "<1-4294967295>;;Specify an IP explicit path by number";
              }
            }
            leaf name {
              tailf:info "Specify an IP explicit path by name";
              type string {
                tailf:info "WORD;;Specify an IP explicit path by name";
              }
            }
          }
        }
      }
      leaf segment-routing {
        tailf:info "Require segment routing`";
        tailf:cli-break-sequence-commands;
        type empty;
      }
      leaf verbatim {
        tailf:info "Do not require topology database for explicit path";
        type empty;
      }
      leaf lockdown {
        tailf:info "Not a candidate for reoptimization";
        type empty;
      }
      container ospf {
        tailf:info "Limit CSPF to a single OSPF instance and area";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf instance-name {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;OSPF instance name";
          }
        }
        leaf area {
          tailf:info "OSPF area";
          type union {
            type uint32 {
              tailf:info "<0-4294967295>;;OSPF area ID as a decimal value";
            }
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;OSPF area ID in IP address format";
            }
          }
        }
      }
      leaf attribute-set {
        tailf:info "Attribute set for this LSP";
        type string {
          tailf:info "WORD;;Specify attribute-set name (max 64 char)";
          length "1..64";
        }
      }
      leaf protected-by {
        tailf:info "Index of the protecting path-option";
        type uint32 {
          tailf:info "<1-1000>;;Index of the protecting path-option";
          range "1..1000";
        }
      }
    }
  }

  grouping interface-name-grouping {
    choice interface-choice {
      leaf Bundle-Ether {
        tailf:info "Aggregated Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Bundle-Ether/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container Bundle-Ether-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Bundle-Ether {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Bundle-Ether-subinterface/Bundle-Ether/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf BVI {
        tailf:info "Bridge-Group Virtual Interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/BVI/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf FastEthernet {
        tailf:info "FastEthernet IEEE 802.3";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/FastEthernet/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container FastEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FastEthernet {
          tailf:info "FastEthernet IEEE 802.3";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/FastEthernet-subinterface/FastEthernet/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf GigabitEthernet {
        tailf:info "GigabitEthernet IEEE 802.3z";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/GigabitEthernet/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container GigabitEthernet-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf GigabitEthernet {
          tailf:info "GigabitEthernet IEEE 802.3z";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/GigabitEthernet-subinterface/GigabitEthernet/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf TenGigE {
        tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/TenGigE/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container TenGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf TenGigE {
          tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/TenGigE-subinterface/TenGigE/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf FortyGigE {
        tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/FortyGigE/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container FortyGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf FortyGigE {
          tailf:info "FortyGigabitEthernet/IEEE 802.3 interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/FortyGigE-subinterface/FortyGigE/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf HundredGigE {
        tailf:info HundredGigEthernet;
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/HundredGigE/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container HundredGigE-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf HundredGigE {
          tailf:info HundredGigEthernet;
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subif";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/HundredGigE-subinterface/HundredGigE/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf PW-Ether {
        tailf:info "Pseudo-Wire Ethernet interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <1-32768>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/PW-Ether/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf Loopback {
        tailf:info "Loopback interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info <0-2147483647>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Loopback/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf MgmtEth {
        tailf:info "Ethernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/MgmtEth/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf Multilink {
        tailf:info "Multilink network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Multilink/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container Multilink-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Multilink {
          tailf:info "Multilink network interface(s)";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Multilink-subinterface/Multilink/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf SRP {
        tailf:info "SRP interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/SRP/id" {
            tailf:xpath-root 3;
          }
        }
        type string {
          pattern "[0-9]+.*";
        }
      }
      leaf Null {
        tailf:info "Null interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info <0-0>;
          pattern 0;
        }
      }
      leaf Port-channel {
        tailf:info "Ethernet Channel of interfaces";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint32 {
          tailf:info <1-512>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Port-channel/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/POS/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container POS-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf POS {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/POS-subinterface/POS/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf Serial {
        tailf:info "Serial interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Serial/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container Serial-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf Serial {
          tailf:info "Serial interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?\\.[0-9]+";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Serial-subinterface/Serial/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf tunnel-ip {
        tailf:info "GRE/IPinIP Tunnel Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-ip/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf tunnel-te {
        tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-te/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf tunnel-tp {
        tailf:info "MPLS Transport Protocol Tunnel interface";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-tp/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf tunnel-mte {
        tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info <0-65535>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-mte/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf tunnel-ipsec {
        tailf:info "IPSec Tunnel interface(s)";
        type uint32 {
          tailf:info <0-4294967295>;
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/tunnel-ipsec/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+.*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/ATM/id" {
            tailf:xpath-root 3;
          }
        }
      }
      container ATM-subinterface {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf ATM {
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type string {
            pattern "[0-9]+.*";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/ATM-subinterface/ATM/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      leaf Vlan {
        tailf:info "Iosxr Vlans";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Vlan/id" {
            tailf:xpath-root 3;
          }
        }
      }
      leaf CEM {
        tailf:info "Circuit Emulation interface(s)";
        tailf:cli-allow-join-with-value {
          tailf:cli-display-joined;
        }
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+.*";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/CEM/id" {
            tailf:xpath-root 3;
          }
        }
      }
    }
  }

  grouping interface-grouping {
    list Loopback {
      tailf:info "Loopback interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Loopback interface number";
        type uint32 {
          tailf:info "<0-2147483647>;;Loopback interface number";
          range "0..2147483647";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }
    list Bundle-Ether {
      tailf:info "Aggregated Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Bundle-Ether interface id";
        type uint16 {
          tailf:info <1-65535>;
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-bundle-grouping;
    }
    container Bundle-Ether-subinterface {
      tailf:cli-drop-node-name;
      list Bundle-Ether {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Bundle-Ether sub-interface id";
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list MgmtEth {
      tailf:info "Ethernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Ethernet/IEEE 802.3 interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/.+/.+/.+";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    list TenGigE {
      tailf:info "TenGigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Ten Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container TenGigE-subinterface {
      tailf:cli-drop-node-name;
      list TenGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Ten Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list FortyGigE {
      tailf:info FortyGigEthernet;
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Forty Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container FortyGigE-subinterface {
      tailf:cli-drop-node-name;
      list FortyGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Forty Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list HundredGigE {
      tailf:info HundredGigEthernet;
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Hundred Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container HundredGigE-subinterface {
      tailf:cli-drop-node-name;
      list HundredGigE {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Hundred Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list FastEthernet {
      tailf:info "FastEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Fast Ethernet interface id";
        type string {
          tailf:info "WORD;;Rack/Slot/Instance/Port";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container FastEthernet-subinterface {
      tailf:cli-drop-node-name;
      list FastEthernet {
        tailf:info "FastEthernet/IEEE 802.3 interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-if;
        key id;
        leaf id {
          tailf:info "Fast Ethernet sub-interface id";
          type string {
            tailf:info "WORD;;Rack/Slot/Instance/Port.subid";
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list GigabitEthernet {
      tailf:info "GigabitEthernet/IEEE 802.3 interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Gigabit Ethernet interface id";
        type string {
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
    }
    container GigabitEthernet-subinterface {
      tailf:cli-drop-node-name;
      list GigabitEthernet {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Gigabit Ethernet sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum l2transport;
            enum symmetric;
          }
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
      }
    }
    list nve {
      tailf:info "Network Virtualization Endpoint Interface(s)";
      tailf:cli-mode-name config-if-nve;
      tailf:cli-allow-join-with-key {
        tailf:cli-display-joined;
      }
      key name;
      leaf name {
        tailf:info "nve interface name";
        type uint16 {
          tailf:info "<0-65535>;;Config allowed on NVEs, range is 0-65535";
          range "0..65535";
        }
      }
      uses interface-common-grouping;
      container redundancy {
        tailf:info Redundancy;
        tailf:cli-add-mode;
        tailf:cli-mode-name config-nve-red;
        container backbone {
          tailf:info "Configure ICCP backbone";
          container mpls {
            tailf:info "ICCP MPLS backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-nve-red-backbone-mpls;
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
          container vxlan {
            tailf:info "ICCP VXLAN backbone";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-nve-red-backbone-vxlan;
            container iccp {
              tailf:info "Inter-Chassis Communication Protocol";
              leaf group {
                tailf:info "Configure ICCP group number";
                type uint32 {
                  tailf:info "<1-4294967295>;;Enter group number";
                  range "1..4294967295";
                }
              }
            }
          }
        }
      }
      container member {
        tailf:info "NVE VN-Segment Membership";
        list vni {
          tailf:info "vni;;Virtual Network Identifier";
          tailf:cli-mode-name config-nve-vni;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-16777215>;;Single VNI";
                range "1..16777215";
              }
              type string {
                tailf:info "<1-X>;;VNI range";
              }
            }
          }
          leaf vrf {
            tailf:info "Associate a VRF with VxLAN segment";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          container host-reachability {
            tailf:info "Configure host reachability advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum bgp {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          container host-reachabilty {
            tailf:info "Configure host reachabilty advertisement";
            leaf protocol {
              tailf:info "Control protocol to use";
              type enumeration {
                enum bgp {
                  tailf:info "Border Gateway Protocol";
                }
              }
            }
          }
          container mcast-group {
            tailf:info "associate a multicast core group with VxLAN segment(s)";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Single mcast ID or Start of range";
              }
            }
            leaf end-ip-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;End of mcast IP range";
              }
            }
          }
        }
      }
      leaf remap-replication-servers {
        tailf:info "Remap Replication servers to VNIs";
        tailf:cli-full-command;
        type empty;
      }
      leaf replication-server {
        tailf:info "Configure a replication server";
        tailf:cli-full-command;
        type inet:ipv4-address;
      }
      container source-interface {
        tailf:info "Configure source interface for Network Virtualization Endpoint";
        leaf Loopback {
          tailf:info "Loopback interface";
          tailf:cli-allow-join-with-value {
            tailf:cli-display-joined;
          }
          type uint32 {
            tailf:info <0-2147483647>;
            range "0..2147483647";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Loopback/id" {
              tailf:xpath-root 3;
            }
          }
        }
      }
      container anycast {
        tailf:info "Configure anycast mode parameters for this VTEP";
        container source-interface {
          tailf:info "Configure source interface for the anycast mode";
          leaf Loopback {
            tailf:info "Loopback interface";
            tailf:cli-allow-join-with-value {
              tailf:cli-display-joined;
            }
            type uint32 {
              tailf:info <0-2147483647>;
              range "0..2147483647";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/Loopback/id" {
                tailf:xpath-root 3;
              }
            }
          }
        }
      }
    }
    list PW-Ether {
      tailf:info "Pseudo-Wire Ethernet interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Pseudo-Wire Ethernet interface id";
        type uint16 {
          tailf:info <1-32768>;
          range "1..32768";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-non-bundle-grouping;
      container attach {
        tailf:info "Attach to an interface list";
        leaf generic-interface-list {
          tailf:info "Interface List";
          type string {
            tailf:info "WORD;;The name of the interface list";
          }
        }
      }
    }
    container PW-Ether-subinterface {
      tailf:cli-drop-node-name;
      list PW-Ether {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Pseudo-Wire Ethernet sub-interface id";
          type string {
            pattern "[0-9]+\\.[0-9]+";
          }
        }
        leaf l2transport {
          tailf:info "Treat as an attachment circuit";
          tailf:cli-hide-in-submode;
          type empty;
        }
        uses interface-common-grouping;
        uses interface-ethernet-grouping;
        uses subinterface-common-grouping;
        container attach {
          tailf:info "Attach to an interface list";
          leaf generic-interface-list {
            tailf:info "Interface List";
            type string {
              tailf:info "WORD;;The name of the interface list";
            }
          }
        }
      }
    }
    list Port-channel {
      tailf:info "Ethernet Channel of interfaces";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Port-channel interface id";
        type uint32 {
          tailf:info "<1-512>;;Port-channel interface number";
          range "1..512";
        }
      }
      uses interface-common-grouping;
      uses interface-ethernet-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }
    list POS {
      tailf:info "Packet over SONET/SDH network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "POS interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container pos {
        tailf:info "Modify POS parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-pos;
        leaf crc {
          tailf:cli-full-command;
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode ";
            }
            enum 32 {
              tailf:info "32-bit CRC mode (default)";
            }
          }
        }
      }
    }
    container POS-subinterface {
      tailf:cli-drop-node-name;
      list POS {
        tailf:info "Packet over SONET/SDH network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-subif;
        key id;
        leaf id {
          tailf:info "POS sub-interface id";
          type string {
            pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
      }
    }
    list BVI {
      tailf:info "Bridge-Group Virtual Interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "BVI interface id";
        type uint16 {
          tailf:info <1-65535>;
          range "1..65535";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }
    list Vlan {
      tailf:info "Iosxr Vlans";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Vlan interface id";
        type uint16 {
          tailf:info "<1-4094>;;Vlan interface number";
          range "1..4094";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
    }
    list tunnel-ip {
      tailf:info "GRE/IPinIP Tunnel Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-ip interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container tunnel {
        tailf:info "Configure GRE tunnel parameters";
        container mode {
          tailf:info "Tunnel encapsulation method (default: gre ipv4)";
          leaf gre {
            tailf:info "IP over GRE encapsulation";
            type enumeration {
              enum ipv4 {
                tailf:info "GRE over IPV4 encapsulation";
              }
              enum ipv6 {
                tailf:info "GRE over IPV6 encapsulation";
              }
            }
          }
        }
        leaf source {
          tailf:info "Tunnel source physical interface";
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf destination {
          tailf:info "Tunnel destination IP address";
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Ip Address";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPV6 address of the tunnel destination";
            }
          }
        }
      }
    }
    list tunnel-te {
      tailf:info "MPLS Traffic Engineering Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-te interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      container bfd {
        tailf:info "Configure BFD parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-bfd;
        presence true;
        leaf multiplier {
          tailf:info "Detect multiplier";
          type uint8 {
            tailf:info "3-10;;Detect multiplier (default 3)";
            range "3..10";
          }
        }
        container fast-detect {
          tailf:info "Enable BFD fast detection";
          tailf:cli-delete-when-empty;
          presence true;
          leaf sbfd {
            tailf:info "Enable SBFD";
            type empty;
          }
        }
        leaf minimum-interval {
          tailf:info "Hello interval";
          type uint16 {
            tailf:info "3-30000;;Hello interval in milliseconds (default 100)";
            range "3..30000";
          }
        }
        container dampening {
          tailf:info "Configure dampening intervals to bring tunnel up";
          leaf maximum-wait {
            tailf:info "Maximum delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 600000)";
              range "1..518400000";
            }
          }
          leaf secondary-wait {
            tailf:info "Secondary delay bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 20000)";
              range "1..518400000";
            }
          }
          leaf initial-wait {
            tailf:info "Initial delay before bringing up the tunnel";
            type uint32 {
              tailf:info "<1-518400000>;;Delay in milliseconds (default 16000)";
              range "1..518400000";
            }
          }
        }
        leaf bringup-timeout {
          tailf:info "Timeout before BFD session bring up on new LSP is aborted";
          type uint16 {
            tailf:info "<10-3600>;;Wait for session to come up in seconds (default 60)";
            range "10..3600";
          }
        }
        container lsp-ping {
          tailf:info "Configure periodic LSP ping";
          choice lsp-ping-choice {
            leaf disable {
              tailf:info "Disable periodic LSP Ping";
              type empty;
            }
            leaf interval {
              tailf:info "Periodic LSP ping interval";
              type uint16 {
                tailf:info "<60-3600>;;Periodic LSP Ping interval in seconds (default 120)";
                range "60..3600";
              }
            }
          }
        }
      }
      leaf load-share {
        tailf:info "Specify tunnel load-sharing metric";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4294967295>;;Loadshare value. Scale is the same as bandwidths.";
          range "1..4294967295";
        }
      }
      container auto-bw {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-autobw;
        container bw-limit {
          tailf:info "Set min/max bandwidth auto-bw can apply on a tunnel";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:info "Set minimum bandwidth auto-bw can apply on a tunnel";
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Minimum bandwidth to apply (kbps)";
            }
          }
          leaf max {
            tailf:info "Set maximum bandwidth auto-bw can apply on a tunnel";
            type uint32 {
              tailf:info "<0-4294967295>;;Maximum bandwidth to apply (kbps)";
            }
          }
        }
        container overflow {
          tailf:info "Configuring the tunnel overflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container underflow {
          tailf:info "Configuring the tunnel underflow detection";
          uses interface-tunnel-te-auto-bw-threshold-grouping;
        }
        container adjustment-threshold {
          tailf:info "Set the bandwidth change threshold to trigger adjustment";
          leaf percentage {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Bandwidth change percent to trigger adjustment";
              range "1..100";
            }
          }
          leaf min {
            tailf:info "Set the bandwidth change value to trigger adjustment";
            type uint32 {
              tailf:info "<10-4294967295>;;Bandwidth change value to trigger adjustment (kbps)";
              range "10..4294967295";
            }
          }
        }
        leaf application {
          tailf:info "Set the tunnel auto-bw application frequency";
          type uint16 {
            tailf:info "<5-10080>;;Auto-bw application frequency (minutes)";
            range "5..10080";
          }
        }
      }
      container autoroute {
        tailf:info "Parameters for IGP routing over tunnel";
        container metric {
          tailf:info "Specify MPLS tunnel metric";
          choice metric-choice {
            leaf absolute {
              tailf:info "Set metric mode absolute";
              type uint32 {
                tailf:info "<1-2147483647>;;Absolute metric";
                range "1..2147483647";
              }
            }
            leaf relative {
              tailf:info "Set metric mode relative";
              type int8 {
                tailf:info "<-10,+10>;;Relative metric";
                range "-10..10";
              }
            }
          }
        }
        container announce {
          tailf:info "Announce tunnel to IGP";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-if-tunte-aa;
          presence true;
          container metric {
            tailf:info "Specify MPLS tunnel metric";
            choice metric-choice {
              leaf constant {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2147483647>;;Set constant metric";
                  range "1..2147483647";
                }
              }
              leaf absolute {
                tailf:info "Set metric mode absolute";
                type uint32 {
                  tailf:info "<1-2147483647>;;Absolute metric";
                  range "1..2147483647";
                }
              }
              leaf relative {
                tailf:info "Set metric mode relative";
                type int8 {
                  tailf:info "<-10,+10>;;Relative metric";
                  range "-10..10";
                }
              }
            }
          }
        }
        list destination {
          tailf:info "Adds static route to destination";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key addr;
          leaf addr {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Address of static route to add";
            }
          }
        }
      }
      leaf destination {
        tailf:info "Specify tunnel destination";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Destination address";
        }
      }
      leaf forward-class {
        tailf:info "Specify tunnel forward class for policy based routing";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
          range "1..7";
        }
      }
      leaf policy-class {
        tailf:info "Specify classs for policy-based tunnel selection";
        type union {
          type enumeration {
            enum default {
              tailf:info "Default class for policy-based tunnel selection";
            }
          }
          type uint8 {
            tailf:info "<1-7>;;Tunnel policy class";
            range "1..7";
          }
        }
      }
      leaf soft-preemption {
        tailf:info "Enable the soft-preemption feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container affinity {
        tailf:info "Link attributes for links traversed by tunnel";
        container affinity-value {
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          tailf:cli-drop-node-name;
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity value";
              pattern 0x[0-9a-fA-F]+;
            }
          }
          leaf mask {
            type string {
              tailf:info "<0x0-0xffffffff>;;Affinity mask value";
              pattern 0x[0-9a-fA-F]+;
            }
          }
        }
        list include {
          tailf:info "Affinity to include in the loose sense";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
        list include-strict {
          tailf:info "Affinity to include in the strict sense";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
        list exclude {
          tailf:info "Affinity to exclude";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;Affinity name";
            }
          }
        }
      }
      leaf path-protection {
        tailf:info "Enable the path protection feature on this tunnel";
        tailf:cli-full-command;
        type empty;
      }
      container path-selection {
        tailf:info "Path Selection Configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-tunte-path-sel;
        container metric {
          tailf:info "Metric Type for path calculation";
          leaf metric-type {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type enumeration {
              enum igp {
                tailf:info "Use IGP metric";
              }
              enum te {
                tailf:info "Use TE metric";
              }
            }
          }
        }
        container segment-routing {
          tailf:info "Segment-routing path-selection options";
          leaf adjacency {
            tailf:info "Segment-routing adjacency path-selection type";
            type enumeration {
              enum protected {
                tailf:info "Use only protected adjacencies";
              }
              enum unprotected {
                tailf:info "Use only unprotected adjacencies";
              }
            }
          }
        }
      }
      container priority {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf setup {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-7>;;Setup Priority";
            range "0..7";
          }
        }
        leaf hold-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<0-7>;;Hold Priority";
          }
        }
      }
      leaf signalled-name {
        tailf:info "The signaling name to assign to tunnel";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;The name to be included in signaling";
        }
      }
      container signalled-bandwidth {
        tailf:info "Tunnel bandwidth requirement to be signalled";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf sub-pool {
          tailf:info "Specify sub-pool bandwidth";
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf bandwidth {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
          }
        }
        leaf class-type {
          when "not(../sub-pool)" {
            tailf:xpath-root 3;
            tailf:dependency "../sub-pool";
          }
          tailf:info "Specify the bandwidth class type";
          type uint8 {
            tailf:info "<0-1>;;Class type number";
            range "0..1";
          }
        }
      }
      leaf fast-reroute {
        tailf:info "Specify MPLS tunnel can be fast-rerouted";
        tailf:cli-full-command;
        type empty;
      }
      leaf record-route {
        tailf:info "Record the route used by the tunnel";
        tailf:cli-full-command;
        type empty;
      }
      uses interface-tunnel-path-option-grouping;
      container pce {
        tailf:info "Config PCE parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-pce;
        presence true;
        leaf delegation {
          tailf:info "Enable PCE delegation";
          type empty;
        }
      }
    }
    list tunnel-tp {
      tailf:info "MPLS Transport Protocol Tunnel interface";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-tp interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
    list tunnel-mte {
      tailf:info "MPLS Traffic Engineering P2MP Tunnel interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-mte interface id";
        type uint16 {
          tailf:info <0-65535>;
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      list destination {
        tailf:info "Specify a destination to an endpoint of the tunnel";
        tailf:cli-mode-name config-if-p2mp-dest;
        key addr;
        leaf addr {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Destination address";
          }
        }
        uses interface-tunnel-path-option-grouping;
      }
    }
    list tunnel-ipsec {
      tailf:info "IPSec Tunnel interface(s)";
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "tunnel-ipsec interface id";
        type uint32 {
          tailf:info <0-4294967295>;
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
    }
    list ATM {
      tailf:info "ATM Network Interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "ATM Network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-atm-grouping;
    }
    container ATM-subinterface {
      tailf:cli-drop-node-name;
      list ATM {
        tailf:info "ATM Network Interface(s)";
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "ATM Network sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        choice mode-choice {
          leaf l2transport {
            tailf:info "Treat as an attachment circuit";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
          leaf point-to-point {
            tailf:info "Treat as a point-to-point link";
            tailf:cli-full-command;
            tailf:cli-hide-in-submode;
            type empty;
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-atm-grouping;
      }
    }
    list Multilink {
      tailf:info "Multilink network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Multilink interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      uses interface-multilink-grouping;
    }
    container Multilink-subinterface {
      tailf:cli-drop-node-name;
      list Multilink {
        tailf:cli-mode-name config-subif;
        tailf:cli-allow-join-with-key;
        key id;
        leaf id {
          tailf:info "Multilink sub-interface id";
          type string {
            pattern "[0-9]+(/[0-9]+)*\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
          }
        }
        uses interface-common-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        uses interface-multilink-grouping;
      }
    }
    list SRP {
      tailf:info "SRP interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        type string {
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses non-subinterface-common-grouping;
      container threshold {
        tailf:info "Commands to set the threshold for the appropriate Bit Error Rate";
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
    }
    list Serial {
      tailf:info "Serial network interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Serial network interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      uses interface-pointtopoint-grouping;
      container multilink {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-multilink;
        leaf group {
          tailf:info "Enter multilink group ID";
          type uint32 {
            tailf:info "<1-999999999>;;Group Id";
            range "1..999999999";
          }
        }
      }
      container serial {
        tailf:info "Modify Serial parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-if-serial;
        leaf crc {
          tailf:info "Set the Encapsulation of this PVC";
          type enumeration {
            enum 16 {
              tailf:info "16-bit CRC mode (default)";
            }
            enum 32 {
              tailf:info "32-bit CRC mode";
            }
          }
        }
        leaf scramble {
          tailf:info "Enable payload scrambling on Serial interface";
          type empty;
        }
      }
    }
    container Serial-subinterface {
      tailf:cli-drop-node-name;
      list Serial {
        tailf:info "Serial network interface(s)";
        tailf:cli-allow-join-with-key;
        tailf:cli-mode-name config-subif;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          tailf:info "Serial network sub-interface id";
          type string {
            tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
            pattern "[0-9]+(/[0-9]+)+(:[0-9]+)?\\.[0-9]+";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum point-to-point {
              tailf:info "Treat as a point-to-point link";
            }
            enum l2transport {
              tailf:info "Treat as an attachment circuit";
            }
          }
        }
        uses interface-common-grouping;
        uses interface-bfd-grouping;
        uses subinterface-common-grouping;
        uses interface-pointtopoint-grouping;
        leaf subinterface {
          tailf:info "Do not SET, internal testing leaf only";
          tailf:cli-full-command;
          type empty;
        }
      }
    }
    list CEM {
      tailf:info "Circuit Emulation interface(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-if;
      key id;
      leaf id {
        tailf:info "Circuit Emulation interface id";
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+.*";
        }
      }
      uses interface-common-grouping;
      uses interface-bfd-grouping;
      uses non-subinterface-common-grouping;
      container cem {
        tailf:info "Global CEM interface configuration subcommands";
        leaf class-attach {
          tailf:info "Attach a CEM class to this interface";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;CEM class name";
          }
        }
        leaf dejitter {
          tailf:info "Configure dejitter buffer";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-500>;;buffer size in milliseconds";
          }
        }
      }
    }
  }

  grouping bgp-address-family-pre-grouping {
    container label {
      tailf:info "Label-related configuration";
      container mode {
        tailf:info "Select label mode";
        choice mode-choice {
          leaf per-ce {
            tailf:info "Set per CE label mode";
            type empty;
          }
          leaf per-prefix {
            tailf:info "Set per perfix label mode";
            type empty;
          }
          leaf per-vrf {
            tailf:info "Set per VRF label mode";
            type empty;
          }
          leaf route-policy {
            tailf:info "Use a route policy to select prefixes for label allocation mode";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
        }
      }
    }
    leaf table-policy {
      tailf:info "Configure policy for installation of routes to RIB";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Name of the policy";
      }
    }
    container retain {
      tailf:info "Accept/Retain specified bgp parameters";
      leaf local-label {
        tailf:info "Delay the release of the local label as configured";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<3-60>;;Label retention time in minutes";
          range "3..60";
        }
      }
      container route-target {
        tailf:info "Accept received updates with the specified route targets";
        choice route-target-choice {
          leaf all {
            tailf:info "Accept received updates containing at least one route target";
            type empty;
          }
          leaf route-policy {
            tailf:info "Accept received updates accepted by the specified policy";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                tailf:xpath-root 3;
              }
            }
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update generation configuration";
      container limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        leaf address-family {
          tailf:info "Update limit for address-family";
          type uint16 {
            tailf:info "<4-2048>;;Update limit in MegaBytes(MB); default is 256 MB";
            range "4..2048";
          }
        }
        container sub-group {
          tailf:info "Update limit for sub-groups";
          leaf ebgp {
            tailf:info "Update limit for eBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
          leaf ibgp {
            tailf:info "Update limit for iBGP sub-groups";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-512>;;Update limit in MegaBytes(MB); default is 32 MB";
              range "1..512";
            }
          }
        }
      }
    }
    container additional-paths {
      tailf:info "Additional paths configuration";
      leaf receive {
        tailf:info "Additional paths Receive capability";
        tailf:cli-full-command;
        type empty;
      }
      leaf send {
        tailf:info "Additional paths Send capability";
        tailf:cli-full-command;
        type empty;
      }
      container selection {
        tailf:info "Additional paths selection";
        list route-policy {
          tailf:info "Route-policy for additional paths selection";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                tailf:xpath-root 3;
              }
            }
          }
        }
      }
    }
    leaf weight {
      tailf:info "Define or modify weight";
      tailf:cli-full-command;
      type union {
        type enumeration {
          enum reset-on-import {
            tailf:info "Reset weight of paths on import";
          }
        }
        type uint32 {
          tailf:info "<0-65535>;;default weight";
          range "0..65535";
        }
      }
    }
    container advertise {
      tailf:info "Advertise BGP path";
      leaf best-external {
        tailf:info "Advertise best-external path";
        type empty;
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }
      container vpnv6 {
        tailf:info "Vpnv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-delete-when-empty;
          presence true;
          uses router-bgp-af-advertise-grouping;
        }
      }
    }
    container bgp {
      tailf:info "BGP Commands";
      leaf attribute-download {
        tailf:info "Configure attribute download for this address-family";
        tailf:cli-full-command;
        type empty;
      }
      container dampening {
        tailf:info "Enable route-flap dampening";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-delete-when-empty;
        presence true;
        choice dampening-choice {
          case a {
            leaf half-life {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-45>;;Half-life time for the penalty";
                range "1..45";
              }
            }
            leaf reuse {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start reusing a route";
                range "1..20000";
              }
            }
            leaf suppress {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-20000>;;Value to start suppressing a route";
                range "1..20000";
              }
            }
            leaf max-suppress-time {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-255>;;Maximum duration to suppress a stable route";
                range "1..255";
              }
            }
          }
          case b {
            leaf route-policy {
              tailf:info "Route policy to specify criteria for dampening";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the policy";
              }
            }
          }
        }
      }
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container client-to-client {
        tailf:info "Configure client to client route reflection";
        container reflection {
          tailf:info Reflection;
          leaf disable {
            tailf:info Disable;
            type empty;
          }
        }
      }
    }
    container maximum-paths {
      tailf:info "Forward packets over multiple paths";
      container eibgp {
        tailf:info eiBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
      container ebgp {
        tailf:info eBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths";
          }
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
      container ibgp {
        tailf:info iBGP-multipath;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf maximum {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<2-32>;;Number of paths (limit includes backup path)";
          }
        }
        leaf unequal-cost {
          tailf:info "Allow multipaths to have different BGP nexthop IGP metrics";
          tailf:cli-optional-in-sequence;
          type empty;
        }
        leaf selective {
          tailf:info "Allow multipaths only from marked neighbors";
          type empty;
        }
      }
    }
    container distance {
      tailf:info "Define an administrative distance";
      container bgp {
        tailf:info "BGP distance";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf external {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes external to the AS";
            range "1..255";
          }
        }
        leaf internal {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-255>;;Distance for routes internal to the AS";
            range "1..255";
          }
        }
        leaf local {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Distance for local routes";
            range "1..255";
          }
        }
      }
    }
    container nexthop {
      tailf:info Nexthop;
      container resolution {
        tailf:info "Nexthop resolution";
        container prefix-length {
          tailf:info "Nexthop resolution prefix-length";
          leaf minimum {
            tailf:info "Set minimum prefix-length for nexthop resolution";
            type uint16 {
              tailf:info "<0-32|128>;;Prefix-length value (only 0 and 32|128 are supported)";
            }
          }
        }
      }
      leaf route-policy {
        tailf:info "Policy to filter out nexthop notification";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
      }
      container trigger-delay {
        tailf:info "Processing trigger delay";
        leaf critical {
          tailf:info "For critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
        leaf non-critical {
          tailf:info "For non-critical notification";
          type uint32 {
            tailf:info "<0-4294967295>;;Delay in milliseconds";
          }
        }
      }
    }
    leaf domain-distinguisher {
      tailf:info "Globally unique identifier for IGP domain";
      tailf:cli-full-command;
      type string {
        tailf:info "<1-4294967295>:;;4 octet ASN";
      }
    }
  }

  grouping bgp-address-family-post-grouping {
    list aggregate-address {
      tailf:info "Configure BGP aggregate entries";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      key prefix;
      leaf prefix {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 Aggregate address and mask or masklength";
        }
      }
      leaf as-set {
        tailf:info "Generate AS set path information";
        type empty;
      }
      leaf as-confed-set {
        tailf:info "Generate AS confed set path information";
        type empty;
      }
      leaf summary-only {
        tailf:info "Filter more specific routes from updates";
        type empty;
      }
      container route-policy {
        tailf:info "Policy to condition advertisement, suppression,and attributes";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf name {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container connected {
        tailf:info "Connected routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }
      container static {
        tailf:info "Static routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }
      container rip {
        tailf:info "Routing Information Protocol (RIP)";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }
      container mobile {
        tailf:info "Mobile routes";
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-af-redistribute-grouping;
      }
      list ospf {
        tailf:info "Open Shortest Path First (OSPF)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;OSPF router tag";
          }
        }
        leaf match {
          tailf:info "Redistribution of OSPF routes";
          type empty;
        }
        leaf internal {
          tailf:info "Redistribute OSPF internal routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf external {
          tailf:info "Redistribute OSPF external routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf external-type {
          tailf:cli-drop-node-name;
          when "../external" {
            tailf:xpath-root 3;
          }
          type enumeration {
            enum 1 {
              tailf:info "Redistribute external type 1 routes";
            }
            enum 2 {
              tailf:info "Redistribute external type 2 routes";
            }
          }
        }
        leaf nssa-external {
          tailf:info "Redistribute OSPF NSSA external routes";
          when "../match" {
            tailf:xpath-root 3;
          }
          type empty;
        }
        leaf nssa-external-type {
          tailf:cli-drop-node-name;
          when "../nssa-external" {
            tailf:xpath-root 3;
          }
          type enumeration {
            enum 1 {
              tailf:info "Redistribute NSSA external type 1 routes";
            }
            enum 2 {
              tailf:info "Redistribute NSSA external type 2 routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }
      list isis {
        tailf:info "ISO IS-IS";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;IS-IS instance name";
          }
        }
        leaf level {
          tailf:info "Redistribute routes from the specified ISIS levels";
          type enumeration {
            enum 1 {
              tailf:info "Redistribute ISIS level 1 routes";
            }
            enum 1-inter-area {
              tailf:info "Redistribute ISIS level 1 inter-area routes";
            }
            enum 2 {
              tailf:info "Redistribute ISIS level 2 ISIS routes";
            }
          }
        }
        uses router-af-redistribute-grouping;
      }
    }
    container allocate-label {
      tailf:info "Allocate label for selected prefixes";
      choice allocate-label-choice {
        leaf all {
          tailf:info "Allocate labels for all prefixes";
          type empty;
        }
        leaf route-policy {
          tailf:info "Use a route policy to select prefixes for label allocation";
          type string {
            tailf:info "WORD;;Name of the policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
  }

  grouping bgp-address-family-ipv4-grouping {
    uses bgp-address-family-pre-grouping;
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type ipv4-prefix {
          tailf:info "A.B.C.D/length;;IPv4 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    uses bgp-address-family-post-grouping;
  }

  grouping bgp-address-family-ipv6-grouping {
    uses bgp-address-family-pre-grouping;
    list network {
      tailf:info "Specify a network to announce via BGP";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key net;
      leaf net {
        type tailf:ipv6-address-and-prefix-length {
          tailf:info "X:X::X/length;;IPv6 network and mask or masklength";
        }
      }
      leaf backdoor {
        tailf:info "Specify a BGP backdoor route";
        type empty;
      }
      leaf route-policy {
        tailf:info "Route-policy to modify the attributes";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    uses bgp-address-family-post-grouping;
  }

  grouping bgp-address-family-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container vpnv6 {
        tailf:info "VPNv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
        }
      }
      container link-state {
        tailf:info "Link-state Address Family";
        container link-state {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-pre-grouping;
        }
      }
    }
  }

  grouping router-bgp-neighbor-af-grouping {
    leaf multipath {
      tailf:info "Paths from this neighbor is eligible for multipath";
      tailf:cli-full-command;
      type empty;
    }
    list route-policy {
      tailf:info "Apply route policy to neighbor";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      key direction;
      leaf direction {
        type enumeration {
          enum in {
            tailf:info "Apply route policy to inbound routes";
          }
          enum out {
            tailf:info "Apply route policy to outbound routes";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        tailf:meta-data string-remove-quotes {
          tailf:meta-value "route-policy <STRING>";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
    leaf encapsulation-type {
      tailf:info "Specify encapsulation type";
      tailf:cli-full-command;
      type enumeration {
        enum mpls {
          tailf:info "MPLS encapsulation";
        }
        enum vxlan {
          tailf:info "VxLAN encapsulation";
        }
      }
    }
    container remove-private-AS {
      tailf:info "Remove private AS number from outbound updates";
      tailf:cli-delete-when-empty;
      presence true;
      leaf entire-aspath {
        tailf:info "remove only if all ASes in the path are private";
        type empty;
      }
    }
    container soft-reconfiguration {
      tailf:info "Per neighbor soft reconfiguration";
      container inbound {
        tailf:info "Allow inbound soft reconfiguration for this neighbor";
        tailf:cli-compact-syntax;
        presence true;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum always {
              tailf:info "Always use soft reconfig, even if route refresh is supported";
            }
            enum inheritance-disable {
              tailf:info "Prevent soft-reconfiguration from being inherited from the parent";
            }
          }
        }
      }
    }
    container allowas-in {
      tailf:info "Allow as-path with my AS present in it";
      leaf as-occurrence-number {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-10>;;Number of occurences of AS number";
          range "1..10";
        }
      }
    }
    leaf site-of-origin {
      tailf:info "Site-of-Origin extended community associated with the neighbor";
      type string {
        tailf:info "WORD;;AS number or IPV4 address:index";
      }
    }
    container import {
      tailf:info "Import options for neighbor address-family routes";
      choice import-choice {
        container stitching-rt {
          tailf:info "Import routes using stitching RTs";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          choice re-originate-choice {
            leaf re-originate {
              tailf:info "Reoriginate imported routes";
              type empty;
            }
            leaf reoriginate {
              tailf:info "Reoriginate imported routes, version 5.3.x";
              type empty;
            }
          }
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
        container re-originate {
          tailf:info "Re-originate imported routes";
          tailf:cli-delete-when-empty;
          presence true;
          leaf stitching-rt {
            tailf:info "Reoriginate imported routes by attaching stitching RTs";
            type empty;
          }
        }
      }
    }
    container accept-own {
      tailf:info "Handle self-originated routes with Accept-Own community";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent item being inherited from a parent group";
        type empty;
      }
    }
    container as-override {
      tailf:info "Override matching AS-number while sending update";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent as-override from being inherited from the parent";
        type empty;
      }
    }
    container maximum-prefix {
      tailf:info "Maximum number of prefixes to accept from this peer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      tailf:cli-reset-container;
      leaf max-prefix-limit {
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;maximum no. of prefix limit";
          range "1..4294967295";
        }
      }
      leaf threshold {
        tailf:cli-drop-node-name;
        tailf:cli-break-sequence-commands;
        type uint8 {
          tailf:info "<1-100>;;Threshold value (%) at which to generate a warning msg";
          range "1..100";
        }
      }
      leaf restart {
        tailf:info "Restart time interval";
        type uint16 {
          tailf:info "<1-65535>;;Time interval (min) after which peering session will be reestablished";
          range "1..65535";
        }
      }
      leaf warning-only {
        tailf:info "Only give warning message when limit is exceeded";
        tailf:cli-full-command;
        type empty;
      }
    }
    container next-hop-self {
      tailf:info "Disable the next hop calculation for this neighbor";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-self from being inherited from the parent";
        type empty;
      }
    }
    container next-hop-unchanged {
      tailf:info "Do not overwrite next hop before advertising to eBGP peers";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent next-hop-unchanged from being inherited from the parent";
        type empty;
      }
    }
    leaf route-reflector-client {
      tailf:info "Configure a neighbor as Route Reflector client";
      type empty;
    }
    container default-originate {
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-policy {
        tailf:info "Route policy to specify criteria to originate default";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
      }
    }
    container send-community-ebgp {
      tailf:info "Send community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-community-ebgp from being inherited from the parent";
        type empty;
      }
    }
    container send-extended-community-ebgp {
      tailf:info "Send extended community attribute to this external neighbor";
      tailf:cli-reset-container;
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent send-extended-community-ebgp from being inherited from the parent";
        type empty;
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration for this address-family from an af-group";
        tailf:cli-full-command;
        type string;
      }
    }
    container capability {
      tailf:info "Advertise capability to the peer";
      container orf {
        tailf:info "Advertise ORF capability to the peer";
        leaf prefix {
          tailf:info "Advertise address prefix ORF capability to this neighbor";
          type enumeration {
            enum both {
              tailf:info "Capability to RECEIVE and SEND the ORF from/to this neighbor";
            }
            enum none {
              tailf:info "No capability to RECEIVE or SEND the ORF from/to this neighbor";
            }
            enum receive {
              tailf:info "Capability to RECEIVE the ORF from this neighbor";
            }
            enum send {
              tailf:info "Capability to SEND the ORF to this neighbor";
            }
          }
        }
      }
    }
  }

  grouping bgp-neighbor-grouping {
    leaf remote-as {
      tailf:info "Specify a BGP neighbor";
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;AS of remote neighbor";
          range "1..4294967295";
        }
        type string {
          tailf:info "<1.0-XX.YY>;;AS of remote neighbor";
          pattern "[0-9]+\\.[0-9]+";
        }
      }
    }
    container local {
      tailf:info "Configure local parameter";
      container address {
        tailf:info "use configured local address for bgp peering";
        leaf ip {
          tailf:cli-drop-node-name;
          type inet:host {
            tailf:info "A.B.C.D or X:X::X;;address";
          }
        }
      }
    }
    container local-as {
      tailf:info "Specify local AS number";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice local-as-choice {
        leaf inheritance-disable {
          tailf:info "Prevent local AS from being inherited from parent";
          type empty;
        }
        case as-number-case {
          leaf as-number {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
            }
          }
          leaf no-prepend {
            tailf:info "Do not prepend local AS to announcements from this neighbor";
            type empty;
          }
          leaf replace-as {
            tailf:info "Prepend only local AS to announcements to this neighbor";
            type empty;
          }
          leaf dual-as {
            tailf:info "Dual-AS mode";
            type empty;
          }
        }
      }
    }
    uses bfd-common-parameters-grouping;
    container ebgp-multihop {
      tailf:info "Allow EBGP neighbors not on directly connected networks";
      tailf:cli-compact-syntax;
      leaf ttl-value {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;maximum hop count";
          range "1..255";
        }
      }
      leaf mpls {
        tailf:info "Disable BGP MPLS forwarding";
        type empty;
      }
    }
    container enforce-first-as {
      tailf:info "Enforce the first AS for EBGP routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Do not enforce the first AS for EBGP routes";
        type empty;
      }
    }
    container advertisement-interval {
      tailf:info "Minimum interval between sending BGP routing updates";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf seconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-600>;;time in seconds";
          range "0..600";
        }
      }
      leaf milliseconds {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0-999>;;time in milliseconds";
          range "0..999";
        }
      }
    }
    container timers {
      tailf:info "BGP per neighbor timers";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf keepalive {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint16 {
          tailf:info "<0-65535>;;Keepalive interval";
        }
      }
      leaf holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<0|3-65535>;;Holdtime (0=disable)";
        }
      }
      leaf min-holdtime {
        tailf:cli-drop-node-name;
        type uint16 {
          tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor";
        }
      }
    }
    leaf description {
      tailf:info "Neighbor specific description";
      tailf:cli-multi-value;
      tailf:cli-preformatted;
      tailf:cli-full-command;
      type string {
        tailf:info "LINE;;Up to 80 characters describing this neighbor";
      }
    }
    container password {
      tailf:info "Set a password";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands;
      leaf enc-type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum clear {
            tailf:info "Specifies an UNENCRYPTED password will follow";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED password will follow";
          }
        }
      }
      leaf password {
        tailf:cli-drop-node-name;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The password";
        }
      }
    }
    container ttl-security {
      tailf:info "Enable EBGP TTL security";
      tailf:cli-delete-when-empty;
      presence true;
      leaf inheritance-disable {
        tailf:info "Prevent ttl-security from being inherited from the parent";
        type empty;
      }
    }
    container update {
      tailf:info "BGP Update configuration";
      container in {
        tailf:info "Inbound update message handling";
        container filtering {
          tailf:info "Inbound update message filtering";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-vrf-nbr-upd-filter;
          container attribute-filter {
            tailf:info "Attribute-filter configuration";
            leaf group {
              tailf:info "Attribute-filter group configuration";
              type string {
                tailf:info "WORD;;Attribute-filter group name";
              }
            }
          }
        }
      }
    }
    container update-source {
      tailf:info "Source of routing updates";
      uses interface-name-grouping;
    }
    container ignore-connected-check {
      tailf:info "Ignore check for directly connected peer";
      presence true;
    }
    leaf cluster-id {
      tailf:info "Enter cluster id for this neighbor";
      tailf:cli-full-command;
      type union {
        type uint32 {
          tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
        }
        type inet:host {
          tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
        }
      }
    }
    container graceful-restart {
      tailf:info "Enable graceful restart support for this neighbor";
      presence true;
      leaf suppress {
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
      leaf disable {
        tailf:info "Disable graceful restart support for this neighbor";
        tailf:cli-reset-container;
        tailf:cli-full-command;
        type empty;
      }
    }
    container capability {
      tailf:info "Advertise capability to the peer";
      container suppress {
        tailf:info "Suppress advertising capability to the peer ";
        container four-byte-as {
          tailf:alt-name 4-byte-as;
          tailf:info "4-byte-as capability";
          presence true;
          leaf inheritance-disable {
            tailf:info "Prevent capability suppress 4-type-as being inherited from the parent";
            type empty;
          }
        }
      }
    }
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container mdt {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container rt-filter {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container flowspec {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
      container l2vpn {
        tailf:info "L2VPN Address Family";
        container vpls-vpws {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container evpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container mspw {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv4 {
        tailf:info "VPNv4 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv4-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container multicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container labeled-unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
        container mvpn {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
      container vpnv6 {
        tailf:info "IPv6 Address Family";
        container unicast {
          tailf:info "Address Family modifier";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-bgp-nbr-af;
          presence true;
          uses bgp-address-family-ipv6-grouping;
          uses router-bgp-neighbor-af-grouping;
        }
      }
    }
    leaf keychain {
      tailf:info "Set keychain based authentication";
      type string {
        tailf:info "WORD;;The Key Chain name";
      }
      tailf:non-strict-leafref {
        path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
          tailf:xpath-root 3;
        }
      }
    }
    container peer-group {
      tailf:info "Configure peer-group";
      tailf:cli-compact-syntax;
      tailf:cli-delete-when-empty;
      presence true;
      leaf group-name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;peer-group name";
        }
      }
    }
    container use {
      tailf:info "Inherit configuration from a group";
      leaf af-group {
        tailf:info "Inherit configuration from an af-group";
        type string {
          tailf:info "WORD;;AF-group name";
        }
      }
      leaf neighbor-group {
        tailf:info "Inherit configuration from a neighbor-group";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      leaf session-group {
        tailf:info "Inherit address-family independent config from a session-group";
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
    }
    container shutdown {
      tailf:info "Administratively shut down this neighbor";
      presence true;
    }
  }

  grouping router-bgp-vrf-grouping {
    container bfd {
      tailf:info "Configure BFD parameters";
      leaf multiplier {
        tailf:info "Detect multiplier";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<2-16>;;Detect multiplier";
          range "2..16";
        }
      }
      leaf minimum-interval {
        tailf:info "Hello interval";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<3-30000>;;hello interval in milli-seconds";
          range "3..30000";
        }
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container bgp {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf keepalive {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-65535>;;Keepalive interval";
            range "0..65535";
          }
        }
        leaf holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Holdtime (0 Disable keepalives/hold time)";
            range "0|3..65535";
          }
        }
        leaf min-neighbor-holdtime {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<3-65535>;;Minimum acceptable holdtime from neighbor (0to disable)";
            range "0|3..65535";
          }
        }
      }
    }
    container bgp {
      tailf:info "BGP specific commands";
      leaf router-id {
        tailf:info "Configure Router-id";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Manually configured router identifier";
        }
      }
      leaf cluster-id {
        tailf:info "Configure Route-Reflector Cluster-id";
        tailf:cli-full-command;
        type union {
          type uint32 {
            tailf:info "<1-4294967295>;;Route-Reflector Cluster-id as 32 bit quantity";
          }
          type inet:host {
            tailf:info "A.B.C.D;;Route-Reflector Cluster-id in IP address format";
          }
        }
      }
      leaf scan-time {
        tailf:info "Configure background scanner interval for generic scanner";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<5-3600>;;Scanner interval (seconds)";
          range "5..3600";
        }
      }
      container update-delay {
        tailf:info "Set the max initial delay for sending updates";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update-delay-value {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-3600>;;Delay value (seconds)";
            range "0..3600";
          }
        }
        leaf always {
          tailf:info "Keepalive trigger bestpath is disabled and delay is enforced";
          type empty;
        }
      }
      leaf redistribute-internal {
        tailf:info "Allow redistribution of iBGP into IGPs (dangerous)";
        type empty;
      }
      container graceful-restart {
        tailf:info "Graceful restart capability parameters";
        presence true;
        tailf:cli-display-separated;
        leaf extended {
          tailf:info "Enable Graceful-Restart Extension";
          type empty;
        }
        leaf restart-time {
          tailf:info "Set the max time needed to restart and come back up";
          type uint16 {
            tailf:info "<1-4095>;;Max time (seconds)";
            range "1..4095";
          }
        }
        leaf stalepath-time {
          tailf:info "Set the max time to hold onto restarting peer's stale paths";
          type uint16 {
            tailf:info "<1-3600>;;Delay value (seconds)";
            range "1..3600";
          }
        }
        leaf purge-time {
          tailf:info "Time before stale routes are purged.";
          type uint16 {
            tailf:info "<1-6000>;;Max time (seconds)";
            range "1..6000";
          }
        }
        leaf graceful-reset {
          tailf:info "Reset gracefully if configuration change forces a peer reset";
          type empty;
        }
      }
      container bestpath {
        tailf:info "Change default route selection criteria";
        leaf compare-routerid {
          tailf:info "Compare router-id for identical EBGP paths";
          tailf:cli-full-command;
          type empty;
        }
        container cost-community {
          tailf:info "Cost community";
          leaf ignore {
            tailf:info "Ignore cost-community comparison";
            type empty;
          }
        }
        container med {
          tailf:info "MED related";
          leaf always {
            tailf:info "Allow comparing MED from different neighbors";
            tailf:cli-full-command;
            type empty;
          }
          leaf confed {
            tailf:info "Compare MED among confederation paths";
            tailf:cli-full-command;
            type empty;
          }
          leaf missing-as-worst {
            tailf:info "Treat missing MED as the least preferred one";
            tailf:cli-full-command;
            type empty;
          }
        }
        container as-path {
          tailf:info "AS path length";
          leaf ignore {
            tailf:info "Ignore as-path length";
            type empty;
          }
        }
      }
      container log {
        tailf:info "Log bgp info";
        container neighbor {
          tailf:info "Log neighbor state info";
          leaf changes {
            tailf:info "Log neighbor up/down and reset reason";
            type enumeration {
              enum detail {
                tailf:info "Include extra detail in change messages";
              }
              enum disable {
                tailf:info "Disable logging";
              }
            }
          }
        }
      }
      container default {
        tailf:info "Configure default value";
        leaf local-preference {
          tailf:info "Local preference";
          type uint32 {
            tailf:info "<0-4294967295>;;Higher = more preferred";
          }
        }
      }
      container auto-policy-soft-reset {
        tailf:info "Enable automatic soft peer reset on policy reconfiguration";
        leaf disable {
          tailf:info "Disable automatic soft peer reset on policy reconfiguration";
          type empty;
        }
      }
      container label-delay {
        tailf:info "Specify delay for batching label processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container import-delay {
        tailf:info "Specify delay for import processing";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf seconds {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<0-10>;;Delay, seconds part";
            range "0..10";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;Delay, milliseconds part";
            range "0..999";
          }
        }
      }
      container fast-external-fallover {
        tailf:info "Immediately reset session if a link to a directly connected external peer goes down";
        leaf disable {
          tailf:info Disable;
          type empty;
        }
      }
    }
    container default-information {
      tailf:info "Control distribution of default information";
      leaf originate {
        tailf:info "Distribute a default route";
        type empty;
      }
    }
    container mpls {
      tailf:info "Enable mpls parameters";
      container activate {
        tailf:info "Enter mpls interfaces in BGP mpls activate mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-bgp-mpls;
        list interface {
          tailf:info "Interface to enable mpls";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
        }
      }
    }
    container update {
      tailf:info "BGP Update configuration";
      leaf limit {
        tailf:info "Upper bound on transient memory usage for update generation";
        type uint16 {
          tailf:info "<16-2048>;;Update limit in MegaBytes(MB); default is 512 MB";
          range "16..2048";
        }
      }
    }
    container ibgp {
      tailf:info "Set options for iBGP peers";
      container policy {
        tailf:info "Set options for route-policy";
        container out {
          tailf:info "Set options for outbound policy";
          leaf enforce-modifications {
            tailf:info "Allow policy to modify all attributes";
            type empty;
          }
        }
      }
    }
    uses bgp-address-family-grouping;
    list af-group {
      tailf:info "Specify a AF group";
      tailf:cli-mode-name config-bgp-afgrp;
      key "name address-family af-modifier";
      leaf name {
        type string {
          tailf:info "WORD;;AF group name";
        }
      }
      leaf address-family {
        tailf:info "Enter Address Family command mode";
        tailf:cli-expose-key-name;
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 Address Family";
          }
          enum ipv6 {
            tailf:info "IPv6 Address Family";
          }
          enum l2vpn {
            tailf:info "L2VPN Address Family";
          }
          enum vpnv4 {
            tailf:info "VPNv4 Address Family";
          }
          enum vpnv6 {
            tailf:info "VPNv6 Address Family";
          }
        }
      }
      leaf af-modifier {
        type enumeration {
          enum labeled-unicast {
            tailf:info "Address Family modifier";
          }
          enum mdt {
            tailf:info "Address Family modifier";
          }
          enum multicast {
            tailf:info "Address Family modifier";
          }
          enum mvpn {
            tailf:info "Address Family modifier";
          }
          enum rt-filter {
            tailf:info "Address Family modifier";
          }
          enum tunnel {
            tailf:info "Address Family modifier";
          }
          enum unicast {
            tailf:info "Address Family modifier";
          }
          enum vpls-vpws {
            tailf:info "Address Family modifier";
          }
        }
      }
      uses router-bgp-neighbor-af-grouping;
    }
    list neighbor-group {
      tailf:info "Specify a Neighbor-group";
      tailf:cli-mode-name config-bgp-nbrgrp;
      key name;
      leaf name {
        tailf:info "Neighbor-group name";
        type string {
          tailf:info "WORD;;Neighbor-group name";
        }
      }
      uses bgp-neighbor-grouping;
    }
    list neighbor {
      tailf:info "Specify a neighbor router";
      tailf:cli-mode-name config-bgp-nbr;
      key id;
      leaf id {
        type union {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Neighbor address";
          }
          type inet:ipv6-address {
            tailf:info "X:X:X:X::X;;Neighbor IPv6 address";
          }
        }
      }
      leaf activate {
        tailf:cli-hide-in-submode;
        type empty;
      }
      uses bgp-neighbor-grouping;
    }
    container socket {
      tailf:info "set socket parameters";
      container receive-buffer-size {
        tailf:info "socket receive buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<512-131072>;;Receive socket buffer size in bytes";
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "BGP Read buffer size in bytes";
            range "512..131072";
          }
        }
      }
      container send-buffer-size {
        tailf:info "socket send buffer size";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf socket-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
        leaf bgp-size {
          tailf:cli-drop-node-name;
          type uint32 {
            range "512..131072";
          }
        }
      }
    }
  }

  grouping router-bgp-grouping {
    container nsr {
      tailf:info "Enable non-stop-routing support for all neighbors";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable non-stop-routing support for all neighbors";
        type empty;
      }
    }
    uses router-bgp-vrf-grouping;
    list session-group {
      tailf:info "Specify a Session group";
      tailf:cli-mode-name config-bgp-sngrp;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session group name";
        }
      }
      leaf remote-as {
        tailf:info "Set remote AS";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
        }
      }
      container use {
        tailf:info "Inherit configuration from a group";
        leaf session-group {
          tailf:info "Inherit address-family independent config from a session-group";
          type string {
            tailf:info "WORD;;Session group name";
          }
        }
      }
      container ebgp-multihop {
        tailf:info "Allow EBGP neighbors not on directly connected networks";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf ttl-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;maximum hop count";
          }
        }
        leaf mpls {
          tailf:info "Disable BGP MPLS forwarding";
          type empty;
        }
      }
      container advertisement-interval {
        tailf:info "Minimum interval between sending BGP routing updates";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf seconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-600>;;time in seconds";
            range "0..600";
          }
        }
        leaf milliseconds {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-999>;;time in milliseconds";
            range "0..999";
          }
        }
      }
      container local-as {
        tailf:info "Specify a local-as number";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice local-as-choice {
          case a {
            leaf inheritance-disable {
              tailf:info "Prevent local AS from being inherited from parent";
              type empty;
            }
          }
          case b {
            leaf as-number {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
              }
            }
            leaf no-prepend {
              tailf:info "Do not prepend local AS to announcements from this neighbor";
              type empty;
            }
            leaf replace-as {
              tailf:info "Prepend only local AS to announcements to this neighbor";
              type empty;
            }
            leaf dual-as {
              tailf:info "Dual-AS mode";
              type empty;
            }
          }
        }
      }
      container password {
        tailf:info "Set a password";
        choice password-choice {
          leaf clear {
            tailf:info "Specifies an unencrypted password will follow";
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
            }
          }
          leaf encrypted {
            tailf:info "Specifies an encrypted password will follow";
            type string {
              tailf:info "WORD;;The ENCRYPTED neighbor password string";
            }
          }
          leaf inheritance-disable {
            tailf:info "Prevent password from being inherited from parent";
            type empty;
          }
        }
      }
      leaf description {
        tailf:info "Neighbor specific description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Up to 80 characters describing this neighbor";
        }
      }
      container update-source {
        tailf:info "Source of routing updates";
        uses interface-name-grouping;
      }
      leaf session-open-mode {
        tailf:info "Establish BGP session using this TCP open mode";
        type enumeration {
          enum active-only {
            tailf:info "Active only";
          }
          enum both {
            tailf:info "Prevent session-open-mode being inherited from the parent";
          }
          enum passive-only {
            tailf:info "Passive only";
          }
        }
      }
      leaf send-buffer-size {
        tailf:info "Set socket and BGP send buffer size";
        type uint32 {
          tailf:info "<4096-131072>;;Send socket buffer size in bytes";
        }
      }
      leaf receive-buffer-size {
        tailf:info "Set socket and BGP receive buffer size";
        type uint32 {
          tailf:info "<512-131072>;;Receive socket buffer size in bytes";
        }
      }
      uses bfd-common-parameters-grouping;
    }
    list vrf {
      tailf:info "Specify a vrf name";
      tailf:cli-mode-name config-bgp-vrf;
      key name;
      leaf name {
        tailf:info "VRF name";
        type string {
          tailf:info "WORD;;VRF name - maximum length 32 characters";
        }
      }
      leaf rd {
        tailf:info "route distinguisher";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
        }
      }
      leaf label-allocation-mode {
        tailf:info "Set MPLS/VPN label allocation mode";
        tailf:cli-full-command;
        type enumeration {
          enum per-ce {
            tailf:info "Set per CE label mode";
          }
          enum per-vrf {
            tailf:info "Set per VRF label mode";
          }
        }
      }
      container label {
        leaf mode {
          tailf:info "Select label mode";
          type enumeration {
            enum per-ce {
              tailf:info "Set per CE label mode";
            }
            enum per-vrf {
              tailf:info "Set per VRF label mode";
            }
          }
        }
      }
      uses router-bgp-vrf-grouping;
    }
  }

  grouping police-set-grouping {
    leaf atm-clp {
      tailf:info "Set atm cell-loss-priority bit";
      tailf:cli-full-command;
      type empty;
    }
    container cos {
      tailf:info "Set Class Of Service values";
      leaf cos-value {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
      leaf inner {
        tailf:info "COS inner value";
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-7>;;COS value";
          range "0..7";
        }
      }
    }
    leaf dei {
      tailf:info "Set DEI";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-1>;;DEI value";
        range "0..1";
      }
    }
    leaf discard-class {
      tailf:info "Set discard-class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;Discard Class value";
        range "0..63";
      }
    }
    container dscp {
      tailf:info "Set IP DSCP (DiffServ CodePoint)";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type dscp-type;
      }
      leaf tunnel {
        tailf:info "Set DSCP Tunnel(for ipsec tunnels)";
        tailf:cli-full-command;
        type dscp-type;
      }
    }
    leaf fr-de {
      tailf:info "Set FR DE value";
      tailf:cli-full-command;
      type enumeration {
        enum 1 {
          tailf:info "<1-1>;;FR DE value";
        }
      }
    }
    container mpls {
      tailf:info "Set MPLS specific values";
      container experimental {
        tailf:info "Set Experimental value";
        leaf imposition {
          tailf:info "Set Experimental value at tag imposition";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
        leaf topmost {
          tailf:info "Set Experimental value on topmost label";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-7>;;Experimental value";
            range "0..7";
          }
        }
      }
    }
    container precedence {
      tailf:info "Set IP Precedence";
      leaf outer {
        tailf:cli-drop-node-name;
        tailf:cli-full-command;
        type precedence-type;
      }
      leaf tunnel {
        tailf:info "Set Precedence tunnel (for ipsec tunnels)";
        tailf:cli-full-command;
        type precedence-type;
      }
    }
    leaf qos-group {
      tailf:info "Set qos-group";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-63>;;QoS group value";
        range "0..63";
      }
    }
    leaf forward-class {
      tailf:info "Set forward class";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-7>;;Forward class value";
        range "1..7";
      }
    }
    leaf srp-priority {
      tailf:info "Set SRP priority";
      type uint8 {
        tailf:info "<0-7>;;SRP priority value";
        range "0..7";
      }
    }
  }

  grouping police-action-grouping {
    leaf child-conform-aware {
      tailf:cli-break-sequence-commands;
      tailf:info "Enable coupled policing";
      type empty;
    }
    container conform-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container exceed-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
    container violate-action {
      tailf:info "Action for conforming traffic";
      leaf drop {
        tailf:info "Drop packet";
        tailf:cli-full-command;
        type empty;
      }
      container set {
        tailf:info "Conditional marking";
        uses police-set-grouping;
      }
      leaf transmit {
        tailf:info "Transmit packet";
        tailf:cli-full-command;
        type empty;
      }
    }
  }

  grouping policy-map-class-grouping {
    leaf type {
      tailf:info "The type of classmap";
      tailf:cli-prefix-key;
      type enumeration {
        enum traffic {
          tailf:info "Traffic classmap";
        }
      }
    }
    leaf drop {
      tailf:info "Drop the packet";
      type empty;
    }
    container redirect {
      tailf:info "Configure PBF redirect feature";
      container nexthop {
        tailf:info "Forward to specified nexthop";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf vrf {
          tailf:info "Enter specific VRF Name for this nexthop";
          tailf:cli-optional-in-sequence;
          type vrf-type;
        }
        choice nexthop-choice {
          leaf IPv4-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Input IPv4 Nexthop address";
            }
          }
          leaf IPv6-address {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "X:X::X%zone;;Input IPv6 Nexthop address";
            }
          }
          leaf route-target {
            tailf:info "Enter specific route-target string";
            type string {
              tailf:info "WORD;;IPAddress:index or 2-byte ASN or 4-byte ASN";
            }
          }
        }
      }
    }
    container shape {
      tailf:info "Configure shaping for this class";
      container average {
        tailf:info "Average rate shaping";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        choice average-choice {
          case percent-case {
            leaf percent {
              tailf:info "Configure shape rate in percentage";
              type uint8 {
                tailf:info "<1-100>;;Shape rate as percentage of available bandwidth";
                range "1..100";
              }
            }
          }
          case unit-case {
            leaf rate {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint32 {
                tailf:info "<1-4294967295>;;Shape rate";
                range "1..4294967295";
              }
            }
            leaf rate-unit {
              tailf:cli-drop-node-name;
              type enumeration {
                enum bps {
                  tailf:info "Bits per second (default)";
                }
                enum cellsps {
                  tailf:info "Cells per second";
                }
                enum gbps {
                  tailf:info "Gigabits per second";
                }
                enum kbps {
                  tailf:info "Kilobits per second";
                }
                enum mbps {
                  tailf:info "Megabits per second";
                }
              }
            }
          }
        }
        leaf burst {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Excess burst size";
            range "1..4294967295";
          }
        }
        leaf burst-unit {
          tailf:cli-drop-node-name;
          type union {
            type police-burst-units-type;
            type enumeration {
              enum cells {
                tailf:info Cells;
              }
            }
          }
        }
      }
    }
    container bandwidth {
      tailf:info "Configure bandwidth for this class";
      container bandwidth-units {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf rate {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Bandwidth value";
          }
        }
        leaf units {
          tailf:cli-drop-node-name;
          type police-rate-units-type;
        }
      }
      leaf percent {
        tailf:info "configure a percentage bandwidth";
        type percentage-type;
      }
      container remaining {
        tailf:info "Allocate left over bandwidth";
        leaf percent {
          tailf:info "Allocate remaining bandwidth as percentage";
          type percentage-type;
        }
        leaf ratio {
          tailf:info "Allocate remaining bandwidth as a ratio";
          type uint16 {
            tailf:info "<1-1020>;;Bandwidth ratio";
            range "1..1020";
          }
        }
      }
    }
    choice police-choice {
      case police-rate-unit-case {
        container police-rate-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            container rate {
              tailf:info "Committed Information Rate";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-pmap-c-police;
              tailf:cli-flatten-container;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice rate-choice {
                case units-case {
                  leaf cir {
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    tailf:cli-incomplete-command;
                    type uint64 {
                      tailf:info "<1-4294967295>;;Committed Information Rate";
                    }
                  }
                  leaf cir-unit {
                    tailf:cli-no-keyword;
                    tailf:cli-drop-node-name;
                    tailf:cli-hide-in-submode;
                    type police-rate-units-type;
                  }
                }
                case percent-case {
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    tailf:cli-hide-in-submode;
                    type uint8 {
                      tailf:info "<1-100>;;Committed Information Rate in percentage of link bandwidth";
                      range "1..100";
                    }
                  }
                }
              }
              leaf burst {
                tailf:info "Burst size (BC)";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<1-4294967295>;;Burst size (BC)";
                  range "1..4294967295";
                }
              }
              leaf burst-units {
                when "../burst" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              leaf peak-rate {
                tailf:info "Peak Information Rate";
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type uint64 {
                  tailf:info "WORD;;Peak-rate value in range 1-10,000,000,000";
                  range "1..10000000000";
                }
              }
              leaf peak-rate-units {
                when "../peak-rate" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-rate-units-type;
              }
              container peak-rate-percent {
                when "not(../peak-rate)" {
                  tailf:xpath-root 3;
                  tailf:dependency "../peak-rate";
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                container peak-rate {
                  tailf:cli-flatten-container;
                  leaf percent {
                    tailf:info "Percent of the link bandwidth";
                    type percentage-type;
                  }
                }
              }
              leaf peak-burst {
                tailf:info "Excess Burst size (BE)";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<1-4294967295>;;Excess burst size (BE)";
                }
              }
              leaf peak-burst-units {
                when "../peak-burst" {
                  tailf:xpath-root 3;
                }
                tailf:cli-no-keyword;
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                tailf:cli-hide-in-submode;
                type police-burst-units-type;
              }
              uses police-action-grouping;
            }
          }
        }
      }
      case police-unit-case {
        container police-unit {
          tailf:cli-no-keyword;
          tailf:cli-drop-node-name;
          container police {
            tailf:info "Police traffic";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-pmap-c-police;
            tailf:cli-flatten-container;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf cir {
              tailf:info "Committed information rate";
              tailf:cli-hide-in-submode;
              type uint32 {
                range "8000..2000000000";
                tailf:info "<8000-2000000000>;;Bits per second";
              }
            }
            leaf bc {
              tailf:info "Conform burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            leaf be {
              tailf:info "Excess burst";
              tailf:cli-hide-in-submode;
              tailf:cli-optional-in-sequence;
              type uint32 {
                range "1000..512000000";
                tailf:info "<1000-512000000>;;Burst bytes";
              }
            }
            uses police-action-grouping;
          }
        }
      }
    }
    container set {
      tailf:info "Configure marking for this class";
      uses police-set-grouping;
    }
    container priority {
      tailf:info "Assign priority to this class";
      leaf level {
        tailf:info "Configure a priority level";
        type uint8 {
          tailf:info "<1-3>;;Priority level";
          range "1..3";
        }
      }
    }
    container queue-limit {
      tailf:info "Configure queue-limit (taildrop threshold) for this class";
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      leaf queue-limit-value {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type uint32 {
          tailf:info "<1-4294967295>;;Max Threshold for tail drop";
          range "1..4294967295";
        }
      }
      leaf queue-limit-unit {
        tailf:cli-no-keyword;
        tailf:cli-drop-node-name;
        type enumeration {
          enum bytes {
            tailf:info Bytes;
          }
          enum kbytes {
            tailf:info Kilobytes;
          }
          enum mbytes {
            tailf:info Megabytes;
          }
          enum ms {
            tailf:info Milliseconds;
          }
          enum packets {
            tailf:info "Packets (default)";
          }
          enum us {
            tailf:info Microseconds;
          }
        }
      }
    }
    container service-function-path {
      tailf:info "Configure NSH service function action";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf id {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint32 {
          tailf:info "<1-16777215>;;Service function path id";
          range "1..16777215";
        }
      }
      leaf index {
        tailf:info "Specify service path index";
        type uint8 {
          tailf:info "<1-255>;;Service function path index";
          range "1..255";
        }
      }
      leaf metadata {
        tailf:info "service-function metadata";
        type string {
          tailf:info "WORD;;Specify metadata name";
        }
      }
    }
    container service-policy {
      tailf:info "Configure a child service policy";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum accounting {
            tailf:info "Accounting policymap";
          }
          enum control {
            tailf:info "Control policy-map";
          }
          enum none {
            tailf:info "Untyped policymap";
          }
          enum pbr {
            tailf:info "PBR policymap";
          }
          enum performance-traffic {
            tailf:info "Realtime Application Flow Monitoring policymap";
          }
          enum qos {
            tailf:info "QoS policymap (default)";
          }
          enum redirect {
            tailf:info "Redirect policymap";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf name {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;Name of the child service policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
            tailf:xpath-root 3;
          }
        }
      }
    }
    container random-detect {
      tailf:info "Enable Random Early Detection";
      leaf default {
        tailf:info "Enable RED with default min and max thresholds";
        tailf:cli-full-command;
        type empty;
      }
      list cos {
        tailf:info "COS based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;COS value";
          }
        }
        uses class-random-detect-grouping;
      }
      list dei {
        tailf:info "DEI based WRED";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-1>;;DEI value";
          }
        }
        uses class-random-detect-grouping;
      }
      list dscp {
        tailf:info "DSCP based WRED (upto 8 values or ranges)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info
              "<0-63>;;Differentiated services codepoint value
               af11,af12,af13,af21,af22,af23,af31,af32,af33,af41,af42,af43
               cs1-cs7,default,ef and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      list exp {
        tailf:info "MPLS Experimental value based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "<0-7>;;MPLS Experimental valueand ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      list precedence {
        tailf:info "Precedence based WRED (upto 8 values)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info
              "<0-7>;;Precedence value
               critical,flash,flash-override,immediate,
               internet,network,priority,routine and ',' for ranges";
          }
        }
        uses class-random-detect-grouping;
      }
      list discard-class {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        key name;
        leaf name {
          type uint8 {
            tailf:info "<0-7>;;Discard Class  value";
            range "0..7";
          }
        }
        uses class-random-detect-grouping;
      }
      container default-values {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses class-random-detect-grouping;
      }
    }
  }

  grouping performance-mgmt-grouping {
    choice case-choice {
      container AverageCpuUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
      container AverageCPUUsed {
        tailf:info "Average %CPU utilization";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        uses average-cpu-used-grouping;
      }
    }
    leaf sample-size {
      tailf:info "Number of samples to be taken";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Number of samples";
        range "1..60";
      }
    }
    leaf sample-interval {
      tailf:info "Frequency of sampling in minutes";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-60>;;Frequency of samples";
        range "1..60";
      }
    }
  }

  grouping ipv4-ipv6-common-grouping {
    leaf conflict-policy {
      tailf:info "ip address conflict algorithm selection";
      tailf:cli-full-command;
      type enumeration {
        enum highest-ip {
          tailf:info "Keeps the highest ip address in the conflict set UP";
        }
        enum longest-prefix {
          tailf:info "Keeps the longest prefix match in the conflict set UP";
        }
        enum static {
          tailf:info "Keeps the existing interface UP across new address configs";
        }
      }
    }
    list prefix-list {
      tailf:info "Prefix-list command";
      tailf:cli-mode-name config-ipv_pfx;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Name of a prefix list - maximum 32 characters";
          length "1..32";
        }
      }
      list rule {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-2147483646>;;Sequence number";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          type string {
            tailf:info
              "deny;;Specify packets to reject
               permit;;Specify packets to forward
               remark;;Comment for access list";
            pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
          }
        }
      }
    }
  }

  grouping arp-grouping {
    list arp-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key address;
      leaf address {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf mac {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type string {
          tailf:info "H.H.H;;MAC address";
          pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
        }
      }
      leaf type {
        tailf:cli-drop-node-name;
        type enumeration {
          enum ARPA {
            tailf:info "Encapsulation type ARPA";
          }
          enum SRP {
            tailf:info "Encapsulation type SRP";
          }
          enum SRPA {
            tailf:info "Encapsulation type SRPA";
          }
          enum SRPB {
            tailf:info "Encapsulation type SRPB";
          }
        }
      }
      leaf alias {
        tailf:info "Configure an Alias ARP entry";
        type empty;
      }
    }
  }

  grouping tftp-server-grouping {
    list tftp-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "Global ipv4 specific TFTP server commands";
          }
          enum ipv6 {
            tailf:info "Global ipv6 specific TFTP server commands";
          }
        }
      }
      leaf server {
        tailf:info "TFTP server configuration commands";
        tailf:cli-incomplete-command;
        type empty;
      }
      leaf homedir {
        tailf:info "Home directory for TFTP server";
        type string {
          tailf:info "WORD;;Name of home directory (e.g. disk0:)";
        }
      }
      leaf max-servers {
        tailf:cli-break-sequence-commands;
        tailf:info "Set maximum number of concurrent tftp servers";
        type union {
          type uint32 {
            tailf:info "<1-2147483647>;;Set number of allowable tftp server processes";
            range "1..2147483647";
          }
          type enumeration {
            enum no-limit {
              tailf:info "No limit to number of allowable tftp server processes";
            }
          }
        }
      }
      leaf access-list {
        tailf:info "Access list for TFTP server";
        type string {
          tailf:info "WORD;;Name of access list";
        }
      }
    }
  }

  grouping telnet-server-grouping {
    list telnet-server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-incomplete-command;
      tailf:cli-compact-syntax;
      key af;
      leaf af {
        type enumeration {
          enum ipv4 {
            tailf:info "IPv4 configuration";
          }
          enum ipv6 {
            tailf:info "IPv6 configuration";
          }
        }
      }
      leaf dscp {
        tailf:info dscp;
        tailf:cli-full-command;
        type uint8 {
          tailf:info "<0-63>;;dscp value";
        }
      }
      container server {
        tailf:info "Telnet server configuration commands";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf max-servers {
          tailf:info "Set number of allowable telnet sessions";
          type uint8 {
            tailf:info "<1-100>;;Set number of allowable telnet sessions";
            range "1..100";
          }
        }
        leaf access-list {
          tailf:info "Access list for telnet server";
          type string {
            tailf:info "WORD;;Name of access list";
          }
        }
      }
    }
  }

  grouping ntp-server-grouping {
    list server-list {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-disallow-value vrf;
        type inet:host {
          tailf:info "Hostname or A.B.C.D or X:X::X;;Peer/server address";
        }
      }
      leaf ip-version {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum ipv4 {
            tailf:info "Specify IPv4 address or hostname";
          }
          enum ipv6 {
            tailf:info "Specify IPv6 address or host name";
          }
        }
      }
      leaf version {
        tailf:info "Configure NTP version";
        type uint8 {
          tailf:info "<1-4>;;NTP version number";
          range "1..4";
        }
      }
      leaf minpoll {
        tailf:info "Configure minimum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Minimum poll rate, default 6, less than maxpoll";
          range "4..17";
        }
      }
      leaf maxpoll {
        tailf:info "Configure maximum polling rate";
        type uint8 {
          tailf:info "<4-17>;;Maximum poll rate, default 10, greater than minpoll";
          range "4..17";
        }
      }
      leaf prefer {
        tailf:info "Prefer this peer when possible";
        type empty;
      }
      leaf burst {
        tailf:info "Use burst mode";
        type empty;
      }
      leaf iburst {
        tailf:info "Use initial burst mode";
        type empty;
      }
      container source {
        tailf:info "Interface for source address";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf key {
        tailf:info "Configure peer authentication key";
        type uint16 {
          tailf:info "<1-65535>;;Peer key number";
          range "1..65535";
        }
      }
    }
  }

  grouping router-static-options-grouping {
    leaf bfd {
      tailf:info "Configure BFD paramenters";
      type enumeration {
        enum fast-detect {
          tailf:info "Enable Fast detection";
        }
      }
    }
    leaf minimum-interval {
      when "../bfd" {
        tailf:xpath-root 3;
      }
      tailf:info "Hello interval";
      type uint16 {
        tailf:info "<3-30000>;;interval in milli-seconds";
        range "3..30000";
      }
    }
    leaf multiplier {
      when "../bfd" {
        tailf:xpath-root 3;
      }
      tailf:info "Detect multiplier";
      type uint8 {
        tailf:info "<1-10>;;Detect multiplier";
        range "1..10";
      }
    }
    choice metric-choice {
      leaf metric {
        tailf:info "Distance metric for this route";
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-254>;;Distance metric for this route";
          range "1..254";
        }
      }
      container metric2 {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf metric {
          tailf:info "Set metric for this route";
          type uint32 {
            tailf:info "<1-16777214>;;Set metric for this route";
            range "1..16777214";
          }
        }
      }
    }
    leaf tag {
      tailf:info "Set tag for this route";
      type uint32 {
        tailf:info "<1-4294967295>;;Set tag for this route";
      }
    }
    leaf permanent {
      tailf:info "Permanent route";
      type empty;
    }
    leaf vrflabel {
      tailf:info "VRF label";
      type uint32 {
        tailf:info "<0-4294967295>;;VRF label";
      }
    }
    leaf tunnel-id {
      tailf:info "Tunnel ID";
      type uint32 {
        tailf:info "<0-4294967295>;;Tunnel ID";
      }
    }
    leaf description {
      tailf:info "description of the static route";
      type string {
        tailf:info "WORD;;short description of static route";
      }
    }
  }

  grouping router-static-grouping {
    container maximum {
      tailf:info "Limit the number of static paths which may be configured";
      container path {
        tailf:info "Limit the number of static paths which may be configured";
        leaf ipv4 {
          tailf:info "IPv4 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
        leaf ipv6 {
          tailf:info "IPv6 commands";
          type uint32 {
            tailf:info "<1-140000>;;The maximum number of static paths which can be configured";
            range "1..140000";
          }
        }
      }
    }
    container address-family {
      tailf:info "Static route address family configuration subcommands";
      container ipv4 {
        tailf:info "IPv4 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-static-afi;
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type ipv4-prefix {
                tailf:info "A.B.C.D/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 commands";
        container unicast {
          tailf:info "Unicast commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-static-afi;
          list routes {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-ip {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-if {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-ip-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf address";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf address {
              tailf:info "Forwarding router's address";
              type inet:ipv6-address {
                tailf:info "X:X::X;;Forwarding router's address";
              }
            }
            uses router-static-options-grouping;
          }
          list routes-if-vrf {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            key "net vrf interface";
            leaf net {
              tailf:info "Destination prefix";
              type tailf:ipv6-address-and-prefix-length {
                tailf:info "X:X::X/length;;Destination prefix";
              }
            }
            leaf vrf {
              tailf:info "Destination VRF";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "WORD;;Destination VRF";
              }
            }
            leaf interface {
              tailf:info "Interface Name";
              tailf:cli-disallow-value vrf;
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            uses router-static-options-grouping;
          }
        }
      }
    }
  }

  grouping router-igmp-grouping {
    list interface {
      tailf:info "IGMP interface configuration subcommands";
      tailf:cli-mode-name config-igmp-default-if;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface Name";
        }
      }
      container explicit-tracking {
        tailf:info "IGMPv3 explicit host tracking";
        presence true;
      }
      leaf version {
        tailf:info "IGMP version";
        type uint8 {
          tailf:info "<1-3>;;version number";
        }
      }
      leaf router {
        tailf:info "Enable/Disable Router side functionality in IGMP";
        type enumeration {
          enum disable {
            tailf:info "Disable Router side functionality in IGMP";
          }
          enum enable {
            tailf:info "Enable Router side functionality in IGMP";
          }
        }
      }
      list join-group {
        tailf:info "IGMP join multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        choice source-choice {
          leaf source-address {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to include";
            }
          }
          leaf exclude {
            tailf:info "Exclude the only following source address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Source address to exclude";
            }
          }
        }
      }
      list static-group {
        tailf:info "IGMP static multicast group";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key address;
        leaf address {
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP group address";
          }
        }
        leaf source-address {
          tailf:cli-drop-node-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Source address to join";
          }
        }
      }
    }
    container explicit-tracking {
      tailf:info "IGMPv3 explicit host tracking";
      presence true;
    }
    leaf version {
      tailf:info "IGMP version";
      type uint8 {
        tailf:info "<1-3>;;version number";
        range "1..3";
      }
    }
    leaf access-group {
      tailf:info "IGMP group access group";
      type string {
        tailf:info "WORD;;IP Named Standard Access list";
      }
    }
    leaf query-interval {
      tailf:info "IGMP host query interval";
      type uint16 {
        tailf:info "<1-3600>;;Query interval in seconds";
        range "1..3600";
      }
    }
    leaf query-max-response-time {
      tailf:info "IGMP max query response value";
      type uint8 {
        tailf:info "<1-12>;;query response value in seconds";
        range "1..12";
      }
    }
    leaf robustness-count {
      tailf:info "IGMP robustness variable";
      type uint8 {
        tailf:info "<2-10>;;Robustness variable count";
        range "2..10";
      }
    }
  }

  grouping key-grouping {
    leaf encryption {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      tailf:cli-optional-in-sequence;
      type enumeration {
        enum 0 {
          tailf:info "Specifies an UNENCRYPTED key will follow";
        }
        enum 7 {
          tailf:info "Specifies an ENCRYPTED key will follow";
        }
      }
    }
    leaf key {
      tailf:cli-drop-node-name;
      tailf:cli-reset-container;
      tailf:cli-disallow-value 0|7;
      tailf:meta-data secret-password;
      type string {
        tailf:info "LINE;;The UNENCRYPTED key";
      }
    }
  }

  grouping l2vpn-bridge-domain-mac-grouping {
    container learning {
      tailf:info "MAC learning";
      tailf:cli-delete-when-empty;
      presence true;
      leaf disable {
        tailf:info "Disable MAC learning";
        type empty;
      }
    }
    container limit {
      tailf:info "MAC-Limit configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-l2vpn-bg-bd-ac-mac-limit;
      leaf maximum {
        tailf:info "Number of MAC addresses after which MAC limit action is taken";
        type uint32 {
          tailf:info "<1-512000>;;Number of MAC addresses after which MAC limit action is taken";
          range "1..512000";
        }
      }
      leaf action {
        tailf:info "MAC address limit enforcement action";
        type enumeration {
          enum flood {
            tailf:info "Stop learning but continue flooding";
          }
          enum no-flood {
            tailf:info "Stop learning and stop flooding";
          }
          enum none {
            tailf:info "No action";
          }
          enum shutdown {
            tailf:info "Stop forwarding";
          }
        }
      }
      leaf notification {
        tailf:info "MAC address limit notification action";
        type enumeration {
          enum both {
            tailf:info "Generate syslog message and SNMP trap";
          }
          enum none {
            tailf:info "No notification";
          }
          enum syslog {
            tailf:info "Generate syslog message";
          }
          enum trap {
            tailf:info "Generate SNMP trap";
          }
        }
      }
    }
    container secure {
      tailf:info "MAC Secure configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-l2vpn-bg-bd-mac-secure;
      leaf action {
        tailf:info "MAC secure enforcement action";
        type enumeration {
          enum none {
            tailf:info "Forward the violating packet and allow the MAC to be relearned";
          }
          enum shutdown {
            tailf:info "Shutdown the violating bridge port";
          }
        }
      }
      leaf logging {
        tailf:info "Enable Logging";
        type empty;
      }
    }
  }

  grouping freqsync-quality-grouping {
    choice quality-type {
      leaf exact {
        tailf:info "Specify the exact QL value to use";
        type empty;
      }
      leaf highest {
        tailf:info "Specify the highest acceptable QL value";
        type empty;
      }
      leaf lowest {
        tailf:info "Specify the lowest acceptable QL value";
        type empty;
      }
    }
    container itu-t {
      tailf:info "ITU-T QL options";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf option {
        tailf:info "ITU-T QL options";
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2";
          }
        }
      }
      leaf generation {
        tailf:info "ITU-T QL option 2 generation";
        tailf:cli-incomplete-command;
        when "../option = '2'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum 1 {
            tailf:info "ITU-T QL option 2, generation 1";
          }
          enum 2 {
            tailf:info "ITU-T QL option 2, generation 2";
          }
        }
      }
      leaf ql1 {
        tailf:cli-drop-node-name;
        when "../option = '1'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum PRC;
          enum SSU-A;
          enum SSU-B;
          enum SEC;
          enum DNU;
        }
      }
      leaf ql2 {
        tailf:cli-drop-node-name;
        when "../option = '2'" {
          tailf:xpath-root 3;
        }
        type enumeration {
          enum DUS {
            tailf:info "This signal should not be used for synchronization";
          }
          enum PRS {
            tailf:info "ITU-T Option 2, Primary reference source";
          }
          enum SMC {
            tailf:info "ITU-T Option 2, SONET clock self timed";
          }
          enum ST2 {
            tailf:info "ITU-T Option 2, Stratum 2";
          }
          enum ST3 {
            tailf:info "ITU-T Option 2, Stratum 3";
          }
          enum ST3E {
            tailf:info "ITU-T Option 2, Stratum 3E";
          }
          enum STU {
            tailf:info "ITU-T Option 2, Synchronized - traceability unknown";
          }
          enum TNC {
            tailf:info "ITU-T Option 2, Transit node clock";
          }
          enum ST4;
          enum PROV;
        }
      }
    }
  }

  grouping router-hsrp-group-grouping {
    leaf name {
      tailf:info "MGO session name";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;MGO session name";
      }
    }
    leaf authentication {
      tailf:info "Authentication string";
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Authentication string";
      }
    }
    container timers {
      tailf:info "Set hello and hold timers";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      container hello {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hello-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hello time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify hellotime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Hellotime in msecs";
              range "100..3000";
            }
          }
        }
      }
      container hold {
        tailf:cli-drop-node-name;
        tailf:cli-flatten-container;
        choice hold-timer-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;hold time in seconds";
              range "1..255";
            }
          }
          leaf msec {
            tailf:info "Specify holdtime in milliseconds";
            type uint16 {
              tailf:info "<100-3000>;;Holdtime in msecs";
              range "100..3000";
            }
          }
        }
      }
    }
    leaf mac-address {
      tailf:info "Use specified mac address for the virtual router";
      tailf:cli-full-command;
      type string {
        tailf:info "H.H.H;;48-bit hardware address of ARP entry";
      }
    }
    container preempt {
      tailf:info "Force active if higher priority";
      tailf:cli-delete-when-empty;
      presence true;
      leaf delay {
        tailf:info "Wait before preempting";
        type uint16 {
          tailf:info "<0-3600>;;Number of seconds to delay";
          range "0..3600";
        }
        default 0;
      }
    }
    leaf priority {
      tailf:info "Priority level";
      type uint8 {
        tailf:info "<0-255>;;Priority value";
      }
    }
    list track {
      tailf:info "Configure tracking";
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      key name;
      leaf name {
        type ifname;
      }
      leaf priority-decrement {
        tailf:cli-drop-node-name;
        type uint8 {
          tailf:info "<1-255>;;Priority decrement";
          range "1..255";
        }
        default 10;
      }
    }
    container bfd {
      tailf:info "Configure BFD parameters";
      container fast-detect {
        tailf:info "Enable Fast detection";
        tailf:cli-delete-when-empty;
        presence true;
        container peer {
          tailf:info "Information about HSRP peer for BFD monitoring";
          container ipv4 {
            tailf:info "BFD peer interface IPv4 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv4-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
          container ipv6 {
            tailf:info "BFD peer interface IPv6 address";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf ipv6-address {
              tailf:cli-drop-node-name;
              type inet:ipv6-address {
                tailf:info "X:X::X;;HSRP BFD remote interface IP address";
              }
            }
            container interface {
              tailf:cli-drop-node-name;
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              uses interface-name-grouping;
            }
          }
        }
      }
    }
  }

  grouping router-hsrp-ipv4-group-grouping {
    leaf address {
      tailf:info "Enable hot standby protocol for IP";
      type union {
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Hot standby IP address";
        }
        type enumeration {
          enum learn {
            tailf:info "Learn virtual IP address from peer";
          }
        }
      }
    }
    uses router-hsrp-group-grouping;
  }

  grouping router-hsrp-ipv6-group-grouping {
    uses router-hsrp-group-grouping;
    container address {
      tailf:info "Enable hot standby protocol for IP";
      leaf-list global {
        tailf:info "Global HSRP IPv6 address";
        tailf:cli-list-syntax;
        type inet:ipv6-address {
          tailf:info "X:X::X;;Set Global HSRP IPv6 address";
        }
      }
      container linklocal {
        tailf:info "HSRP IPv6 linklocal address";
        choice linklocal-choice {
          leaf address {
            tailf:cli-drop-node-name;
            type inet:ipv6-address {
              tailf:info "X:X::X;;HSRP IPv6 linklocal address";
            }
          }
          container autoconfig {
            tailf:info "Autoconfigure the HSRP IPv6 linklocal address";
            tailf:cli-delete-when-empty;
            presence true;
            leaf legacy-compatible {
              tailf:info "Autoconfigure for Legacy compatibility (with IOS/NX-OS)";
              type empty;
            }
          }
        }
      }
    }
  }

  grouping interface-atm-grouping {
    container atm {
      tailf:info "Global ATM interface configuration subcommands";
      container mcpt-timers {
        tailf:info "Configure Maximum cell Packing Timeout Values";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf timer-1 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer1 value in microsecond (CEoP min value is 101)";
            range "50..4095";
          }
        }
        leaf timer-2 {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<50-4095>;;MCPT timer2 value in microsecond";
            range "50..4095";
          }
        }
        leaf timer-3 {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<60-4095>;;MCPT timer3 value in microsecond";
            range "60..4095";
          }
        }
      }
      container ilmi-keepalive {
        tailf:info "ILMI keepalive configuration";
        presence true;
      }
    }
    list pvc {
      tailf:info "Configure a pvc on this interface";
      tailf:cli-mode-name config-atm-l2transport-pvc;
      key vpi-vci;
      leaf vpi-vci {
        type string {
          tailf:info "WORD;;VPI/VCI";
        }
      }
      uses interface-service-policy-grouping;
      container shape {
        tailf:info "ATM Traffic Shaping";
        container vbr-nrt {
          tailf:info "Variable Bit Rate - Non Real Time";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf peak-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Peak output rate in kbps (max:OC12 599040; OC3 149760; T1 1544; T3 44736)";
            }
          }
          leaf sustained-output-rate {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<8-599040>;;Sustained output rate (kbps)";
            }
          }
          leaf burst-size {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-8192>;;Burst size (cells)";
            }
          }
        }
      }
      leaf encapsulation {
        tailf:info "Configure encapsulation on this PVC";
        tailf:cli-full-command;
        type enumeration {
          enum aal0 {
            tailf:info "Use aal0 encapsulation on this PVC";
          }
          enum aal5 {
            tailf:info "Use aal5 encapsulation on this PVC";
          }
          enum aal5mux {
            tailf:info "Use aal5mux encapsulation on this PVC";
          }
          enum aal5nlpid {
            tailf:info "Use aal5nlpid encapsulation on this PVC";
          }
          enum aal5snap {
            tailf:info "Use aal5snap encapsulation on this PVC";
          }
        }
      }
      container oam {
        tailf:info "Configure ATM OAM VC commands";
        container retry {
          tailf:info "Enter OAM to configure retry freq";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          tailf:cli-reset-container;
          tailf:cli-delete-when-empty;
          presence true;
          leaf up-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as up";
            }
          }
          leaf down-count {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-600>;;OAM retry count before declaring a VC as down";
            }
          }
          leaf retry-frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<1-1000>;;OAM retry polling frequency in seconds";
            }
          }
        }
      }
      container oam-pvc {
        tailf:info "Enter OAM to generate OAM cells  ";
        container manage {
          tailf:info "OAM PVC management";
          tailf:cli-delete-when-empty;
          presence true;
          leaf disable {
            tailf:info "Disable OAM PVC management";
            tailf:cli-reset-container;
            tailf:cli-full-command;
            type empty;
          }
          leaf frequency {
            tailf:cli-drop-node-name;
            type uint16 {
              tailf:info "<0-600>;;OAM loopback frequency (seconds)";
              range "0..600";
            }
          }
        }
      }
      container cell-packing {
        tailf:info "Configure L2VPN cell packing parameters";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf cells {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<2-255>;;Maximum number of cells to be packed in a packet";
            range "2..255";
          }
        }
        leaf timer {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-3>;;Which cell packing timer to use";
            range "1..3";
          }
        }
      }
    }
  }

  grouping ipsla-operation-type-grouping {
    leaf tag {
      tailf:info "Add a tag for this operation";
      type string {
        tailf:info "WORD;;Tag string";
      }
    }
    leaf timeout {
      tailf:info "Probe/Control timeout interval";
      type uint32 {
        tailf:info "<1-604800000>;;Probe/Control timeout in ms (default 5000 ms)";
        range "1..604800000";
      }
    }
    leaf vrf {
      tailf:info "Configure IPSLA for a VPN Routing/Forwarding instance";
      type string {
        tailf:info "WORD;;VPN Routing/Forwarding instance name";
      }
    }
    container source {
      tailf:info "Address/port of the source device";
      leaf address {
        tailf:info "IPv4 address of the source device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the source device";
        }
      }
      leaf port {
        tailf:info "Port number on source device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }
    container destination {
      tailf:info "Address/port of the target device";
      leaf address {
        tailf:info "IPv4 address of the target device";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;Enter IPv4 address of the target device";
        }
      }
      leaf port {
        tailf:info "Port number on target device";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-65535>;;Specify the port number";
        }
      }
    }
    container statistics {
      tailf:info "Statistics collection parameters for this operation";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-ipsla-op-stats;
      tailf:cli-incomplete-command;
      leaf hourly {
        tailf:info "Statistics collection aggregated over an hour";
        tailf:cli-hide-in-submode;
        type empty;
      }
      leaf buckets {
        tailf:info "Number of Hours for which statistics are kept";
        type uint8 {
          tailf:info "<0-25>;;Specify number of hours (default 2)";
          range "0..25";
        }
      }
    }
    container packet {
      tailf:info "Probe packet configuration parameters";
      leaf count {
        tailf:info "Number of packets to be transmitted during a probe";
        type uint16 {
          tailf:info "<1-60000>;;Packet count (default 10)";
          range "1..60000";
        }
      }
      leaf interval {
        tailf:info "Inter packet interval";
        type uint16 {
          tailf:info "<1-60000>;;Packet interval (default 20 ms)";
          range "1..60000";
        }
      }
    }
    leaf tos {
      tailf:info "Type of service setting in probe packet";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<0-255>;;Type of service number";
      }
    }
    container datasize {
      tailf:info "Protocol data size in payload of probe packets";
      leaf request {
        tailf:info "Payload size in request probe packet";
        type uint16 {
          tailf:info "<16-1500>;;Enter request datasize in byte";
        }
      }
    }
    container target {
      tailf:info "Target for the MPLS LSP operation";
      container traffic-eng {
        tailf:info "Traffic engineering target";
        leaf tunnel {
          tailf:info "TE tunnel interface";
          type uint16 {
            tailf:info "<0-65535>;;Tunnel interface number";
          }
        }
      }
      container pseudowire {
        tailf:info "Pseudowire target";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf address {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Target address";
          }
        }
        leaf pw-id {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-4294967295>;;Virtual Circuit ID";
          }
        }
      }
      leaf ipv4 {
        tailf:info "Target specified as an IPv4 address";
        tailf:cli-full-command;
        type ipv4-prefix {
          tailf:info "A.B.C.D/prefix;;Target FEC address with mask";
        }
      }
    }
    leaf frequency {
      tailf:info "Frequency of the probing";
      type uint32 {
        tailf:info "<1-604800>;;Probe interval in seconds (default 60)";
        range "1..604800";
      }
    }
    container statistics-interval {
      tailf:cli-drop-node-name;
      container statistics {
        tailf:info "Statistics collection parameters for this operation";
        list interval {
          tailf:info "Statistics collection over specified time interval";
          tailf:cli-mode-name config-ipsla-op-stats;
          key seconds;
          leaf seconds {
            type uint16 {
              tailf:info "<1-3600>;;Interval in seconds";
              range "1..3600";
            }
          }
          leaf buckets {
            tailf:info "Maximum number of buckets to keep";
            type uint8 {
              tailf:info "<1-100>;;Buckets of enhanced statistics kept";
              range "1..100";
            }
          }
        }
      }
    }
  }

  grouping storm-control-grouping {
    container storm-control {
      tailf:info "Storm Control";
      container broadcast {
        tailf:info "Broadcast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container multicast {
        tailf:info "Multicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
      container unknown-unicast {
        tailf:info "Unknown-unicast Storm Control";
        leaf kbps {
          tailf:info "Set the storm control kbps";
          type uint32 {
            tailf:info "<64-1280000>;;storm control kbps value";
            range "64..1280000";
          }
        }
        leaf pps {
          tailf:info "Set the storm control pps";
          type uint32 {
            tailf:info "<1-160000>;;storm control pps value";
            range "1..160000";
          }
        }
      }
    }
  }

  grouping vrf-af-ipv4-grouping {
    container import {
      tailf:info "VRF import";
      leaf route-policy {
        tailf:info "Use route-policy for import filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
      }
      container route-target {
        tailf:info "Specify import route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-vrf-import-rt;
        uses vrf-route-target-grouping;
      }
      container from {
        tailf:info "Import routes from a VRF";
        container vrf {
          tailf:info "VRF import";
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PEs";
            type empty;
          }
        }
        container default-vrf {
          tailf:info "Import routes from the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for import filtering";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf advertise-as-vpn {
            tailf:info "Advertise imported routes to PE";
            type empty;
          }
        }
      }
    }
    container export {
      tailf:info "VRF export";
      leaf route-policy {
        tailf:info "Use route-policy for export filtering";
        type string {
          tailf:info "WORD;;Name of the policy";
        }
        tailf:non-strict-leafref {
          path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
            tailf:xpath-root 3;
          }
        }
      }
      container route-target {
        tailf:info "Specify export route target extended communities";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-vrf-export-rt;
        uses vrf-route-target-grouping;
      }
      container to {
        tailf:info "Export routes to a VRF";
        container vrf {
          tailf:info "VRF export";
          leaf allow-imported-vpn {
            tailf:info "Allow export of imported VPN routes to non-default VRF";
            type empty;
          }
        }
        container default-vrf {
          tailf:info "Export routes to the default VRF";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf route-policy {
            tailf:info "Use route-policy for export";
            type string {
              tailf:info "WORD;;Name of the policy";
            }
          }
          leaf allow-imported-vpn {
            tailf:info "Export imported VPN routes to default VRF";
            type empty;
          }
        }
      }
    }
    container maximum {
      tailf:info "Set maximum prefix limit";
      container prefix {
        tailf:info "Set table's maximum prefix limit";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf limit {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<32-5000000>;;Maximum table's prefix limit";
            range "32..5000000";
          }
        }
        leaf mid-thresh {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-100>;;mid-thresh (% of max)";
            range "1..100";
          }
        }
      }
    }
  }

  grouping snmp-server-host-grouping {
    list host {
      tailf:info "Specify hosts to receive SNMP notifications";
      tailf:cli-suppress-mode;
      tailf:cli-sequence-commands;
      tailf:cli-compact-syntax;
      tailf:cli-incomplete-command;
      tailf:cli-delete-when-empty;
      key address;
      leaf address {
        type string {
          tailf:info "A.B.C.D or X:X::X;;IP address of SNMP notification host";
        }
      }
      leaf informs {
        tailf:info "Send Inform messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf traps {
        tailf:info "Send Trap messages to this host";
        tailf:cli-optional-in-sequence;
        type empty;
      }
      leaf version {
        tailf:info "SNMP version to use for notification messages";
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum 1 {
            tailf:info "WORD  Use 1 for SNMPv1";
          }
          enum 2c {
            tailf:info "WORD;;Use 2c for SNMPv2c";
          }
          enum 3 {
            tailf:info "WORD;;Use 3 for SNMPv3";
          }
        }
      }
      leaf security-level {
        when "../version = 3" {
          tailf:xpath-root 3;
          tailf:dependency "../version";
        }
        tailf:cli-drop-node-name;
        type enumeration {
          enum auth {
            tailf:info "Using authNoPriv Security Level";
          }
          enum noauth {
            tailf:info "Using noAuthNoPriv Security Level";
          }
          enum priv {
            tailf:info "Using authPriv Security Level";
          }
        }
      }
      leaf enc {
        tailf:cli-drop-node-name;
        tailf:cli-optional-in-sequence;
        type enumeration {
          enum clear {
            tailf:info "Save the community string in encrypted form";
          }
          enum encrypted {
            tailf:info "Specifies an ENCRYPTED community string";
          }
        }
      }
      leaf community-string {
        tailf:cli-drop-node-name;
        mandatory true;
        type string {
          tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
        }
      }
      leaf udp-port {
        tailf:info "udp port to which notifications should be sent";
        tailf:cli-optional-in-sequence;
        type uint16;
      }
    }
  }

  grouping multicast-routing-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mcast-default-ipv4;
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name config-mcast-default-ipv4-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          choice status-choice {
            leaf enable {
              tailf:info "Enable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable IP multicast";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf boundary {
            tailf:info "Boundary for administratively scoped multicast addresses";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Access list specifying scoped multicast groups";
            }
          }
        }
        container interface-inheritance {
          tailf:info "Knob to separate enabling/disabling multicast routing & forwarding";
          leaf disable {
            tailf:info "Disable inheriting En/Dis config";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf nsf {
          tailf:cli-full-command;
          type empty;
        }
        leaf log-traps {
          tailf:info "Enable logging trap events";
          type empty;
        }
        container mdt {
          tailf:info "MVPN configuration";
          leaf mtu {
            tailf:info "MDT mtu configuration";
            type uint16 {
              tailf:info "<1401-65535>;;MTU value";
              range "1401..65535";
            }
          }
          container source {
            tailf:info "Interface used to set MDT source address";
            uses interface-name-grouping;
          }
          container data {
            tailf:info "Data MDT configuration";
            container address {
              tailf:cli-drop-node-name;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf mdt-group-address {
                tailf:cli-drop-node-name;
                type ipv4-prefix {
                  tailf:info "A.B.C.D/length;;Data MDT group IP address/prefix length";
                }
              }
              leaf threshold {
                tailf:info "Traffic rate threshold in Kbps to trigger Data MDT";
                tailf:cli-optional-in-sequence;
                type uint32 {
                  tailf:info "<0-4294967295>;;Threshold value (kbps). Default 1kbps";
                }
                default 1;
              }
              leaf acl-name {
                tailf:cli-drop-node-name;
                tailf:cli-disallow-value threshold;
                type string {
                  tailf:info "WORD;;ACL for Customer VRF groups allowed to do Data MDT";
                }
              }
            }
            container p2mp-te {
              tailf:info "P2MPTE Data MDT core";
              choice max-or-rp-choice {
                container max-number {
                  tailf:cli-drop-node-name;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf value {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-255>;;Maximum number of data-mdts to be triggered";
                    }
                  }
                }
                leaf route-policy {
                  tailf:info "Route policy to select data mdt core";
                  type string {
                    tailf:info "WORD;;Route policy name";
                  }
                  tailf:non-strict-leafref {
                    path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                      tailf:xpath-root 3;
                    }
                  }
                }
              }
            }
          }
          container default {
            tailf:info "MDT Default distribution tree";
            leaf ipv4 {
              tailf:info "IPv4 encapsulated MDT";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address MDT default group";
              }
            }
            container mldp {
              tailf:info "mLDP default distribution tree";
              list ipv4 {
                tailf:info "MP2MP core-tree with IPv4 Root Address";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                key address;
                leaf address {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Root address";
                  }
                }
                container partitioned {
                  tailf:info "mLDP Partitioned MDT";
                  leaf bidir {
                    tailf:info "Enable Exclusive Partitioned MDT for Bidir";
                    type empty;
                  }
                }
              }
            }
            container p2mp-te {
              tailf:info "P2MP-TE default distribution tree";
              tailf:cli-delete-when-empty;
              presence true;
              leaf attribute-set {
                tailf:info "The Attribute Set template to be used with the TE tunnel request";
                type string {
                  tailf:info "WORD;;Name of template describing the Attribute Set";
                }
              }
              container static {
                tailf:info "Static P2MP-TE Tunnel";
                leaf tunnel-mte {
                  tailf:cli-allow-join-with-value {
                    tailf:cli-display-joined;
                  }
                  type uint16 {
                    tailf:info "<0-65535>;;MPLS Traffic Engineering P2MP Tunnel interface(s)";
                  }
                }
              }
            }
          }
        }
        container bgp {
          tailf:info "Enable BGP MVPN Discovery";
          container auto-discovery {
            tailf:info "Enable BGP Auto-Discovery";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-mcast-vrf-ipv4-bgp-ad;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            leaf ad-tree {
              tailf:cli-drop-node-name;
              tailf:cli-hide-in-submode;
              type enumeration {
                enum ingress-replication {
                  tailf:info "IR core tree";
                }
                enum mldp {
                  tailf:info "mLDP core tree";
                }
                enum p2mp-te {
                  tailf:info "RSVP P2MP-TE core tree";
                }
                enum pim {
                  tailf:info "PIM core tree";
                }
              }
            }
            leaf inter-as {
              tailf:info "Inter-AS MVPN";
              tailf:cli-break-sequence-commands;
              type empty;
            }
            leaf leaf-info-required {
              tailf:info "Explicit tracking of S-PMSI core trees";
              type empty;
            }
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          tailf:cli-delete-when-empty;
          presence true;
          leaf hash {
            tailf:info "Enter a hashing algorithm";
            type enumeration {
              enum source {
                tailf:info "Enable source based multipath hashing (Compatible with IOS versions)";
              }
              enum source-group {
                tailf:info "Enable source, group based multipath hashing";
              }
              enum source-nexthop {
                tailf:info "Enable source with next-hop multipath hashing (better distribution)";
              }
            }
          }
        }
        container ssm {
          tailf:info "Configure a group range for Source-Specific use";
          leaf range {
            tailf:info "Provide ACL that specifies non-standard SSM range";
            type string {
              tailf:info "WORD;;Access list specifying SSM group range";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
                tailf:xpath-root 3;
              }
            }
          }
          leaf allow-override {
            tailf:info "Allow SSM ranges to be overridden by more specific ranges";
            type empty;
          }
        }
        container oom-handling {
          tailf:info "Enable out-of-memory handling";
          presence true;
        }
        leaf rate-per-route {
          tailf:info "Enable/disable per (S,G) rate calculation";
          tailf:cli-full-command;
          type empty;
        }
        container accounting {
          tailf:info "Enable/disable Accounting";
          container per-prefix {
            tailf:info "Enable per (S,G) accounting.";
            presence true;
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv6;
        list interface {
          tailf:info "Multicast interface configuration subcommands";
          tailf:cli-mode-name config-mcast-default-ipv6-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf enable {
            tailf:info "Enable IP multicast";
            tailf:cli-full-command;
            type empty;
          }
        }
        container multipath {
          tailf:info "Enable equal-cost multipath routing";
          presence true;
        }
      }
    }
  }

  grouping router-mld-grouping {
    leaf version {
      tailf:info "MLD version";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-2>;;version number";
        range "1..2";
      }
    }
    list interface {
      tailf:info "MLD interface configuration subcommands";
      tailf:cli-mode-name config-mld-default-if;
      key name;
      leaf name {
        type ifname;
      }
      leaf router {
        tailf:info "Enable/Disable Router side functionality in MLD";
        tailf:cli-full-command;
        type enumeration {
          enum enable {
            tailf:info "Enable Router side functionality in MLD";
          }
          enum disable {
            tailf:info "Disable Router side functionality in MLD";
          }
        }
      }
    }
  }

  grouping router-pim-grouping {
    container address-family {
      tailf:info "Enter Address Family command mode";
      container ipv4 {
        tailf:info "Enter ipv4 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv4;
        leaf hello-interval {
          tailf:info "Inherited by all interfaces : Hello interval in seconds";
          type uint16 {
            tailf:info "<1-3600>;;Hello interval in seconds";
            range "1..3600";
          }
        }
        container rpf {
          tailf:info "RPF commands";
          container topology {
            tailf:info "Select RPF topology";
            leaf route-policy {
              tailf:info "Route policy to select RPF topology";
              type string {
                tailf:info "WORD;;Name of the policy";
              }
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
        }
        container mdt {
          tailf:info "Multicast Distribution Tree commands";
          container c-multicast-routing {
            tailf:info "MVPN customer routing commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-pim-default-ipv4-mdt-cmcast;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            choice protocol-choice {
              leaf bgp {
                tailf:info "BGP customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
              leaf pim {
                tailf:info "PIM customer multicast routing";
                tailf:cli-hide-in-submode;
                tailf:cli-full-command;
                type empty;
              }
            }
            container unicast-reachability {
              tailf:info "Control addition of Extended Communities to Unicast VPN-IP routes";
              tailf:cli-compact-syntax;
              leaf connector {
                tailf:info "Enable/Disable Connector";
                type enumeration {
                  enum disable {
                    tailf:info "Disable Connector Attribute";
                  }
                  enum enable {
                    tailf:info "Enable Connector Attribute";
                  }
                }
              }
            }
          }
        }
        container auto-rp {
          tailf:info "Auto-RP Commands";
          container listen {
            tailf:info "RP discovery through AUTORP protocol";
            leaf disable {
              tailf:info "Disable RP discovery through the AUTORP protocol";
              type empty;
            }
          }
        }
        list rp-address {
          tailf:info "Configure Rendezvous Point";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type inet:host {
              tailf:info "IP name or address of Rendezvous Point";
            }
          }
          leaf group-access-list {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            type string {
              tailf:info "WORD;;Access list of groups that should map to given RP";
            }
          }
          leaf override {
            tailf:info "Static RP config overrides auto-rp and BSR";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf bidir {
            tailf:info "Specify keyword bidir to configure a bidir RP";
            type empty;
          }
        }
        leaf accept-register {
          tailf:info "Registers accept filter";
          type string {
            tailf:info "WORD;;IP named access list";
          }
        }
        container spt-threshold {
          tailf:info "Configure threshold for switching to SPT on last-hop";
          container infinity {
            tailf:info "Always stay on shared-tree";
            tailf:cli-reset-container;
            tailf:cli-delete-when-empty;
            presence true;
            leaf group-list {
              tailf:info "Only stay on the shared-tree for specified groups";
              type string {
                tailf:info "WORD;;Access-list of threshold limited groups";
              }
            }
          }
        }
        container neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }
        container neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          leaf enable {
            tailf:info "Enable this feature";
            type empty;
          }
        }
        container nsf {
          tailf:info "Configure Non-stop forwarding (NSF) options(cisco-support)";
          leaf lifetime {
            tailf:info "Override default maximum lifetime for PIM NSF mode";
            type uint16 {
              tailf:info "<10-600>;;Maximum time for PIM NSF mode in seconds";
              range "10..600";
            }
          }
        }
        container log {
          tailf:info "Enable PIM logging";
          container neighbor {
            tailf:info "Enable PIM neighbor logging";
            leaf changes {
              tailf:info "Enable PIM neighbor state logging";
              type empty;
            }
          }
        }
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name config-pim-ipv4-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          uses bfd-common-parameters-grouping;
          choice status-choice {
            leaf enable {
              tailf:info "Enable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable PIM processing on this interface";
              tailf:cli-full-command;
              type empty;
            }
          }
          leaf dr-priority {
            tailf:info "PIM Hello DR priority";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967295>;;Hello DR priority, preference given to larger value";
            }
          }
        }
        container maximum {
          tailf:info "Maximum state limits";
          container routes {
            tailf:info "PIM Routes";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf number {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-200000>;;Maximum PIM routes";
                range "1..200000";
              }
            }
            leaf threshold {
              tailf:info "Set threshold to print warning";
              type uint32 {
                tailf:info "<1-200000>;;Threshold value";
                range "1..200000";
              }
            }
          }
        }
      }
      container ipv6 {
        tailf:info "Enter ipv6 Address Family command mode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim-default-ipv6;
        leaf neighbor-check-on-recv {
          tailf:info "Check for PIM neighbor before rcv'ing control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }
        leaf neighbor-check-on-send {
          tailf:info "Check for PIM neighbor before sending control messages";
          tailf:cli-full-command;
          type enumeration {
            enum enable {
              tailf:info "Enable this feature";
            }
          }
        }
        list interface {
          tailf:info "PIM interface configuration subcommands";
          tailf:cli-mode-name config-pim-ipv6-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interace Name";
            }
          }
          leaf enable {
            tailf:info "Enable PIM processing on this interface";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
  }

  grouping router-rip-redistribute-grouping {
    leaf route-policy {
      tailf:info "Route policy reference";
      type string {
        tailf:info "WORD;;Name of the policy";
      }
      tailf:non-strict-leafref {
        path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
          tailf:xpath-root 3;
        }
      }
    }
  }

  grouping router-rip-grouping {
    list interface {
      tailf:cli-mode-name config-rip-if;
      key name;
      leaf name {
        type ifname;
      }
      leaf passive-interface {
        tailf:info "Suppress routing updates on this interface";
        tailf:cli-full-command;
        type empty;
      }
    }
    container timers {
      tailf:info "Adjust routing timers";
      container basic {
        tailf:info "Basic routing protocol update timers";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf update {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<5-50000>;;Interval between updates";
          }
        }
        leaf invalid {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Invalid";
          }
        }
        leaf holddown {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<15-200000>;;Holddown";
          }
        }
        leaf flush {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16-250000>;;Flush";
          }
        }
      }
    }
    container redistribute {
      tailf:info "Redistribute information from another routing protocol";
      container static {
        tailf:info Static;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        presence true;
        uses router-rip-redistribute-grouping;
      }
      list bgp {
        tailf:info "Border Gateway Protocol (BGP)";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type string {
            tailf:info "WORD;;AS number in 2-byte, 4-byte asdot and asplain";
          }
        }
        uses router-rip-redistribute-grouping;
      }
    }
  }

  grouping router-vrrp-if-af-vrrp-grouping {
    leaf priority {
      tailf:info "Set priority level";
      tailf:cli-full-command;
      type uint8 {
        tailf:info "<1-254>;;Priority value";
      }
    }
    container preempt {
      tailf:info "Preempt Master router if higher priority";
      choice preempt-choice {
        leaf delay {
          tailf:info "Wait before preempting";
          tailf:cli-optional-in-sequence;
          type uint16 {
            tailf:info "<1-3600>;;Number of seconds to delay";
            range "1..3600";
          }
        }
        leaf disable {
          tailf:info "Disable preemption";
          type empty;
        }
      }
    }
    container timer {
      tailf:info "Set advertisement timer";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      choice timer-choice {
        leaf time-value {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-255>;;Advertisement time in seconds";
          }
        }
        leaf msec {
          tailf:info "Configure in milliseconds";
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<100-3000>;;Advertisement time in milliseconds (100-3000)";
          }
        }
      }
      leaf force {
        tailf:info "Force the configured values to be used (required for msec)";
        type empty;
      }
    }
    container track {
      tailf:info "Track an item, reducing priority if it goes down";
      list interface {
        tailf:info "Track an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf priority {
          tailf:cli-drop-node-name;
          type uint8 {
            tailf:info "<1-254>;;Priority decrement";
            range "1..254";
          }
        }
      }
    }
  }

  grouping router-bgp-af-advertise-grouping {
    container re-originated {
      tailf:info "Advertise Re-orignated routes only";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }
    container local {
      tailf:info "Advertisement of local routes";
      tailf:cli-delete-when-empty;
      presence true;
      leaf route-target {
        tailf:cli-drop-node-name;
        type enumeration {
          enum regular-rt {
            tailf:info "Advertise re-originated routes with regular (non-stitching) Route-Targets";
          }
          enum stitching-rt {
            tailf:info "Advertise re-originated routes with stitching Route-Targets";
          }
        }
      }
    }
    leaf disable {
      tailf:info "Disable Advertisement of selected SAFI";
      tailf:cli-full-command;
      type empty;
    }
    container imported-from-vrf {
      tailf:info "VRF extranet imported routes";
      leaf disable {
        tailf:info "Disable advertisement of VRF extranet imported routes";
        type empty;
      }
    }
    container imported-from-default-vrf {
      tailf:info "Default VRF imported routes";
      leaf disable {
        tailf:info "Disable advertisement of default VRF imported routes";
        type empty;
      }
    }
  }

  grouping controller-dwdm-grouping {
    list dwdm {
      tailf:info "DWDM controller(s)";
      tailf:cli-allow-join-with-key;
      key id;
      leaf id {
        type string {
          tailf:info "dwdm Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      uses description-grouping;
      leaf proactive {
        tailf:info "Enable Proactive Protection Feature";
        tailf:cli-full-command;
        type empty;
      }
      container proactive-conf {
        tailf:cli-drop-node-name;
        container proactive {
          tailf:info "Enable Proactive Protection Feature";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container revert {
            tailf:info "Configure Revert thresholds";
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>;;Bit error rate coefficient (x of xE-y) (Revert threshold cannot be > 1E-3";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<3-10>;;Bit error rate power (y of xE-y) (Revert threshold cannot be > 1E-3)";
                  range "3..10";
                }
              }
            }
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<500-100000>;;Integration window for FRR revert in MS";
                range "500..100000";
              }
            }
          }
          container trigger {
            tailf:info "Configure trigger threshold";
            container threshold {
              tailf:info "Set values x and y of xE-y";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf x-coefficient {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-9>  Bit error rate coefficient (x of xE-y) (Trigger threshold cannot be > 1E-2)";
                  range "1..9";
                }
              }
              leaf y-power {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<2-9>;;Bit error rate power (y of xE-y) (Trigger threshold cannot be > 1E-3)";
                  range "2..9";
                }
              }
            }
            leaf window {
              tailf:info "Number of times threshold crossing is tested";
              type uint32 {
                tailf:info "<10-10000>;;Integration window for FRR trigger in MS";
                range "10..10000";
              }
            }
          }
        }
      }
      container g709 {
        tailf:info "Configure G709 parameters";
        leaf enable {
          tailf:info "Enable G709 function";
          tailf:cli-full-command;
          type empty;
        }
        container fec {
          tailf:info "Configure FEC mode";
          choice fec-choice {
            leaf ci-bch {
              tailf:info "Continuously Interleaved BCH FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf disable {
              tailf:info "Disable FEC";
              tailf:cli-full-command;
              type empty;
            }
            leaf enhanced {
              tailf:info "Enhanced FEC mode";
              type enumeration {
                enum "i.4" {
                  tailf:info "efec i.4";
                }
                enum "i.7" {
                  tailf:info "efec i.7";
                }
              }
            }
            leaf high-gain-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf high-gain-multivendor-hd-fec {
              tailf:info "7% HD FEC (Staircase FEC) Multivendor Interoperable";
              type empty;
            }
            leaf high-gain-sd-fec {
              tailf:info "7% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf long-haul-hd-fec {
              tailf:info "20% HD FEC (Staircase FEC)";
              type empty;
            }
            leaf long-haul-sd-fec {
              tailf:info "20% CISCO SD FEC (Etna Soft-Decision FEC)";
              type empty;
            }
            leaf standard {
              tailf:info "Standard FEC mode";
              type empty;
            }
          }
        }
        leaf framing {
          tailf:info "Configure Framing mode";
          type enumeration {
            enum opu1e {
              tailf:info "opu1e framing mode";
            }
            enum opu2e {
              tailf:info "opu2e framing mode";
            }
          }
        }
        container odu {
          tailf:info "Configure ODU parameters";
          container overhead {
            tailf:info "Configure ODU overhead";
            container tti {
              tailf:info "Configure ODU Trail Trace Identifier buffer";
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
        }
        container otu {
          tailf:info "Configure OTU parameters";
          container overhead {
            tailf:info "Configure OTU overhead";
            container tti {
              tailf:info "Configure OTU Trail Trace Identifier buffer";
              container expected {
                tailf:info "Set expected TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
              container sent {
                tailf:info "Set transmit TTI";
                leaf ascii {
                  tailf:info "Enter ASCII string";
                  tailf:cli-multi-value;
                  type string {
                    tailf:info "LINE;;ASCII text (Max 64 characters)";
                  }
                }
              }
            }
          }
          container threshold {
            tailf:info "Configure OTU threshold value";
            leaf sf-ber {
              tailf:info "Set Signal Failure BER threshold";
              type uint8 {
                tailf:info "<1-9>;;Bit error rate (10 to the minus n)";
                range "1..9";
              }
            }
          }
        }
        leaf tti-processing {
          tailf:info "Enable Trail Trace Identifier processing";
          tailf:cli-full-command;
          type empty;
        }
      }
      leaf loopback {
        tailf:info "Configure loopback mode";
        tailf:cli-full-command;
        type enumeration {
          enum internal {
            tailf:info "Select internal loopback mode";
          }
          enum line {
            tailf:info "Select line loopback mode";
          }
        }
      }
      container wavelength {
        tailf:info "Configure ITU Channel, Wavelength and Frequency";
        choice wave-length-choice {
          leaf channel-number {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-100>;;Select an ITU channel number; C Band: 1-89";
              range "1..100";
            }
          }
          leaf frequency {
            tailf:info "Configure Frequency and Map to ITU Channel";
            type uint16 {
              tailf:info "<19115-19610>;;Enter 5-digit Frequency data; e.g. 19580 for 195.8 THz";
              range "19115..19610";
            }
          }
        }
      }
      leaf admin-state {
        tailf:info "Configure the transport admin state of the controller";
        type enumeration {
          enum in-service {
            tailf:info "change the admin-state to In-service (IS)";
          }
          enum maintenance {
            tailf:info "change the admin-state to Out-of-service-Maintenance (OOS-MT)";
          }
          enum out-of-service {
            tailf:info "change the admin-state to Out-of-service (OOS)";
          }
          enum in-service-config-allowed {
            tailf:info "change the admin-state to In-service-config-allowed (IS-CFG)";
          }
        }
      }
      leaf transmit-power {
        tailf:info "Configure transponder transmit power ";
        tailf:cli-full-command;
        type int16 {
          tailf:info "<-190,+10>;;Select power level (in units of 0.1dBm)";
          range "-190..10";
        }
      }
    }
  }

  grouping controller-grouping {
    uses controller-dwdm-grouping;
    list MgmtMultilink {
      tailf:info "Controller for the management of multilink interfacess";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-mgmtmultilink;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
        }
      }
      list bundle {
        tailf:info "Configure a multilink bundle interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-999999999>;;Bundle Id";
          }
        }
      }
    }
    list T1 {
      tailf:info "T1 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-t1;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
        }
      }
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum esf {
            tailf:info "esf framing: default";
          }
          enum sf {
            tailf:info "sf framing mode";
          }
        }
      }
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum b8zs {
            tailf:info "B8ZS encoding";
          }
        }
      }
      container carrier-delay {
        tailf:info "Set the carrier delay on a T1/E1 controller";
        choice carrier-delay-choice {
          leaf seconds {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<0-60>;;Carrier Transitions delay in seconds";
              range "0..60";
            }
          }
          leaf msec {
            tailf:info "Set time in milliseconds";
            type uint16 {
              tailf:info "<0-1000>;;Carrier Transitions delay in milliseconds";
              range "0..1000";
            }
          }
        }
      }
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name config-t1-channel_group;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-23>;;channel group number";
            range "0..23";
          }
        }
        leaf speed {
          tailf:info "speed of the ds0 channel";
          tailf:cli-full-command;
          type enumeration {
            enum 56 {
              tailf:info "56 Kbits";
            }
            enum 64 {
              tailf:info "64 Kbits";
            }
          }
        }
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 24. (:) indicates individual timeslot and (-) represent range";
          }
        }
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
      container bert {
        tailf:info "Configure BERT parameters";
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum 0s {
              tailf:info "All 0's test pattern";
            }
            enum 1in8 {
              tailf:info "1 in 8 test pattern";
            }
            enum 1s {
              tailf:info "All 1's test pattern";
            }
            enum 2e11 {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum 2e15 {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum 2e20 {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum 2e20-QRSS {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum 2e23 {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum 2e9 {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum 3in24 {
              tailf:info "3 in 24 test pattern";
            }
            enum 55Daly {
              tailf:info "55 Daly test pattern";
            }
            enum 55Octet {
              tailf:info "55 Octect test pattern";
            }
            enum alt-0-1 {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      container loopback {
        tailf:info "Configure T1 loopback mode";
        leaf local {
          tailf:cli-full-command;
          tailf:info "Put near end in local loopback";
          type empty;
        }
        leaf network {
          tailf:info "Network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Put line network loopback";
            }
            enum payload {
              tailf:info "Put payload network loopback";
            }
          }
        }
        container remote {
          tailf:info "Remote loopback (put far end in loopback)";
          tailf:cli-compact-syntax;
          choice line-payload {
            container line {
              tailf:info "Put far end line loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum ansi {
                    tailf:info "loopback using ansi fdl";
                  }
                  enum bellcore {
                    tailf:info "loopback using Bellcore fdl (SmartJack loopback)";
                  }
                }
              }
              leaf inband {
                tailf:info "loopback using inband code";
                tailf:cli-full-command;
                type empty;
              }
            }
            container payload {
              tailf:info "Put far end payload loop";
              leaf fdl {
                tailf:info "loopback using fdl";
                tailf:cli-full-command;
                type enumeration {
                  enum ansi {
                    tailf:info "loopback using ansi fdl";
                  }
                }
              }
            }
          }
        }
      }
    }
    list T3 {
      tailf:info "T3 Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-t3;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }
      container dsu {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-t3-dsu;
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<75-44210>;;DSU subrate bandwidth range";
            range "75..44210";
          }
        }
        leaf mode {
          tailf:info "Configure DSU mode";
          tailf:cli-full-command;
          type enumeration {
            enum adtran {
              tailf:info "Set DSU mode to Adtran";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
            enum larscom {
              tailf:info "Set DSU mode to Larscom";
            }
            enum verilink {
              tailf:info "Set DSU mode to Verilink";
            }
          }
        }
        leaf remote {
          tailf:info "Specify commands associated with the remote end";
          tailf:cli-full-command;
          type enumeration {
            enum disable {
              tailf:info "Deny incoming remote requests to reset bandwidth to fullrate";
            }
            enum fullrate {
              tailf:info "Request that the farend set its bandwidth to fullrate";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        type enumeration {
          enum auto-detect {
            tailf:info "Application Identification Channel Signal";
          }
          enum c-bit {
            tailf:info "C-bit framing (T3 default)";
          }
          enum m23 {
            tailf:info "M23 Framing Format";
          }
        }
      }
      container delay {
        leaf trigger {
          tailf:info "trigger time";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<0-60000>;;time in msec to soak before declaring the alarm";
            range "0..60000";
          }
        }
      }
      leaf cablelength {
        tailf:info "Length of the T3/E3 cable in feet";
        type uint16 {
          tailf:info "<0-450>;;Length of the cable in feet";
          range "0..450";
        }
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
          }
        }
      }
      container bert {
        tailf:info "Configure BERT parameters";
        leaf error {
          tailf:info "Insert errors into BERT bit stream";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<1-255>;;Number of errors to generate";
            range "1..255";
          }
        }
        leaf interval {
          tailf:info "Duration of BERT in minutes";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1-1440>;;Duration of BERT in minutes";
            range "1..1440";
          }
        }
        leaf pattern {
          tailf:info "BERT pattern";
          tailf:cli-full-command;
          type enumeration {
            enum 0s {
              tailf:info "All 0's test pattern";
            }
            enum 1in8 {
              tailf:info "1 in 8 test pattern";
            }
            enum 1s {
              tailf:info "All 1's test pattern";
            }
            enum 2e11 {
              tailf:info "2^11-1 O.150 test pattern";
            }
            enum 2e15 {
              tailf:info "2^15-1 O.151 test pattern";
            }
            enum 2e20 {
              tailf:info "2^20-1 O.153 test pattern";
            }
            enum 2e20-QRSS {
              tailf:info "2^20-1 QRSS O.151 test pattern";
            }
            enum 2e23 {
              tailf:info "2^23-1 O.151 test pattern";
            }
            enum 2e9 {
              tailf:info "2^9-1 O.150 test pattern";
            }
            enum 3in24 {
              tailf:info "3 in 24 test pattern";
            }
            enum 55Daly {
              tailf:info "55 Daly test pattern";
            }
            enum 55Octet {
              tailf:info "55 Octect test pattern";
            }
            enum alt-0-1 {
              tailf:info "Alternating 0's and 1's test pattern";
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
      container loopback {
        tailf:info "Configure T3 loopback mode";
        leaf local {
          tailf:info "Put near end in local loopback";
          tailf:cli-full-command;
          type empty;
        }
        leaf network {
          tailf:info "Put near end in network loopback";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Put line network loopback";
            }
            enum payload {
              tailf:info "Put payload network loopback";
            }
          }
        }
        leaf remote {
          tailf:info "Remote loopback (put far end in loopback by sending FEAC)";
          tailf:cli-full-command;
          type enumeration {
            enum line {
              tailf:info "Remote line loopback";
            }
            enum payload {
              tailf:info "Remote payload loopback";
            }
          }
        }
      }
    }
    list E1 {
      tailf:info "E1 Port controller(s)";
      tailf:cli-mode-name config-e1;
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Portformat";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses description-grouping;
      container cem-group {
        tailf:info "Configure CEM interface on T1/E1";
        leaf unframed {
          tailf:info "Configure a unframed CEM interface on T1/E1";
          type empty;
        }
        list framed {
          tailf:info "Configure a framed CEM interface on T1/E1";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<0-30>;;CEM group number";
            }
          }
          leaf timeslots {
            tailf:info "List of timeslots in the CEM group";
            type string {
              tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. (:) indicates individual timeslot and (-) represent range";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure T1E1 framing";
        type enumeration {
          enum crc4 {
            tailf:info "E1 with CRC: default";
          }
          enum no-crc4 {
            tailf:info E1;
          }
          enum unframed {
            tailf:info unframed;
          }
        }
      }
      leaf linecode {
        tailf:info "Specify the line encoding method for a DS1 link";
        tailf:cli-full-command;
        type enumeration {
          enum ami {
            tailf:info "AMI encoding";
          }
          enum hdb3 {
            tailf:info "high-density bipolar 3";
          }
        }
      }
      list channel-group {
        tailf:info "Configure channel group on T1E1";
        tailf:cli-mode-name config-e1-channel_group;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-30>;;channel group number";
            range "0..30";
          }
        }
        leaf timeslots {
          tailf:info "List of timeslots in the channel group";
          type string {
            tailf:info "WORD;;timeslot string seprated by (:) or (-) from 1 to 31. (:) indicates individual timeslot and (-) represent range";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure t1e1 controller into down-when-looped mode";
        type empty;
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t1/e1  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list E3 {
      tailf:info "E3 Port controller(s)";
      tailf:cli-mode-name config-e3;
      key name;
      leaf name {
        type string {
          tailf:info "R/S/I/P;;Forward interface in Rack/Slot/Instance/Port format";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses description-grouping;
      leaf mode {
        tailf:info "Configure mode for the port";
        tailf:cli-full-command;
        type enumeration {
          enum atm {
            tailf:info "clear channel carrying atm";
          }
          enum e1 {
            tailf:info "channelize into 21 E1s";
          }
          enum serial {
            tailf:info "clear channel carrying hdlc like payload";
          }
          enum t1 {
            tailf:info "channelized into 28 T1s";
          }
        }
      }
      leaf framing {
        tailf:info "Configure T3/E3 framing";
        tailf:cli-full-command;
        type enumeration {
          enum g751 {
            tailf:info "E3 Framing G.751 (E3 default)";
          }
          enum g832 {
            tailf:info "E3 Framing G.832";
          }
        }
      }
      container dsu {
        tailf:info "Configure T3/E3 subrate(dsu)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-e3-dsu;
        leaf mode {
          tailf:info "Configure DSU mode";
          type enumeration {
            enum cisco {
              tailf:info "Set DSU mode to Cisco";
            }
            enum digital-link {
              tailf:info "Set DSU mode to Digital link";
            }
            enum kentrox {
              tailf:info "Set DSU mode to Kentrox";
            }
          }
        }
        leaf bandwidth {
          tailf:info "Configure DSU bandwidth";
          type uint16 {
            tailf:info "<300-34010>;;DSU subrate bandwidth range";
            range "300..34010";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure T3/E3 controller into down-when-looped mode";
        tailf:cli-full-command;
        type empty;
      }
      container clock {
        tailf:info "Configure clock source";
        container source {
          tailf:info "Configure t3/e3  TX clock source";
          choice source-choice {
            leaf internal {
              tailf:info "Select internal clock";
              type empty;
            }
            leaf line {
              tailf:info "Select clock recovered from line";
              type empty;
            }
            leaf recovered {
              tailf:info "Select Recovered clock";
              type uint8 {
                tailf:info "<0-23>;;Clock number";
                range "0..23";
              }
            }
          }
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list SONET {
      tailf:info "SONET/SDH Port controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-sonet;
      key id;
      leaf id {
        tailf:cli-case-insensitive;
        type string {
          tailf:info "WORD;;SONET Interface Instance";
          pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+.*";
        }
      }
      uses description-grouping;
      leaf ais-shut {
        tailf:info "Enable sending SONET/SDH LAIS when shutdown";
        tailf:cli-full-command;
        type empty;
      }
      container line {
        tailf:info "Configure SONET/SDH line parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sonet-line;
        container delay {
          tailf:info "alarm soaking";
          leaf clear {
            tailf:info "clear time";
            type uint32 {
              tailf:info "<1000-180000>;;Time in msec to soak before clearing the alarm (Default 10 seconds)";
              range "1000..180000";
            }
          }
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }
      container path {
        tailf:info "Configure SONET/SDH path parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sonet-path;
        container report {
          tailf:info "Configure SONET/SDH path alarm reporting";
          leaf pais {
            tailf:info "Set Path Alarm Indication Signal reporting status";
            type empty;
          }
          leaf prdi {
            tailf:info "Set Path Remote Defect Indication reporting status";
            type empty;
          }
        }
        leaf ais-shut {
          tailf:info "Enable sending SONET/SDH PAIS when shutdown";
          type empty;
        }
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
        leaf scrambling {
          tailf:info "Configure SONET/SDH SPE scrambling";
          type enumeration {
            enum disable;
            enum enable;
          }
        }
        container threshold {
          tailf:info "Configure SONET/SDH path BER threshold values";
          leaf b3-tca {
            tailf:info "Set B3 BER Threshold Crossing Alert (TCA) threshold";
            type uint8 {
              tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            }
          }
        }
      }
      leaf framing {
        tailf:info "Configure SONET/SDH framing";
        tailf:cli-full-command;
        type enumeration {
          enum sdh {
            tailf:info "Select SDH framing";
          }
          enum sonet {
            tailf:info "Select SONET framing (default)";
          }
        }
      }
      container report {
        tailf:info "Configure SONET/SDH section/line alarm reporting";
        leaf lais {
          tailf:info "Set Line Alarm Indication Signal reporting status";
          type empty;
        }
        leaf sd-ber {
          tailf:info "Set LBIP BER in excess of SD threshold reporting status";
          type empty;
        }
      }
      container overhead {
        tailf:info "Configure SONET/SDH SOH/LOH byte/bit values";
        leaf j0 {
          tailf:info "Specify STS identifier (J0/C1) byte";
          type uint8 {
            tailf:info "<0-255>;;J0/C1 byte value (default 0x01)";
            range "0..255";
          }
        }
        leaf s1s0 {
          tailf:info "Specify bits s1 and s0 of H1 byte";
          type uint8 {
            tailf:info "<0-3>;;s1 & s0 bits value (default 0x0)";
            range "0..3";
          }
        }
      }
      list sts {
        tailf:info "Configure SONET path parameters";
        tailf:cli-mode-name config-stsPath;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-48>;;Possible range is 1-3 for OC3, 1-12 for OC12.";
          }
        }
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural sts boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }
        container mode {
          tailf:info "Configure mode for the path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum pos {
                tailf:info "Configure pos mode for the path";
              }
              enum t3 {
                tailf:info "sonet path carrying T3";
              }
              enum vt15 {
                tailf:info "sonet path carrying VT15";
              }
              enum vt15-t1 {
                tailf:info "sonet path carrying VT15 T1";
              }
              enum vt2 {
                tailf:info "sonet path carrying VT2";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'" {
              tailf:xpath-root 3;
            }
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }
        container delay {
          tailf:info "alarm soaking";
          leaf trigger {
            tailf:info "trigger time";
            type uint16 {
              tailf:info "<0-60000>;;Time in msec to soak before declaring the alarm (Default No Delay)";
              range "0..60000";
            }
          }
        }
      }
      container threshold {
        tailf:info "Configure SONET/SDH section/line BER threshold values";
        leaf sf-ber {
          tailf:info "Set Signal Fail BER threshold";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 3)";
            range "3..9";
          }
        }
        leaf b1-tca {
          tailf:info "Set B1 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
        leaf b2-tca {
          tailf:info "Set B2 BER Threshold Crossing Alert (TCA) threshold";
          type uint8 {
            tailf:info "<3-9>;;Bit error rate (10 to the minus n) (default 6)";
            range "3..9";
          }
        }
      }
      leaf down-when-looped {
        tailf:info "Configure SONET/SDH controller into down-when-looped mode";
        type empty;
      }
      list au {
        tailf:info "Configure SDH path parameters";
        tailf:cli-mode-name config-auPath;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-48>;;au3 or au4 path range";
            range "1..48";
          }
        }
        leaf width {
          tailf:info "Configure width for the path";
          type uint16 {
            tailf:info "<1-768>;;Valid width(1,3,12,48..), natural au boundaries(1,4,7,10,13..)";
            range "1..768";
          }
        }
        container mode {
          tailf:info "Configure mode for the au path";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf carrying {
            tailf:cli-drop-node-name;
            type enumeration {
              enum atm {
                tailf:info "clear channel carrying atm";
              }
              enum c11 {
                tailf:info "au3 path carrying c11";
              }
              enum c11-t1 {
                tailf:info "au3 path carrying c11 t1";
              }
              enum c12 {
                tailf:info "au3 path carrying c12";
              }
              enum c12-e1 {
                tailf:info "au3 path carrying c12 e1";
              }
              enum e3 {
                tailf:info "au3 path carrying E3";
              }
              enum pos {
                tailf:info "Configure pos mode for au path";
              }
              enum t3 {
                tailf:info "au3 path carrying T3";
              }
              enum tug3 {
                tailf:info "au4 path carries TUG3";
              }
            }
          }
          leaf pos-option {
            tailf:cli-drop-node-name;
            when "../carrying = 'pos'" {
              tailf:xpath-root 3;
            }
            type enumeration {
              enum scramble {
                tailf:info "clear channel carrying POS scramble";
              }
              enum unscramble {
                tailf:info "clear channel carrying POS unscramble";
              }
            }
          }
        }
        list tug3 {
          tailf:info "Configure tug3 path parameters";
          tailf:cli-mode-name config-tug3Path;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-3>;;tug3 number range";
              range "1..3";
            }
          }
          container mode {
            tailf:info "Configure mode for the tug3 path";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf carrying {
              tailf:cli-drop-node-name;
              type enumeration {
                enum c11 {
                  tailf:info "tug3 path carrying TU-11";
                }
                enum c11-t1 {
                  tailf:info "tug3 path carrying TU-11 to t1";
                }
                enum c12 {
                  tailf:info "tug3 path carrying TU-12";
                }
                enum c12-e1 {
                  tailf:info "tug3 path carrying TU-12 to e1";
                }
                enum e3 {
                  tailf:info "au3 or all tug3 path carrying E3";
                }
                enum t3 {
                  tailf:info "au3 or all tug3 path carrying T3";
                }
              }
            }
          }
        }
      }
      container clock {
        tailf:info "Configure SONET/SDH port clock";
        leaf source {
          tailf:info "Configure SONET/SDH port TX clock source";
          type enumeration {
            enum internal {
              tailf:info "Select internal clock";
            }
            enum line {
              tailf:info "Select clock recovered from line (default)";
            }
          }
        }
      }
      container s1byte {
        tailf:info "Configure SONET/SDH controller to s1byte ignore mode";
        leaf ignore {
          tailf:info "Ignore S1 byte";
          type empty;
        }
      }
      leaf shutdown {
        tailf:info "Shutdown the selected controller";
        tailf:cli-full-command;
        tailf:cli-show-no;
        type empty;
      }
    }
    list wanphy {
      tailf:info "WANPHY controller(s)";
      tailf:cli-allow-join-with-key;
      tailf:cli-mode-name config-wanphy;
      key id;
      leaf id {
        type string {
          tailf:info "R/S/I/P;;Rack/Slot/Instance/Port format";
          pattern "[0-9]+(/[0-9]+)*";
        }
      }
      container lanmode {
        tailf:info "Configure Lan Mode On/Off";
        leaf on {
          tailf:info "Turn LanMode On";
          type empty;
        }
      }
      container wanmode {
        tailf:info "Configure Wan Mode On/Off";
        leaf on {
          tailf:info "Turn WanMode On";
          type empty;
        }
      }
    }
  }

  grouping set-list-grouping {
    list set {
      tailf:cli-drop-node-name;
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-show-long-obu-diffs;
      ordered-by user;
      key value;
      leaf value {
        tailf:cli-multi-word-key;
        tailf:cli-disallow-value end-set|abort|exit;
        type string {
          tailf:info "WORD;;extcommunity-set line";
          pattern ".*[^,]";
        }
      }
    }
  }

  grouping ipsla-reaction-operation-react-grouping {
    container action {
      tailf:info "Type of action to be taken on threshold violation(s)";
      leaf logging {
        tailf:info "Generate a syslog alarm on threshold violation";
        type empty;
      }
      leaf trigger {
        tailf:info "Generate trigger to active reaction triggered operation(s)";
        type empty;
      }
    }
    container threshold {
      tailf:info "Configure threshold parameters on monitored element";
      container type {
        tailf:info "Threshold type";
        choice type-choice {
          leaf immediate {
            tailf:info "Take action immediately upon threshold violation";
            type empty;
          }
          leaf consecutive {
            tailf:info "Take action after a number of consecutive violations";
            type uint8 {
              tailf:info "<1-16>;;Number of consecutive violations";
              range "1..16";
            }
          }
          leaf average {
            tailf:info "Take action on average values violate threshold";
            type uint8 {
              tailf:info "<1-16>;;Number of probes to average over";
              range "1..16";
            }
          }
        }
      }
      container limit {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-limit {
          tailf:info "Threshold lower limit";
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold lower limit value";
            range "1..4294967295";
          }
        }
        leaf upper-limit {
          tailf:info "Threshold upper limit";
          type uint32 {
            tailf:info "<1-4294967295>;;Threshold upper limit value";
            range "1..4294967295";
          }
        }
      }
    }
  }

  grouping interface-tunnel-te-auto-bw-threshold-grouping {
    container threshold {
      tailf:info "Set the bandwidth change percent to trigger an underflow/overflow";
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-siblings;
      }
      leaf percentage {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-command;
        type uint8 {
          tailf:info "<1-100>;;Bandwidth change percent to trigger an overflow";
          range "1..100";
        }
      }
      leaf min {
        tailf:info "Set the bandwidth change value to trigger an overflow";
        tailf:cli-optional-in-sequence;
        type uint32 {
          tailf:info "<10-4294967295>;;Bandwidth change value to trigger an overflow (kbps)";
          range "10..4294967295";
        }
      }
      leaf limit {
        tailf:info "Set the number of consecutive collections exceeding threshold";
        type uint8 {
          tailf:info "<1-10>;;Number of consecutive collections exceeding threshold";
          range "1..10";
        }
      }
    }
  }

  grouping router-ospf-domain-id-grouping {
    leaf type {
      tailf:info "OSPF domain ID type in Hex format";
      tailf:cli-incomplete-command;
      type enumeration {
        enum 0005 {
          tailf:info "Type 0x0005";
        }
        enum 0105 {
          tailf:info "Type 0x0105";
        }
        enum 0205 {
          tailf:info "Type 0x0205";
        }
        enum 8005 {
          tailf:info "Type 0x8005";
        }
      }
    }
    leaf value {
      tailf:info "OSPF domain ID value in Hex format";
      type string {
        tailf:info "WORD;;OSPF domain ID ext. community value in Hex (6 octets)";
      }
    }
  }

  grouping explicit-path-index-list-grouping {
    list index {
      tailf:cli-suppress-mode;
      tailf:cli-delete-when-empty;
      tailf:cli-compact-syntax;
      tailf:cli-sequence-commands {
        tailf:cli-reset-all-siblings;
      }
      key index-id;
      leaf index-id {
        type uint16 {
          tailf:info "<1-65535>;;Index number";
          range "1..65535";
        }
      }
      leaf keyword {
        tailf:cli-drop-node-name;
        type enumeration {
          enum exclude-address {
            tailf:info "Specify the next address to be excluded ";
          }
          enum exclude-srlg {
            tailf:info "Specify an IP Addr to get SRLGs from for exclusion";
          }
          enum next-address {
            tailf:info "Specify the next (adjacent) address in the path";
          }
          enum next-label {
            tailf:info "Specify the next (adjacent) address in the path";
          }
        }
      }
      leaf hop-type {
        when "../keyword = 'next-address'" {
          tailf:xpath-root 3;
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type enumeration {
          enum loose {
            tailf:info "Specify the next address in the path as a loose hop";
          }
          enum strict {
            tailf:info "Specify the next address in the path as a strict hop";
          }
        }
      }
      leaf label {
        when "../keyword = 'next-label'" {
          tailf:xpath-root 3;
        }
        tailf:cli-optional-in-sequence;
        tailf:cli-drop-node-name;
        type uint32;
      }
      container ipv4 {
        tailf:info "Specify the address AFI";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        leaf unicast {
          tailf:info "Specify the address SAFI";
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Enter IP address (A.B.C.D)";
          }
        }
      }
    }
  }

  grouping route-target-import-export-grouping {
    container route-target {
      tailf:info "Route Target";
      list route-target-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Two or Four Byte AS number or IP:nn";
          }
        }
      }
      leaf-list import {
        tailf:info "Import Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
      leaf-list export {
        tailf:info "Export Route Target";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;AS-number or IPv4 address:index";
        }
      }
    }
  }

  grouping username-grouping {
    list username {
      tailf:info "Configure user name";
      tailf:cli-mode-name config-un;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;User name";
        }
      }
      list group {
        tailf:info "User group in which this user will be a member of";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the user group";
          }
        }
      }
      container password {
        tailf:info "Specify the password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 7 {
              tailf:info "Specifies a HIDDEN password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The HIDDEN user password string";
          }
        }
      }
      leaf privilege {
        tailf:info "Set user privilege level";
        type uint8 {
          tailf:info "<0-15>;;User privilege level";
          range "0..15";
        }
      }
      container secret {
        tailf:info "Specify the secure password for the user";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 5 {
              tailf:info "Specifies that an encrypted password will follow";
            }
          }
        }
        leaf password {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;The user password string";
          }
        }
      }
    }
  }

  grouping clock-grouping {
    container clock {
      tailf:info "Configure time-of-day clock";
      tailf:cli-explicit-exit;
      leaf calendar-valid {
        tailf:info "Calendar time is authoritative";
        type empty;
      }
      container summer-time {
        tailf:info "Configure summer (daylight savings) time";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;name of time zone in summer";
          }
        }
        choice summer {
          case a {
            container date {
              tailf:info "Configure absolute summer time";
            }
          }
          case b {
            leaf recurring {
              type empty;
            }
            leaf start {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to start";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                pattern [0-9][0-9]:[0-9][0-9];
              }
            }
            leaf end {
              tailf:cli-drop-node-name;
              type union {
                type uint8 {
                  tailf:info "<1-4>;;Week number to end";
                  range "1..4";
                }
                type enumeration {
                  enum first {
                    tailf:info "First week of the month";
                  }
                  enum last {
                    tailf:info "Last week of the month";
                  }
                }
              }
            }
            leaf end-day {
              tailf:cli-drop-node-name;
              type enumeration {
                enum monday;
                enum tuesday;
                enum wednesday;
                enum thursday;
                enum friday;
                enum saturday;
                enum sunday;
              }
            }
            leaf end-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf end-time {
              tailf:cli-drop-node-name;
              type string {
                pattern [0-9][0-9]:[0-9][0-9];
              }
            }
          }
        }
      }
      container timezone {
        tailf:info "Configure time zone";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf zone {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;name of time zone";
          }
        }
        leaf hours-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<-23 - 23>;;Hours offset from UTC";
            range "-23..23";
          }
        }
        leaf minutes-offset {
          tailf:cli-drop-node-name;
          type int8 {
            tailf:info "<0-59>;;Minutes offset from UTC";
            range "0..59";
          }
        }
      }
    }
  }

  grouping exception-grouping {
    container exception {
      tailf:info "Coredump configuration commands";
      tailf:cli-explicit-exit;
      container exception-filepath {
        tailf:cli-drop-node-name;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-all-siblings;
        }
        leaf choice {
          tailf:info "Preference for the following dump location";
          tailf:cli-incomplete-command;
          type uint8 {
            tailf:info "<1-3>;;Order of preference";
            range "1..3";
          }
        }
        leaf compress {
          tailf:info "Compress the dump files";
          tailf:cli-incomplete-command;
          type enumeration {
            enum off {
              tailf:info "Do not compress core files dumped on this path";
            }
            enum on {
              tailf:info "Compress core files dumped on this path";
            }
          }
        }
        container filename {
          tailf:info "Dump file name";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Filename";
            }
          }
          leaf limit {
            tailf:cli-drop-node-name;
            type string {
              tailf:info lowlimit-highlimit;
            }
          }
        }
        leaf filepath {
          tailf:info "Give the dump location next";
          type string {
            tailf:info "WORD;;Protocol and directory";
          }
        }
      }
      leaf sparse {
        tailf:info "control sparse core dump";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable sparse core dump";
          }
          enum on {
            tailf:info "Enable sparse core dump by default";
          }
        }
      }
      leaf sprsize {
        tailf:info "Switch to sparse core dump at this size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<1-4095>;;Switch to sparse core dump size in MB";
          range "1..4095";
        }
      }
      leaf coresize {
        tailf:info "Only print out stack trace and create no core file beyond this size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-4095>;;Core file size max limit in MB";
          range "1..4095";
        }
      }
      leaf pakmem {
        tailf:info "control pakmem in core";
        tailf:cli-full-command;
        type enumeration {
          enum off {
            tailf:info "Disable dump of packet memory by default";
          }
          enum on {
            tailf:info "Dump packet memory for all process";
          }
        }
      }
    }
  }

  grouping average-cpu-used-grouping {
    leaf op {
      tailf:cli-drop-node-name;
      tailf:cli-incomplete-command;
      type operator-type;
    }
    leaf threshold {
      tailf:cli-drop-node-name;
      type uint8 {
        tailf:info "<0-100>;;Threshold value";
        range "0..100";
      }
    }
    leaf percent {
      tailf:info "Specify that threshold value is percent of previous sample";
      tailf:cli-optional-in-sequence;
      type empty;
    }
    container rearm {
      tailf:info "Specify Rearm parameters (default - always)";
      tailf:cli-flatten-container;
      tailf:cli-compact-syntax;
      choice rearm-choice {
        leaf toggle {
          tailf:info "Rearm after the first period when condition is not met";
          type empty;
        }
        leaf window {
          tailf:info "Rearm after the window of sampling periods";
          type uint8 {
            tailf:info "<1-100>;;Rearm window size";
            range "1..100";
          }
        }
      }
    }
  }

  augment "/ncs:devices/ncs:device/ncs:config" {
    container admin {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enter administrator/owner plane config";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-admin;
      tailf:cli-full-command;
      tailf:cli-exit-command exit-admin-config;
      uses username-grouping;
      container fpd {
        tailf:info "FPD firmware configuration";
        leaf auto-upgrade {
          tailf:info "FPD auto-upgrade configuration";
          type empty;
        }
      }
      container hw-module {
        tailf:info "Configure h/w module";
        container profile {
          tailf:info "Configure memory resource profile";
          leaf scale {
            tailf:info "Configure scale profile";
            tailf:cli-full-command;
            type enumeration {
              enum bng-max {
                tailf:info "BNG max scale profile";
              }
              enum default {
                tailf:info "Default scale profile";
              }
              enum l2 {
                tailf:info "L2 scale profile";
              }
              enum l3 {
                tailf:info "L3 scale profile (depricated)";
              }
              enum l3xl {
                tailf:info "L3 XL scale profile";
              }
              enum lsr {
                tailf:info "LSR scale profile";
              }
              enum sat {
                tailf:info "nV Satellite scale profile";
              }
            }
          }
        }
        container bfd-hw-offload {
          tailf:info "Configure BFD hw offload parameters";
          container enable {
            tailf:info "Enable BFD hw offload mode";
            leaf location {
              tailf:info "Configure line card location";
              type string {
                tailf:info "WORD;;Fully qualified line card specification";
              }
            }
          }
        }
      }
      uses clock-grouping;
      uses exception-grouping;
      container diagnostic {
        tailf:info "Configure diagnostic information";
        container bootup {
          tailf:info "Configure diagnostic for bootup";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf level {
            tailf:info "Select diagnostic level";
            tailf:cli-incomplete-command;
            type enumeration {
              enum complete {
                tailf:info "Complete level";
              }
              enum minimal {
                tailf:info "Minimal level";
              }
              enum bypass {
                tailf:info "Bypass diagnostic";
              }
            }
          }
          leaf location {
            tailf:info "Select location";
            type string {
              tailf:info "WORD;;Enter Location";
            }
          }
        }
        container monitor {
          tailf:info "Configure diagnostic monitoring tests";
          leaf syslog {
            tailf:info "Configure diagnostic monitoring syslog";
            type empty;
          }
        }
      }
      leaf xyzroot {
        tailf:info "Internal state variable, do not modify.";
        tailf:cli-run-template "";
        tailf:cli-show-with-default;
        type uint16;
        default 0;
      }
    }
    leaf version {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "XR Version";
      type string {
        tailf:info "XR version - READ ONLY";
      }
    }
    container configuration {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configuration related settings";
      tailf:cli-explicit-exit;
      container display {
        tailf:info "Display mode";
        container interface {
          tailf:info "hardware interfaces";
          leaf slot-order {
            tailf:info "Display interfaces in the slot-order in show run output";
            type empty;
          }
        }
      }
    }
    leaf hostname {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Set system's network name";
      type string {
        tailf:info "WORD;;This system's network name";
      }
    }
    list group {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "config group definition mode";
      tailf:cli-mode-name config-GRP;
      tailf:cli-exit-command end-group;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;config group name";
        }
      }
      list interface {
        tailf:info "Interface configuration subcommands";
        tailf:cli-mode-name config-GRP-if;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf mtu {
          tailf:info "Set the MTU on an interface";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<64-65535>;;MTU size in bytes";
            range "64..65535";
          }
        }
      }
    }
    leaf apply-group {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Apply configuration from a group";
      tailf:cli-remove-before-change;
      tailf:cli-full-command;
      type string {
        tailf:info "WORD;;Group name";
      }
    }
    uses clock-grouping {
      refine clock {
        tailf:ncs-device-type cli-ned;
        tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      }
    }
    container banner {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a login banner";
      container exec {
        tailf:info "Set EXEC process creation banner";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
      container incoming {
        tailf:info "Set incoming terminal line banner";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
      container motd {
        tailf:info "Set Message of the Day banner";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
      container login {
        tailf:info "Set login banner";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
      container slip-ppp {
        tailf:info "Set Message for SLIP/PPP";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
      container prompt-timeout {
        tailf:info "Set Message for login authentication timeout";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        uses banner-grouping;
      }
    }
    uses exception-grouping {
      refine exception {
        tailf:ncs-device-type cli-ned;
        tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      }
    }
    container cef {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "CEF related commands";
      container load-balancing {
        tailf:info "Load balance ";
        leaf fields {
          type enumeration {
            enum L3;
            enum L4;
          }
        }
      }
    }
    container explicit-path {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Explicit-path config commands";
      list name {
        tailf:info "Specify explicit path by name";
        tailf:cli-mode-name config-expl-path;
        key pathname;
        leaf pathname {
          type string {
            tailf:info "WORD;;Enter name";
          }
        }
        uses explicit-path-index-list-grouping;
      }
      list identifier {
        tailf:info "Specify explicit path by number";
        tailf:cli-mode-name config-expl-path;
        key identifier;
        leaf identifier {
          type uint16 {
            tailf:info "<1-65535>;;Enter number";
            range "1..65535";
          }
        }
        uses explicit-path-index-list-grouping;
      }
    }
    container selective-vrf-download {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      leaf disable {
        type empty;
      }
    }
    container vrf {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "VRF configuration commands";
      tailf:cli-explicit-exit;
      list vrf-list {
        tailf:cli-mode-name config-vrf;
        tailf:cli-drop-node-name;
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        leaf description {
          tailf:info "A description for the VRF";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Description for this VRF";
          }
        }
        leaf rd {
          tailf:info "Specify Route Distinguisher";
          tailf:cli-full-command;
          type union {
            type inet:ipv4-address;
            type string {
              tailf:info "ASN:nn or IP-address:nn;;VPN Route Distinguisher";
            }
          }
        }
        container vpn {
          tailf:info "VPN ID for the VRF";
          leaf id {
            tailf:info "VPN ID for the VRF";
            type string {
              tailf:info "<0-ffffff>:;;VPN ID, (OUI:VPN-Index) format(hex), 3 bytes OUI Part";
            }
          }
        }
        container address-family {
          tailf:info "AFI/SAFI configuration";
          container ipv4 {
            tailf:info "IPv4 address family";
            container unicast {
              tailf:info "Unicast topology";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-vrf-af;
              presence true;
              uses vrf-af-ipv4-grouping;
            }
            container flowspec {
              tailf:info "Flowspec sub address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-vrf-af;
              presence true;
              uses vrf-af-ipv4-grouping;
            }
          }
          container ipv6 {
            tailf:info "IPv6 address family";
            container unicast {
              tailf:info "Unicast topology";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-vrf-af;
              presence true;
              container import {
                tailf:info "VRF import";
                leaf route-policy {
                  tailf:info "Use route-policy for import filtering";
                  type string {
                    tailf:info "WORD;;Name of the policy";
                  }
                  tailf:non-strict-leafref {
                    path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                      tailf:xpath-root 3;
                    }
                  }
                }
                container route-target {
                  tailf:info "Specify import route target extended communities";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-vrf-import-rt;
                  uses vrf-route-target-grouping;
                }
              }
              container export {
                tailf:info "VRF export";
                leaf route-policy {
                  tailf:info "Use route-policy for export filtering";
                  type string {
                    tailf:info "WORD;;Name of the policy";
                  }
                  tailf:non-strict-leafref {
                    path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:route-policy/name" {
                      tailf:xpath-root 3;
                    }
                  }
                }
                container route-target {
                  tailf:info "Specify export route target extended communities";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-vrf-export-rt;
                  uses vrf-route-target-grouping;
                }
              }
              container maximum {
                tailf:info "Set maximum prefix limit";
                container prefix {
                  tailf:info "Set table's maximum prefix limit";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-all-siblings;
                  }
                  leaf limit {
                    tailf:cli-drop-node-name;
                    type uint32 {
                      tailf:info "<32-5000000>;;Maximum table's prefix limit";
                      range "32..5000000";
                    }
                  }
                  leaf mid-thresh {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-100>;;mid-thresh (% of max)";
                      range "1..100";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container ethernet {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Ethernet configuration commands";
      container sla {
        tailf:info "Service-Level Agreement configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sla;
        list profile {
          tailf:info "Per-profile configuration";
          tailf:cli-mode-name config-sla-prof;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          leaf type {
            tailf:info "Type of packet that operations using this profile will send";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum cfm-delay-measurement {
                tailf:info "CFM delay measurement packets";
              }
              enum cfm-delay-measurement-version-0 {
                tailf:info "CFM delay measurement version 0 packets";
              }
              enum cfm-loopback {
                tailf:info "CFM loopback packets";
              }
              enum cfm-loss-measurement {
                tailf:info "CFM loss measurement packets";
              }
              enum cfm-synthetic-loss-measurement {
                tailf:info "CFM synthetic loss measurement packets";
              }
            }
          }
          container probe {
            tailf:info "SLA Probe configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-sla-prof-pb;
            container send {
              tailf:info "Configure properties of packets to send";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf type {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type enumeration {
                  enum burst {
                    tailf:info "Send bursts of packets";
                  }
                  enum packet {
                    tailf:info "Send single packets";
                  }
                }
              }
              leaf every {
                tailf:info "Specify how often packets within a probe should be sent";
                type uint16 {
                  tailf:info "<1-10000>;;Interval between packets";
                }
              }
              leaf every-time {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum seconds {
                    tailf:info "Time is in seconds";
                  }
                  enum minutes {
                    tailf:info "Time is in minutes";
                  }
                  enum hours {
                    tailf:info "Time is in hours";
                  }
                }
              }
            }
            leaf priority {
              tailf:info "Specify the priority to use when sending packets";
              type uint8 {
                tailf:info "<0-7>;;Packet priority of each packet in the probe";
                range "0..7";
              }
            }
          }
          container schedule {
            tailf:info "SLA Schedule configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-sla-prof-schedule;
            container every {
              tailf:info "Specify scheduling frequency";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf number {
                tailf:cli-drop-node-name;
                tailf:cli-incomplete-command;
                type uint8 {
                  tailf:info "<1-90>;;Interval between operations (hours or minutes)";
                  range "1..90";
                }
              }
              leaf every-time {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum minutes {
                    tailf:info "Time is in minutes";
                  }
                  enum hours {
                    tailf:info "Time is in hours";
                  }
                }
              }
              leaf for {
                tailf:info "Specify how long operations should keep running for";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<1-3600>;;Duration of operation (may be seconds, minutes, hours, days, or weeks)";
                  range "1..3600";
                }
              }
              leaf for-time {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum seconds {
                    tailf:info "Time is in seconds";
                  }
                  enum minutes {
                    tailf:info "Time is in minutes";
                  }
                }
              }
            }
          }
          container statistics {
            tailf:info "SLA Statistics-collection configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-sla-prof-stat;
            list measure {
              tailf:info "Specify the type of statistics to collect";
              tailf:cli-mode-name config-sla-prof-stat-cfg;
              key id;
              leaf id {
                type enumeration {
                  enum one-way-delay-ds {
                    tailf:info "Collect one-way (destination-to-source) delay";
                  }
                  enum one-way-delay-sd {
                    tailf:info "Collect one-way (source-to-destination) delay";
                  }
                  enum one-way-jitter-ds {
                    tailf:info "Collect one-way (destination-to-source) jitter";
                  }
                  enum one-way-jitter-sd {
                    tailf:info "Collect one-way (source-to-destination) jitter";
                  }
                  enum round-trip-delay {
                    tailf:info "Collect round-trip delay";
                  }
                  enum round-trip-jitter {
                    tailf:info "Collect round-trip jitter";
                  }
                }
              }
              container aggregate {
                tailf:info "Specify how results should be aggregated";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                choice aggregate-choice {
                  case none {
                    leaf none {
                      tailf:info "Perform no aggregation";
                      type empty;
                    }
                  }
                  case bins-width {
                    leaf bins {
                      tailf:info "Aggregate results into a number of bins";
                      tailf:cli-incomplete-command;
                      type uint8 {
                        tailf:info "<2-100>;;Number of bins to distribute results between";
                        range "2..100";
                      }
                    }
                    leaf width {
                      tailf:info "Specify the width of each bin (in millisecondsfor delay or percentage points for loss)";
                      type uint16 {
                        tailf:info "<1-10000>;;Width (in milliseconds for delay or percentage points for loss)";
                        range "1..10000";
                      }
                    }
                  }
                }
              }
              container buckets {
                tailf:info "Bucket configuration";
                container size {
                  tailf:info "Configure the size of each bucket";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf number {
                    tailf:cli-drop-node-name;
                    type uint8 {
                      tailf:info "<1-100>;;Size of each bucket (number of probes-per-bucket)";
                      range "1..100";
                    }
                  }
                  leaf probes {
                    tailf:info "Buckets span multiple probes";
                    type empty;
                  }
                }
                leaf archive {
                  tailf:info "Configure the number of buckets to store internally";
                  type uint8 {
                    tailf:info "<1-100>;;Number of buckets to store internally";
                    range "1..100";
                  }
                }
              }
            }
          }
        }
      }
      container cfm {
        tailf:info "802.1ag Connectivity Fault Management configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-cfm;
        container traceroute {
          tailf:info "Traceroute configuration";
          container cache {
            tailf:info "Configure traceroute cache parameters";
            tailf:cli-compact-syntax;
            tailf:cli-reset-container;
            leaf hold-time {
              tailf:info "Traceroute cache hold-time";
              type uint32 {
                tailf:info "<1-525600>;;Hold-time, in minutes";
              }
            }
            leaf size {
              tailf:info "Traceroute cache size (number of replies)";
              type uint32 {
                tailf:info "<1-4294967295>;;Number of replies in the traceroute cache";
              }
            }
          }
        }
        list domain {
          tailf:info "Per domain configuration";
          tailf:cli-mode-name config-cfm-dmn;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Domain name (up to 80 chars)";
            }
          }
          leaf level {
            tailf:info "Level of this domain";
            tailf:cli-hide-in-submode;
            type uint8 {
              tailf:info "<0-7>;;Level";
            }
          }
          container id {
            tailf:info "Maintenance Domain Identifier";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            tailf:cli-hide-in-submode;
            choice id-choice {
              leaf null {
                tailf:info "No MDID value";
                type empty;
              }
              leaf string {
                tailf:info String;
                type string {
                  tailf:info "WORD;;String (up to 43 chars)";
                  length "1..43";
                }
              }
            }
          }
          list service {
            tailf:info "Per service configuration";
            tailf:cli-mode-name config-cfm-dmn-svc;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            tailf:cli-incomplete-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Service name (up to 80 chars)";
              }
            }
            choice service-type {
              container bridge {
                tailf:info "Use a Bridge Domain. All MEPs will be Up MEPs; MIPs are permitted";
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf group {
                  tailf:info "Bridge Domain Group";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Bridge Domain Group Name";
                  }
                }
                leaf bridge-domain {
                  tailf:info "Bridge Domain";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Bridge Domain Name";
                  }
                }
              }
              container xconnect {
                tailf:info "Use a Cross Connect. All MEPs will be Up MEPs;MIPs are permitted";
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf group {
                  tailf:info "Cross Connect Group";
                  tailf:cli-incomplete-command;
                  type string {
                    tailf:info "WORD;;Cross Connect Group Name";
                  }
                }
                leaf p2p {
                  tailf:info "Point-to-Point Cross Connect";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Cross Connect Name";
                  }
                }
              }
              container down-meps {
                tailf:info "Down MEPs; no MIPs permitted";
                tailf:cli-hide-in-submode;
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                presence true;
              }
            }
            container continuity-check {
              tailf:cli-break-sequence-commands;
              tailf:info "Continuity-check configuration";
              container interval {
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands;
                leaf value {
                  tailf:info "Set the continuity-check interval";
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "WORD;;Interval of 3.3ms|10ms|100ms|1s|10s|1m|10m";
                  }
                }
                leaf loss-threshold {
                  tailf:info "Set the continuity-check loss threshold";
                  type uint8 {
                    tailf:info "<2-255>;;Loss threshold (in number of CCMs)";
                  }
                }
              }
              container archive {
                tailf:info "Set the continuity-check archive hold time";
                leaf hold-time {
                  tailf:info "Set the continuity-check archive hold time";
                  type uint16 {
                    tailf:info "<1-65535>;;Hold time (in minutes)";
                    range "1..65535";
                  }
                }
              }
              container loss {
                tailf:info "Loss threshold actions";
                leaf auto-traceroute {
                  tailf:info "Automatically trigger a traceroute when a MEP times out";
                  type empty;
                }
              }
            }
            container log {
              tailf:info "Enable logging for particular types of event";
              container continuity-check {
                tailf:info "Enable continuity-check logging";
                leaf errors {
                  tailf:info "Enable logging when continuity-check errors are detected";
                  type empty;
                }
                container mep {
                  tailf:info "Enable MEP continuity-check logging";
                  leaf changes {
                    tailf:info "Enable logging on peer MEP state changes";
                    type empty;
                  }
                }
              }
              leaf ais {
                tailf:info "Enable logging when AIS or LCK messages are received";
                type empty;
              }
              container crosscheck {
                tailf:info "Enable crosscheck logging";
                leaf errors {
                  tailf:info "Enable logging when crosscheck errors are detected";
                  type empty;
                }
              }
            }
            container mip {
              tailf:info "MIP configuration";
              container auto-create {
                tailf:info "MIP auto-creation policy";
                leaf all {
                  tailf:info "Create MIPs on all interfaces";
                  type empty;
                }
              }
            }
            container mep {
              tailf:info "MEP configuration";
              container crosscheck {
                tailf:info "Statically define the Maintenence End Points with a Maintenance Association to be cross-checked";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-cfm-xcheck;
                list mep-id {
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-8191>;;MEP ID";
                      range "1..8191";
                    }
                  }
                  leaf mac-address {
                    tailf:info "Expected MAC Address for the specified MEP";
                    type string {
                      tailf:info "H.H.H;;48-bit MAC address";
                    }
                  }
                }
              }
            }
            container efd {
              presence true;
            }
          }
        }
      }
      container oam {
        tailf:info "Configure information relating to Ethernet Link OAM";
        list profile {
          tailf:info "802.3 OAM profiles";
          tailf:cli-mode-name config-eoam;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;The name of the profile";
            }
          }
          leaf hello-interval {
            tailf:info "Hello interval time";
            tailf:cli-full-command;
            type enumeration {
              enum 100ms {
                tailf:info "100 millisecond hello interval";
              }
            }
          }
          container link-monitor {
            tailf:info "Enter link-monitor submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-eoam-lm;
            container frame {
              tailf:info "Frame event configuration";
              leaf window {
                tailf:info "window size for frame event configuration";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1000-60000>;;Size of the frame window in milliseconds";
                  range "1000..60000";
                }
              }
              container threshold {
                tailf:info "threshold configuration for frame events";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf low {
                  tailf:info "low threshold for frame events";
                  type uint32 {
                    tailf:info "<0-12000000>;;The low threshold for frame events";
                    range "0..12000000";
                  }
                }
                leaf high {
                  tailf:info "high threshold for frame events";
                  type uint32 {
                    tailf:info "<1-12000000>;;The high threshold for frame events";
                    range "1..12000000";
                  }
                }
              }
            }
          }
          container require-remote {
            tailf:info "Enter require-remote submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-eoam-require;
            leaf link-monitoring {
              tailf:info "Requirement of Link monitoring support";
              type empty;
            }
          }
          container action {
            tailf:info "Enter action submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-eoam-action;
            leaf high-threshold {
              tailf:info "Action to perform when a high-threshold is crossed";
              tailf:cli-full-command;
              type enumeration {
                enum error-disable-interface {
                  tailf:info "disable the interface";
                }
                enum log {
                  tailf:info "Log the event";
                }
              }
            }
          }
        }
      }
    }
    container logging {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify message logging facilities";
      tailf:cli-explicit-exit;
      leaf disable {
        tailf:cli-full-command;
        type empty;
      }
      leaf trap {
        tailf:info "Set syslog server logging level";
        tailf:cli-full-command;
        type severity-type;
      }
      container events {
        tailf:info "Configure event monitoring parameters";
        leaf level {
          tailf:info "Log all events with equal or higher (lower level) severity";
          type severity-type;
        }
        leaf link-status {
          tailf:info "Enable or disable UP/DOWN state notifications for all interfaces";
          type enumeration {
            enum disable {
              tailf:info "Disable state UP/DOWN notifications for all interfaces";
            }
            enum software-interfaces {
              tailf:info "Enable state UP/DOWN notification for software interfaces";
            }
          }
        }
        leaf threshold {
          tailf:info "Configure threshold (%) for capacity alarm";
          type uint8 {
            tailf:info "<10-100>;;Capacity alarm threshold";
          }
        }
      }
      container archive {
        tailf:info "logging to a persistent device(disk/harddisk)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-logging-arch;
        leaf device {
          tailf:info "Configure the archive device";
          type string {
            tailf:info "WORD;;Disk to use as the archive device";
          }
        }
        leaf severity {
          tailf:info "The minimum severity of log messages to archive";
          type severity-type;
        }
        leaf file-size {
          tailf:info "The maximum file size for a single log file";
          type uint32 {
            tailf:info "<1-2047>;;Size in MB";
            range "1..2047";
          }
        }
        leaf frequency {
          tailf:info "The collection interval for logs";
          type enumeration {
            enum daily {
              tailf:info "Collect log in files on a daily basis";
            }
            enum weekly {
              tailf:info "Collect log in files on a weekly basis";
            }
          }
        }
        leaf archive-size {
          tailf:info "The total size of the archive";
          type uint32 {
            tailf:info "<1-2047>;;Size in MB";
            range "1..2047";
          }
        }
        leaf archive-length {
          tailf:info "The maximum no of weeks of log to maintain";
          type uint32 {
            tailf:info "<0-4294967295>;;Number of weeks";
          }
        }
      }
      leaf monitor {
        tailf:info "Set terminal line (monitor) logging parameters";
        tailf:cli-full-command;
        type severity-type;
      }
      container buffered {
        tailf:info "Set buffered logging parameters";
        leaf type {
          tailf:cli-drop-node-name;
          type union {
            type uint32 {
              tailf:info "<4096-2147483647>;;Logging buffer size";
              range "4096..2147483647";
            }
            type severity-type;
          }
        }
      }
      leaf facility {
        tailf:info "Facility parameter for syslog messages";
        tailf:cli-full-command;
        type union {
          type enumeration {
            enum local0;
            enum local1;
            enum local2;
            enum local3;
            enum local4;
            enum local5;
            enum local6;
            enum local7;
          }
          type string {
            tailf:info "WORDD;logging facility param";
          }
        }
      }
      list host {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        key address;
        leaf address {
          type union {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address of the logging host";
            }
            type inet:ipv6-address {
              tailf:info "X:X::X;;IPv6 address of the logging host";
            }
          }
        }
        leaf vrf {
          tailf:info "Set VRF option";
          type string {
            tailf:info "WORD  VPN Routing/Forwarding instance name";
          }
        }
        leaf severity {
          tailf:info "Set severity of  messages for particular remote host/vrf";
          type severity-type;
        }
        leaf port {
          tailf:info "Set UDP port for this remote host/vrf";
          type union {
            type enumeration {
              enum default {
                tailf:info "default Port";
              }
            }
            type uint32 {
              tailf:info "<0-4294967295>;;non-default Port";
              range "0..4294967295";
            }
          }
        }
      }
      leaf localfilesize {
        tailf:info "Set size of the local log file";
        type uint32 {
          tailf:info "<0-4294967295>;;Size of the local log file";
        }
      }
      container source-interface {
        tailf:info "Specify interface for source address in logging transactions";
        uses interface-name-grouping;
      }
      container cns-events {
        tailf:info "Set CNS Event logging level";
        presence true;
        tailf:cli-reset-container;
        tailf:cli-delete-when-empty;
        leaf severity {
          type severity-type;
        }
      }
      leaf console {
        tailf:info "Set console logging parameters";
        tailf:cli-full-command;
        type union {
          type severity-type;
          type enumeration {
            enum disable {
              tailf:info "Disable logging";
              value -1;
            }
          }
        }
      }
      leaf count {
        tailf:info "Count every log message and timestamp last occurance";
        tailf:cli-full-command;
        type empty;
      }
      leaf history {
        tailf:info "Set history logging";
        tailf:cli-full-command;
        type severity-type;
      }
      container suppress {
        tailf:info "Configure properties for the event suppression";
        leaf duplicates {
          tailf:info "Suppress consecutive duplicate messages";
          tailf:cli-full-command;
          type empty;
        }
        list rule {
          tailf:info "Configure a specified suppression rule";
          tailf:cli-mode-name config-suppr-rule;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Rule name";
            }
          }
          list alarm {
            tailf:info "Specify alarm: Category/Group/Code combos";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "msg-category group-name msg-code";
            leaf msg-category {
              type string {
                tailf:info "WORD;;Message category of the suppressed message";
              }
            }
            leaf group-name {
              type string {
                tailf:info "WORD;;Group name of suppressed message";
              }
            }
            leaf msg-code {
              type string {
                tailf:info "WORD;;Message code of suppressed message";
              }
            }
          }
        }
        container apply {
          tailf:info "Apply suppression rule";
          list rule {
            tailf:info "Apply suppression rule";
            tailf:cli-mode-name config-suppr-apply-rule;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Rule name";
              }
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:logging/suppress/rule/name" {
                  tailf:xpath-root 3;
                }
              }
            }
            leaf all-of-router {
              tailf:info "Apply the rule to all of the router";
              tailf:cli-full-command;
              type empty;
            }
            container source {
              tailf:info "Apply rule to specified source";
              leaf location {
                tailf:info "Apply rule to specified location";
                type string {
                  tailf:info "WORD;;Fully qualified source specification";
                }
              }
            }
          }
        }
      }
      leaf hostnameprefix {
        tailf:info "Hostname prefix to add on msgs to servers";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;hostname prefix string";
        }
      }
    }
    container service {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify use of network based services";
      tailf:cli-explicit-exit;
      container alignment {
        tailf:info "Control alignment correction and logging";
        leaf detection {
          tailf:info "Enable detection of alignment issues";
          tailf:cli-full-command;
          type empty;
        }
        leaf logging {
          tailf:info "Enable logging of alignment issues";
          tailf:cli-full-command;
          type empty;
        }
      }
      leaf call-home {
        tailf:info "Enable call-home service";
        tailf:cli-full-command;
        type empty;
      }
      leaf compress-config {
        tailf:info "Compress the nvram configuration file";
        type empty;
        tailf:cli-full-command;
      }
      container counters {
        tailf:info "Control aging of interface counters";
        container max {
          tailf:info "Maximum counter aging threshold";
          leaf age {
            tailf:info "Aging threshold";
            type uint8 {
              tailf:info "<0-60>;;Aging threshold value in seconds";
            }
          }
        }
      }
      leaf dhcp {
        tailf:info "Enable DHCP server and relay agent";
        tailf:cli-full-command;
        type empty;
      }
      leaf disable-ip-fast-frag {
        tailf:info "Disable IP particle-based fast fragmentation";
        type empty;
      }
      leaf exec-callback {
        tailf:info "Enable exec callback";
        type empty;
      }
      leaf exec-wait {
        tailf:info "Delay EXEC startup on noisy lines";
        type empty;
      }
      leaf finger {
        tailf:info "Allow responses to finger requests";
        type empty;
      }
      container heartbeat {
        tailf:info "Enable heartbeat processing";
        leaf fatal-count {
          tailf:info "Set heartbeat fatal count";
          type uint8 {
            range "1..60";
            tailf:info "<1-60>;;Number of timeouts until fatal error occurs";
          }
        }
        leaf interrupt-interval {
          tailf:info "Set heartbeat interrupt test interval";
          type uint8 {
            range "0..60";
            tailf:info "<0-60>;;Interval between interrupt level tests";
          }
        }
        leaf interrupt-max {
          tailf:info "Set maximum message count from interrupt test";
          type uint8 {
            tailf:info "<0-60>;;Maximum number of messages from interrupt test";
            range "0..60";
          }
        }
        leaf transmit-interval {
          tailf:info "Set heartbeat transmit interval";
          type uint8 {
            tailf:info "<1-30>;;Interval between heartbeat transmissions";
            range "1..30";
          }
        }
        leaf warning-timeout {
          tailf:info "Set heartbeat warning timeout interval";
          type uint8 {
            tailf:info "<5-60>;;Interval between heartbeat timeout warnings";
            range "5..60";
          }
        }
      }
      leaf hide-telnet-addresses {
        tailf:info "Hide destination addresses in telnet command";
        type empty;
      }
      leaf linenumber {
        tailf:info "enable line number banner for each exec";
        type empty;
      }
      leaf nagle {
        tailf:info "Enable Nagle's congestion control algorithm";
        type empty;
      }
      leaf old-slip-prompts {
        tailf:info "Allow old scripts to operate with slip/ppp";
        type empty;
      }
      container pad {
        tailf:info "Enable PAD commands";
        presence true;
        leaf cmns {
          tailf:info "Enable PAD over CMNS connections";
          type empty;
        }
        leaf from-xot {
          tailf:info "Accept XOT to PAD connections";
          type empty;
        }
        leaf to-xot {
          tailf:info "Allow outgoing PAD over XOT connections";
          type empty;
        }
      }
      leaf password-encryption {
        tailf:info "Encrypt system passwords";
        type empty;
      }
      container prompt {
        tailf:info "Enable mode specific prompt";
        leaf config {
          tailf:info "Enable configuration mode prompt";
          type empty;
        }
      }
      leaf pt-vty-logging {
        tailf:info "Log significant VTY-Async events";
        type empty;
      }
      leaf sequence-numbers {
        tailf:info "Stamp logger messages with a sequence number";
        type empty;
      }
      leaf slave-log {
        tailf:info "Enable log capability of slave IPs";
        type empty;
      }
      leaf tcp-keepalives-in {
        tailf:info "Generate keepalives on idle incoming network connections";
        type empty;
        tailf:cli-full-command;
      }
      leaf tcp-keepalives-out {
        tailf:info "Generate keepalives on idle outgoing network connections";
        type empty;
        tailf:cli-full-command;
      }
      container tcp-small-servers {
        tailf:info "Enable small TCP servers (e.g., ECHO)";
        presence true;
        leaf max-servers {
          tailf:info "Set number of allowable TCP small servers";
          type union {
            type uint32 {
              tailf:info "<1-2147483647>;;Maximum TCP small servers";
              range "1..2147483647";
            }
            type enumeration {
              enum no-limit {
                tailf:info "No limit to number of allowable TCP small servers";
              }
            }
          }
        }
      }
      leaf telnet-zeroidle {
        tailf:info "Set TCP window 0 when connection is idle";
        type empty;
      }
      container timestamps {
        tailf:info "Timestamp debug/log messages";
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        presence true;
        container debug {
          tailf:info "Timestamp debug messages";
          choice log-time-choice {
            container datetime {
              tailf:info "Timestamp with date and time";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-delete-when-empty;
              presence true;
              leaf localtime {
                tailf:info "Use local time zone for timestamps";
                type empty;
              }
              leaf msec {
                tailf:info "Include milliseconds in timestamp";
                type empty;
              }
              leaf show-timezone {
                tailf:info "Add time zone information to timestamp";
                type empty;
              }
              leaf year {
                tailf:info "Include year in timestamp";
                type empty;
              }
            }
            leaf uptime {
              tailf:info "Timestamp with system uptime";
              type empty;
            }
          }
        }
        container log {
          tailf:info "Timestamp log messages";
          choice log-time-choice {
            container datetime {
              tailf:info "Timestamp with date and time";
              tailf:cli-compact-syntax;
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf localtime {
                tailf:info "Use local time zone for timestamps";
                type empty;
              }
              leaf msec {
                tailf:info "Include milliseconds in timestamp";
                type empty;
              }
              leaf show-timezone {
                tailf:info "Add time zone information to timestamp";
                type empty;
              }
              leaf year {
                tailf:info "Include year in timestamp";
                type empty;
              }
            }
            leaf uptime {
              tailf:info "Timestamp with system uptime";
              type empty;
            }
          }
        }
      }
      container udp-small-servers {
        tailf:info "Enable small UDP servers (e.g., ECHO)";
        presence true;
        leaf max-servers {
          tailf:info "Set number of allowable UDP small servers";
          type union {
            type uint32 {
              tailf:info "<1-2147483647>;;Maximum UDP small servers";
              range "1..2147483647";
            }
          }
        }
      }
      leaf unsupported-transceiver {
        tailf:cli-full-command;
        type empty;
      }
    }
    container event {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Event related commands";
      tailf:cli-explicit-exit;
      container manager {
        tailf:info "Event Manager configuration commands";
        container directory {
          tailf:info "Set Embedded Event Manager directory information";
          container user {
            tailf:info "Set Embedded Event Manager user directory information";
            leaf policy {
              tailf:info "Set Embedded Event Manager user policy directory";
              type string {
                tailf:info "WORD;;Path of the Embedded Event Manager user policy directory";
              }
            }
            leaf library {
              tailf:info "Set Embedded Event Manager user library directory";
              type string {
                tailf:info "WORD;;Path of the Embedded Event Manager user library directory";
              }
            }
          }
        }
        list policy {
          tailf:info "Register an Event Manager policy";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the policy file";
            }
          }
          leaf username {
            tailf:info "Username under whom this policy will execute";
            type string {
              tailf:info "WORD;;A Configured username";
            }
          }
          leaf persist-time {
            tailf:cli-break-sequence-commands;
            tailf:info "Time of validity (in seconds) for cached AAA taskmap of username (default is 3600)";
            type union {
              type enumeration {
                enum infinite {
                  tailf:info "Cached AAA taskmap of username is always treated valid";
                }
              }
              type uint32 {
                tailf:info "<0-4294967294>;;Integer value for this policy's persist-time";
              }
            }
          }
          leaf type {
            tailf:info "The Event Manager type of this policy";
            type enumeration {
              enum system {
                tailf:info "Event Manager system policy";
              }
              enum user {
                tailf:info "Event Manager user policy";
              }
            }
          }
        }
        list environment {
          tailf:info "Set an Embedded Event Manager global variable for policies";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the global variable";
            }
          }
          leaf var-value {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;Value of the global variable";
            }
          }
        }
      }
    }
    container domain {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Domain service related commands";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "Ipv4 hosts";
        list host {
          tailf:info "Add an entry to the ip hostname table";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key host-name;
          leaf host-name {
            type string {
              tailf:info "WORD;;Name of host";
            }
          }
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            ordered-by user;
            max-elements 8;
            type string {
              tailf:info "A.B.C.D;;Host IP address (maximum of 8";
            }
          }
        }
      }
      container ipv6 {
        tailf:info "Ipv6 hosts";
        list host {
          tailf:info "Add an entry to the ipv6 hostname table";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key host-name;
          leaf host-name {
            type string {
              tailf:info "WORD;;Name of host";
            }
          }
          leaf-list address {
            tailf:cli-drop-node-name;
            tailf:cli-flat-list-syntax;
            ordered-by user;
            max-elements 4;
            type string {
              tailf:info "X:X::X;;IPv6 name or address (maximum four addresses";
            }
          }
        }
      }
      container lookup {
        tailf:info "Enable Domain Name System hostname translation";
        leaf disable {
          tailf:info "Disable Domain Name System hostname translation";
          tailf:cli-full-command;
          type empty;
        }
        container source-interface {
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
      leaf name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }
      leaf list {
        tailf:info "Domain name to complete unqualified host names";
        type string {
          tailf:info "WORD;;A domain name";
        }
      }
      list name-server {
        tailf:info "Specify address of name server to use";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key address;
        leaf address {
          type inet:host;
        }
      }
      list vrf {
        tailf:info "VRF name for domain services";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        leaf name {
          tailf:info "Define the default domain name";
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;Default domain name";
          }
        }
        container lookup {
          tailf:info "Enable Domain Name System hostname translation";
          tailf:cli-reset-container;
          leaf disable {
            tailf:info "Disable Domain Name System hostname translation";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
    }
    container forward-protocol {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Controls forwarding of physical and directed IP broadcasts";
      container udp {
        tailf:info "Packets to a specific UDP port";
        list port-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key port;
          leaf port {
            type union {
              type uint16 {
                tailf:info "<1-65535>;;Port number";
                range "1..65535";
              }
              type enumeration {
                enum domain {
                  tailf:info "Domain Name Service (DNS, 53)";
                  value 53;
                }
                enum nameserver {
                  tailf:info "IEN116 name service (obsolete, 42)";
                  value 42;
                }
                enum netbios-dgm {
                  tailf:info "NetBios datagram service (138)";
                  value 138;
                }
                enum netbios-ns {
                  tailf:info "NetBios name service (137)";
                  value 137;
                }
                enum tacacs {
                  tailf:info "TAC Access Control System (49)";
                  value 49;
                }
                enum tftp {
                  tailf:info "Trivial File Transfer Protocol (69)";
                  value 69;
                }
              }
            }
          }
          leaf disable {
            tailf:info "Disable IP Forward Protocol UDP for a specific port";
            type empty;
          }
        }
      }
    }
    list taskgroup {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure task group";
      tailf:cli-mode-name config-tg;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Taskgroup name";
        }
      }
      container task {
        tailf:info "Specify a task ID to be part of this group";
        list execute {
          tailf:info "Specify a execute-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type task-type;
          }
        }
        list read {
          tailf:info "Specify a read-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type task-type;
          }
        }
        list write {
          tailf:info "Specify a write-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type task-type;
          }
        }
        list debug {
          tailf:info "Specify a debug-type task ID";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type task-type;
          }
        }
      }
      container inherit {
        tailf:info "Inherit to include into this taskgroup";
        list taskgroup {
          tailf:info "Specify a taskgroup to inherit from";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the task group to include";
            }
          }
        }
      }
      leaf description {
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;description";
        }
      }
    }
    container radius {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "RADIUS configuration commands";
      tailf:cli-explicit-exit;
      container source-interface {
        tailf:info "Specify interface for source address in RADIUS packets";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
        leaf vrf {
          tailf:info "VRF for this source interface configuration";
          type string {
            tailf:info "WORD;;Name of the VRF";
          }
        }
      }
    }
    container radius-server {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "RADIUS server definition";
      tailf:cli-explicit-exit;
      list host {
        tailf:info "Specify a RADIUS server";
        tailf:cli-mode-name config-radius-host;
        tailf:cli-compact-syntax;
        key id;
        leaf id {
          type inet:host {
            tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
          }
        }
        leaf auth-port {
          tailf:info "UDP port for RADIUS authentication server (default is 1645)";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<0-65535>;;Authentication port number";
            range "0..65535";
          }
        }
        leaf acct-port {
          tailf:info "UDP port for RADIUS accounting server (default is 1646)";
          tailf:cli-hide-in-submode;
          type uint16 {
            tailf:info "<0-65535>;;Accounting port number";
            range "0..65535";
          }
        }
        container key {
          tailf:info "per-server encryption key (overrides default)";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          uses key-grouping;
        }
        leaf timeout {
          tailf:info "Time to wait for this RADIUS server to reply (overrides global timeout)";
          type uint16 {
            tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
            range "1..1000";
          }
        }
        leaf retransmit {
          tailf:info "Number of times a RADIUS request is re-sent to a server (overrides global retransmit value)";
          type uint8 {
            tailf:info "<1-100>;;Retransmit value";
          }
        }
      }
      container key {
        tailf:info "Set RADIUS encryption key";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses key-grouping;
      }
      leaf timeout {
        tailf:info "Time to wait for a RADIUS server to reply (default 5)";
        type uint16 {
          tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
        }
      }
      leaf retransmit {
        tailf:info "Specify the number of retries to active server";
        type union {
          type uint8 {
            tailf:info "<1-100>;;Number of retries for a transaction (default is 3)";
          }
          type enumeration {
            enum disable {
              tailf:info "Disable Radius server retransmit";
            }
          }
        }
      }
    }
    list usergroup {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure user group";
      tailf:cli-mode-name config-ug;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Usergroup name";
        }
      }
      leaf-list taskgroup {
        tailf:info "Task group associated with this group";
        tailf:cli-list-syntax;
        type string {
          tailf:info "WORD;;Name of the task group";
        }
      }
      leaf description {
        tailf:info "Description for the user group";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description for this group";
        }
      }
    }
    container xnetconf {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "NETCONF configuration commands";
      tailf:alt-name netconf;
      tailf:cli-explicit-exit;
      container agent {
        tailf:info "NETCONF agent configuration commands";
        container tty {
          tailf:info "Enable NETCONF agent over TTY";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-netconf-tty;
          container session {
            tailf:info "Session timeout for transport agents";
            leaf timeout {
              tailf:info "Session timeout for agents";
              type uint16 {
                tailf:info "<1-1440>;;Timeout in minutes";
              }
            }
          }
          container throttle {
            tailf:info "Configuration for throttling NETCONF agent";
            leaf memory {
              tailf:info "Memory usage";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<100-600>;;Size of the memory usage in Mbytes per session (default 300 Mbytes)";
                range "100..600";
              }
            }
            leaf process-rate {
              tailf:info "Process rate";
              type uint16 {
                tailf:info "<1000-30000>;;Number of tags to process per sec";
                range "1000..30000";
              }
            }
          }
        }
        leaf ssh {
          tailf:info "Enable NETCONF agent over SSH connection";
          type empty;
        }
      }
    }
    container network-controller {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Network Controller Functionality";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-net-ctrl;
      tailf:cli-explicit-exit;
      presence true;
      container anycast-gateway {
        tailf:info "Anycast-gateway configuration";
        leaf mac {
          tailf:info "MAC address of gateway";
          type string {
            tailf:info "H.H.H;;VSWitch MAC Address";
          }
        }
      }
      leaf standby {
        tailf:info "Set this network-controller in standby mode";
        tailf:cli-full-command;
        type empty;
      }
      leaf dhcp-server {
        tailf:info "Set the DHCP Server Address for this network-controller domain";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;DHCP Server IP Address";
        }
      }
      list switch {
        tailf:info "Switch to configure";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key "mac ip-address";
        leaf mac {
          tailf:info "MAC address of Switch";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "H.H.H;;VSWitch MAC Address";
          }
        }
        leaf ip-address {
          tailf:info "VSwitch Nexthop Address";
          tailf:cli-expose-key-name;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;Switch IP Address";
          }
        }
      }
    }
    container netconf-yang {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "NETCONF YANG configuration commands";
      tailf:cli-explicit-exit;
      container agent {
        tailf:info "NETCONF YANG agent configuration commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-ncy-agent;
        presence true;
        leaf ssh {
          tailf:info "Enable NETCONF-YANG agent over SSH connection";
          type empty;
        }
      }
    }
    container nsr {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global NSR configuration commands";
      tailf:cli-explicit-exit;
      leaf process-failures {
        tailf:info "Recovery action for Process failures on active RP/DRP";
        type enumeration {
          enum switchover {
            tailf:info "Switch over to standby RP/DRP to maintain NSR";
          }
        }
      }
    }
    container ftp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global FTP configuration commands";
      tailf:cli-explicit-exit;
      container client {
        tailf:info "FTP client configuration commands";
        leaf passive {
          tailf:info "Connect using passive mode";
          type empty;
        }
        container password {
          tailf:info "Specify password for ftp connection";
          leaf password {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;Specify an unencrypted password";
            }
          }
          leaf clear {
            tailf:info "Specify an unencrypted password";
            type string {
              tailf:info "WORD;;Clear password";
            }
          }
          leaf encrypted {
            tailf:info "Specify an encrypted password";
            type string {
              tailf:info "WORD;;Encypted password";
            }
          }
        }
        leaf username {
          tailf:info "Specify username for FTP connections";
          type string {
            tailf:info "WORD;;FTP username";
          }
        }
        list vrf {
          tailf:info "VRF name for FTP service";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of VRF";
            }
          }
          container source-interface {
            tailf:info "Specify interface for source address in FTP connections";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
        }
        container source-interface {
          tailf:info "Specify interface for source address in FTP connections";
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          uses interface-name-grouping;
        }
      }
    }
    container icmp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "ICMP options";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "IPv4 specific";
        container source {
          tailf:info "source address selection policy";
          leaf rfc {
            tailf:info "Enable RFC compliance for source address selection";
            tailf:cli-full-command;
            type empty;
          }
          leaf vrf {
            tailf:info "Enable Strct VRF source address selection";
            tailf:cli-full-command;
            type empty;
          }
        }
        container rate-limit {
          tailf:info "rate limit generation of ICMP messages";
          container unreachable {
            tailf:info "Destination Unreachable (type3)";
            leaf DF {
              tailf:info "Fragmentation needed and DF set (code4)";
              type union {
                type uint32 {
                  tailf:info "<1-4294967295>;;One ICMP unreachable message in x milliseconds(default is 500ms)";
                }
                type enumeration {
                  enum disable {
                    tailf:info "Disable rate limit of ICMP messages";
                  }
                }
              }
            }
            leaf milliseconds {
              tailf:cli-drop-node-name;
              type union {
                type uint32 {
                  tailf:info "<1-4294967295>;;One ICMP unreachable message in x milliseconds(default is 500ms)";
                }
                type enumeration {
                  enum disable {
                    tailf:info "Disable rate limit of ICMP messages";
                  }
                }
              }
            }
          }
        }
      }
    }
    container ntp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Go into NTP submode";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      leaf max-associations {
        tailf:info "Set maximum number of associations";
        type uint32 {
          tailf:info "<0-4294967295>;;Number of associations";
        }
      }
      container server {
        tailf:info "Configure NTP server";
        uses ntp-server-grouping;
        list vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Non-default VRF of peer";
            }
          }
          uses ntp-server-grouping;
        }
      }
      list access-group {
        tailf:info "Control NTP access";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-suppress-list-no;
        key "type name";
        leaf type {
          type enumeration {
            enum peer {
              tailf:info "Provide full access";
            }
            enum query-only {
              tailf:info "Allow only control queries";
            }
            enum serve {
              tailf:info "Provide server and query access";
            }
            enum serve-only {
              tailf:info "Provide only server access";
            }
          }
        }
        leaf name {
          type string {
            tailf:info "WORD;;Access list name - maximum 32 characters";
          }
        }
        leaf vrf {
          tailf:info "Specify non-default VRF";
          tailf:cli-prefix-key;
          type string {
            tailf:info "WORD;;Non-default VRF of peer";
          }
        }
        leaf version {
          tailf:cli-drop-node-name;
          tailf:cli-prefix-key;
          type enumeration {
            enum ipv4 {
              tailf:info "Configure IPv4 access";
            }
            enum ipv6 {
              tailf:info "Configure IPv6 access";
            }
          }
        }
      }
      list interface {
        tailf:info "Configure NTP on an interface";
        tailf:cli-mode-name config-ntp-int;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        container broadcast {
          tailf:info "Configure NTP broadcast service";
          tailf:cli-delete-when-empty;
          presence true;
          leaf version {
            tailf:info "Configure NTP version";
            type int8 {
              tailf:info "<1-4>;;NTP version number";
              range "1..4";
            }
          }
        }
      }
      leaf master {
        tailf:info "Choose a refclock as master clock for NTP";
        tailf:cli-full-command;
        type uint16;
      }
      container source {
        tailf:info "Configure default interface";
        tailf:cli-flatten-container;
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
      }
      leaf update-calendar {
        tailf:info "Periodically update calendar with NTP time";
        tailf:cli-full-command;
        type empty;
      }
      list authentication-key {
        tailf:info "Authentication key for trusted time sources";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65535>;;Key number";
            range "1..65535";
          }
        }
        container md5 {
          tailf:info "MD5 authentication";
          choice md5-choice {
            leaf key {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "WORD;;Authentication key - maximum 32 characters";
              }
            }
            leaf clear {
              tailf:info "Specify an unencrypted key";
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) password (key)";
              }
            }
            leaf encrypted {
              tailf:info "Specify an encrypted key";
              type string {
                tailf:info "LINE;;The ENCRYPTED password (key)";
              }
            }
          }
        }
      }
      leaf authenticate {
        tailf:info "Authenticate time sources";
        type empty;
      }
      leaf-list trusted-key {
        tailf:info "Key numbers for trusted time sources";
        tailf:cli-list-syntax;
        type uint16 {
          tailf:info "<1-65535>;;Key number";
        }
      }
    }
    container rcp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global RCP configuration commands";
      container client {
        tailf:info "RCP client configuration commands";
        container source-interface {
          tailf:info "Specify interface for source address in RCP connections";
          uses interface-name-grouping;
        }
      }
    }
    container telnet {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global Telnet configuration commands";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "IPv4 configuration";
        container client {
          tailf:info "Telnet client configuration commands";
          container source-interface {
            tailf:info "Source interface for telnet sessions";
            uses interface-name-grouping;
          }
        }
      }
      container ipv6 {
        tailf:info "IPv6 configuration";
        container client {
          tailf:info "Telnet client configuration commands";
          container source-interface {
            tailf:info "Source interface for telnet sessions";
            uses interface-name-grouping;
          }
        }
      }
      uses telnet-server-grouping;
      list vrf {
        tailf:info "VRF name for telnet server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type vrf-type;
        }
        uses telnet-server-grouping;
      }
    }
    container bfd {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global BFD configuration commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-bfd;
      tailf:cli-explicit-exit;
      list interface {
        tailf:info "Configure BFD on an interface";
        tailf:cli-mode-name config-bfd-if;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        leaf echo {
          tailf:info "Configure BFD echo mode";
          tailf:cli-full-command;
          type empty;
        }
        container echo-conf {
          tailf:cli-drop-node-name;
          container echo {
            tailf:info "Configure BFD echo mode";
            tailf:cli-incomplete-command;
            tailf:cli-incomplete-no;
            leaf disable {
              tailf:info "Disable BFD echo mode for this interface";
              tailf:cli-full-command;
              type empty;
            }
            container ipv4 {
              tailf:info "IPv4 commands";
              leaf source {
                tailf:info "BFD echo source IP addres";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
              }
            }
          }
        }
      }
      container multihop {
        tailf:info "Configure BFD multihop";
        leaf ttl-drop-threshold {
          tailf:info "TTL Drop Threshold";
          type uint8 {
            tailf:info "<0-254>;;Drop Threshold";
            range "0..254";
          }
        }
      }
      container multipath {
        tailf:info "Configure BFD multiple path";
        container include {
          tailf:info "Include a LC node";
          list location {
            tailf:info "Specify a location";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Fully qualified location specification";
              }
            }
          }
        }
      }
      container echo {
        tailf:info "Configure BFD echo parameters";
        leaf disable {
          tailf:info "Disable BFD echo mode";
          tailf:cli-reset-container;
          tailf:cli-full-command;
          type empty;
        }
      }
      container trap {
        tailf:info "Configure BFD trap parameters";
        container singlehop {
          tailf:info "Configure BFD mode";
          leaf pre-mapped {
            tailf:info "Configure BFD trap pre-mapped";
            type empty;
          }
        }
      }
      container dampening {
        tailf:info "Configure BFD dampening intervals";
        container bundle-member {
          tailf:info "Configure BFD dampening for bfd over bundle per member feature";
          leaf l3-only-mode {
            tailf:info "Apply immedite dampening and only when failure is L3 specific";
            type empty;
          }
        }
      }
    }
    container sbfd {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global SBFD configuration commands ";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-sbfd;
      tailf:cli-explicit-exit;
      container remote-target {
        tailf:info "configure remote-target";
        list ipv4 {
          tailf:info "Ipv4 address only";
          tailf:cli-mode-name config-sbfd-rtarget;
          key address;
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
          leaf remote-discriminator {
            tailf:info "Configure remote-discriminator";
            type uint32 {
              tailf:info "<1-4294967295>;;32-bit remote-discriminator";
              range "1..4294967295";
            }
          }
        }
      }
      container local-discriminator {
        tailf:info "configure local-discriminator";
        list address-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key ipv4;
          leaf ipv4 {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;ipv4 address as local-discriminator";
            }
          }
        }
        list id-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;32-bit local-discriminator";
            }
          }
        }
        leaf dynamic {
          tailf:info "configure local-discriminator dynamically";
          tailf:cli-full-command;
          type empty;
        }
        list interface {
          tailf:info "Interface whose IPv4 address is to be used as local discriminator";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type ifname;
          }
        }
      }
    }
    container tftp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global TFTP configuration commands";
      tailf:cli-explicit-exit;
      container client {
        tailf:info "TFTP client configuration commands";
        list vrf {
          tailf:info "VRF name for TFTP service";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of VRF";
            }
          }
          container source-interface {
            tailf:info "Specify interface for source address in TFTP connections";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            uses interface-name-grouping;
          }
        }
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          uses interface-name-grouping;
        }
      }
      uses tftp-server-grouping;
      list vrf {
        tailf:info "VRF name for tftp server";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of VRF";
          }
        }
        uses tftp-server-grouping;
      }
    }
    container nv {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Network Virtualisation configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-nV;
      tailf:cli-explicit-exit;
      container optical {
        tailf:cli-add-mode;
        tailf:cli-mode-name config-nV-optical;
        list satellite {
          tailf:info "Satellite configuration";
          tailf:cli-mode-name config-nV-optical-satellite;
          key id;
          leaf id {
            type uint32 {
              tailf:info "NUM;;Satellite ID";
            }
          }
          container ipv6 {
            leaf address {
              type inet:ipv6-address;
            }
          }
          container username {
            tailf:cli-compact-syntax;
            leaf name {
              tailf:cli-drop-node-name;
              type string;
            }
            leaf password {
              type string;
            }
          }
          container trunk {
            list slot {
              key id;
              leaf id {
                type uint32;
              }
              leaf port {
                tailf:cli-hide-in-submode;
                type uint32;
              }
              leaf local-port {
                tailf:cli-hide-in-submode;
                type string;
              }
            }
          }
        }
      }
      container controller {
        uses controller-dwdm-grouping;
        list HundredGigE {
          tailf:cli-allow-join-with-key;
          key id;
          leaf id {
            type string {
              pattern "[0-9]+/[0-9]+/[0-9]+/[0-9]+";
            }
          }
          leaf admin-state {
            type enumeration {
              enum in-service;
              enum maintenance;
              enum out-of-service;
              enum in-service-config-allowed;
            }
          }
        }
      }
      list satellite {
        tailf:info "ICPE satellite configuration";
        tailf:cli-mode-name config-satellite;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<100-65534>;;Satellite ID";
            range "100..65534";
          }
        }
        leaf type {
          tailf:info "Satellite type";
          type string {
            tailf:info "WORD;;Satellite type";
          }
        }
        container ipv4 {
          tailf:info "IPv4 address";
          leaf address {
            tailf:info "IPv4 address";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
        }
        container redundancy {
          tailf:info "Redundancy configuration";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-nV-red;
          leaf host-priority {
            tailf:info "Priority of this host for the given satellite";
            type uint8 {
              tailf:info "<0-255>;;Priority. A lower number denotes a higher priority. (Default: 128)";
            }
          }
        }
        leaf serial-number {
          tailf:info "Serial number of the connected satellite";
          type string {
            tailf:info "WORD;;Satellite serial number";
          }
        }
        leaf description {
          tailf:info "Satellite description.";
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-full-command;
          type string {
            tailf:info "WORD;;description";
          }
        }
        container secret {
          tailf:info Secure;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum 0 {
                tailf:info "Specifies an UNENCRYPTED password will follow";
              }
              enum 5 {
                tailf:info "Specifies an ENCRYPTED secret will follow";
              }
            }
          }
          leaf secret {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "LINE;;The ENCRYPTED secret string";
            }
          }
        }
      }
    }
    container enable {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Modify enable password parameters";
      tailf:cli-explicit-exit;
      container password {
        tailf:info "Assign the privileged level password (MAX of 25 characters)";
      }
      container secret {
        tailf:info "Assign the privileged level secret (MAX of 25 characters)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf type {
          tailf:cli-drop-node-name;
          type enumeration {
            enum 0 {
              tailf:info "Specifies an UNENCRYPTED password will follow";
            }
            enum 5 {
              tailf:info "Specifies an ENCRYPTED secret will follow";
            }
          }
        }
        leaf secret {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "LINE;;The ENCRYPTED 'enable' secret string";
          }
        }
      }
    }
    uses username-grouping {
      refine username {
        tailf:ncs-device-type cli-ned;
        tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      }
    }
    container tacacs-server {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "TACACS+ server definition";
      tailf:cli-explicit-exit;
      list host {
        tailf:info "Specify a TACACS+ server";
        tailf:cli-compact-syntax;
        tailf:cli-mode-name config-tacacs-host;
        tailf:cli-show-long-obu-diffs;
        ordered-by user;
        key "name port";
        leaf name {
          type inet:host {
            tailf:info "Hostname or A.B.C.D  IP address of TACACS+ server";
          }
        }
        leaf port {
          tailf:info "TCP port for TACACS+ server (default is 49)";
          tailf:cli-expose-key-name;
          type uint16 {
            tailf:info "<1-65535>;;Port number";
            range "1..65535";
          }
        }
        container key {
          tailf:info "per-server encryption key (overrides default)";
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-compact-syntax;
          leaf encryption {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            tailf:cli-optional-in-sequence;
            type enumeration {
              enum 0 {
                tailf:info "Specifies that an UNENCRYPTED key will follow";
              }
              enum 7 {
                tailf:info "Specifies that an encrypted key will follow";
              }
            }
          }
          leaf key {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            tailf:cli-multi-value;
            type string {
              tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
            }
          }
        }
        leaf timeout {
          tailf:info "Time to wait for this TACACS server to reply (overrides default)";
          type uint16 {
            tailf:info "<1-1000>;;Timeout value in seconds to wait for server to reply";
            range "1..1000";
          }
        }
      }
      container key {
        tailf:info "Set TACACS+ encryption key";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        leaf encryption {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-optional-in-sequence;
          type enumeration {
            enum 0 {
              tailf:info "Specifies that an UNENCRYPTED key will follow";
            }
            enum 7 {
              tailf:info "Specifies that an encrypted key will follow";
            }
          }
        }
        leaf key {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "LINE;;The UNENCRYPTED (cleartext) key";
          }
        }
      }
      leaf timeout {
        tailf:info "Time to wait for a TACACS server to reply";
        type uint16 {
          tailf:info "<1-1000>;;Wait time (default 5 seconds)";
          range "1..1000";
        }
      }
    }
    container tacacs {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "TACACS+ configuration commands";
      tailf:cli-explicit-exit;
      container source-interface {
        tailf:info "Specify interface for source address in TACACS+ packets";
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-compact-syntax;
        uses interface-name-grouping;
        leaf vrf {
          tailf:info "VRF for this source interface configuration";
          type string {
            tailf:info "WORD;;Name of the VRF";
          }
        }
      }
    }
    container aaa {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Authentication, Authorization and Accounting.";
      tailf:cli-explicit-exit;
      leaf new-model {
        tailf:info "Enable NEW access control commands and functions. (Disables OLD commands.)";
        tailf:cli-full-command;
        type empty;
      }
      container group {
        tailf:info "AAA group definitions";
        container server {
          tailf:info "AAA Server group definitions";
          list radius {
            tailf:info "Radius server-group definition";
            tailf:cli-mode-name config-sg-radius;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Server-group name";
              }
            }
            container server {
              tailf:info "Specify a RADIUS server";
              list name {
                tailf:info "WORD;;Name of radius server";
                key name;
                leaf name {
                  type string;
                  tailf:non-strict-leafref {
                    path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:aaa/group/server/radius/name" {
                      tailf:xpath-root 3;
                    }
                  }
                }
              }
              list direct {
                tailf:cli-drop-node-name;
                tailf:cli-compact-syntax;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  tailf:cli-disallow-value name;
                  type inet:host {
                    tailf:info "Hostname or A.B.C.D;;IP address of RADIUS server";
                  }
                }
                leaf auth-port {
                  tailf:info "UDP port for RADIUS authentication server (default is 1645)";
                  type uint16 {
                    tailf:info "<0-65535>;;Port number";
                    range "0..65535";
                  }
                }
                leaf acct-port {
                  tailf:info "UDP port for RADIUS accounting server (default is 1646)";
                  type uint16 {
                    tailf:info "<0-65535>;;Port number";
                    range "0..65535";
                  }
                }
              }
            }
            container ip {
              tailf:info "Internet Protocol config commands";
              container vrf {
                tailf:info "Set VPN Routing Forwarding to use with the servers";
                leaf forwarding {
                  tailf:info "Configure forwarding table";
                  type string {
                    tailf:info "WORD;;Table name";
                  }
                }
              }
            }
          }
          list tacacs {
            tailf:alt-name tacacs+;
            tailf:info "tacacs+  TACACS+ server-group definition";
            tailf:cli-mode-name config-sg-tacacs;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Server group name";
              }
            }
            leaf-list server {
              tailf:info "Specify a TACACS+ server";
              tailf:cli-list-syntax;
              type inet:host {
                tailf:info "Hostname or A.B.C.D IP address or Hostname of TACACS+ server";
              }
            }
            leaf vrf {
              tailf:info "VRF to which this server group belongs to";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Name of the VRF";
              }
            }
          }
        }
      }
      container authentication {
        tailf:info "Authentication configurations parameters.";
        list login {
          tailf:info "Set authentication lists for logins.";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named authentication list (max 31 characters,longer will be rejected).";
              length "1..31";
            }
          }
          leaf local {
            tailf:info "Use local username authentication.";
            type empty;
          }
          leaf group {
            tailf:info "Use Server-group";
            type union {
              type string {
                tailf:info "WORD;;Server-group name";
              }
              type enumeration {
                enum ldap {
                  tailf:info "Use list of all LDAP hosts.";
                }
                enum radius {
                  tailf:info "Use list of all Radius hosts.";
                }
                enum tacacs {
                  tailf:info "+  Use list of all Tacacs+ hosts.";
                }
              }
            }
          }
          leaf none {
            tailf:cli-full-command;
            tailf:info "NO authentication.";
            type empty;
          }
        }
      }
      container authorization {
        tailf:info "Authorization configurations parameters.";
        list commands {
          tailf:info "For EXEC (shell) commands";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type aaa-group-type;
          }
          container group2 {
            when "../group" {
              tailf:xpath-root 3;
            }
            tailf:cli-drop-node-name;
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            leaf group {
              tailf:info "Use Server-group 2";
              type aaa-group-type;
            }
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
        list exec {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type aaa-group-type;
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
        list eventmanager {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;List name for AAA authorization";
            }
          }
          leaf group {
            tailf:info "Use server-group.";
            type aaa-group-type;
          }
          leaf local {
            tailf:info "Use local database.";
            type empty;
          }
          leaf none {
            tailf:info "No authorization (always succeeds).";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container accounting {
        tailf:info "Accounting configurations parameters.";
        list exec {
          tailf:info "For starting an exec (shell).";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-drop-node-name;
            type enumeration {
              enum start-stop {
                tailf:info "start and stop records";
              }
              enum stop-only {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum radius {
                  tailf:info "Use list of all Radius hosts";
                }
                enum tacacs+ {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list system {
          tailf:info "For System events";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf start-stop {
            tailf:info "start and stop records";
            type empty;
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum radius {
                  tailf:info "Use list of all Radius hosts";
                }
                enum tacacs+ {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list network {
          tailf:info "For network services (such as IKE, PPP)";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-drop-node-name;
            type enumeration {
              enum start-stop {
                tailf:info "start and stop records";
              }
              enum stop-only {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum radius {
                  tailf:info "Use list of all Radius hosts";
                }
                enum tacacs+ {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
        list commands {
          tailf:info "For EXEC (shell) commands";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Named Accounting list";
            }
          }
          leaf notice {
            tailf:cli-drop-node-name;
            type enumeration {
              enum start-stop {
                tailf:info "start and stop records";
              }
              enum stop-only {
                tailf:info "stop records only";
              }
            }
          }
          leaf group {
            tailf:info "Use Server-group";
            tailf:cli-optional-in-sequence;
            type union {
              type string {
                tailf:info "WORD;;server-group name";
              }
              type enumeration {
                enum radius {
                  tailf:info "Use list of all Radius hosts";
                }
                enum tacacs+ {
                  tailf:info "Use list of all TACACS+ hosts";
                }
              }
            }
          }
          leaf none {
            tailf:info "No accounting";
            type empty;
          }
        }
      }
      leaf session-id {
        tailf:info "AAA Session ID";
        tailf:cli-full-command;
        type enumeration {
          enum common {
            tailf:info "Common Session ID";
          }
          enum unique {
            tailf:info "Unique Session ID for different accounting types";
          }
        }
      }
      leaf default-taskgroup {
        tailf:info "Default taskgroup to be used for remote authentication";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of the taskgroup to be used";
        }
      }
    }
    container cdp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable CDP, or configure global CDP subcommands";
      tailf:cli-display-separated;
      presence true;
      container advertise {
        tailf:info "Specify the version of CDP advertisements";
        leaf v1 {
          tailf:info "CDP sends version-1 advertisements only";
          type empty;
        }
      }
      leaf timer {
        tailf:info "Specify the rate at which CDP packets are sent (in sec)";
        type uint8 {
          tailf:info "<5-254>;;Rate at which CDP packets are sent (in sec)";
          range "5..254";
        }
      }
      leaf holdtime {
        tailf:info "Specify the holdtime (in sec) to be sent in packets";
        type uint8 {
          tailf:info "<10-255>;;Length of time (in sec) that receiver must keep this packet";
          range "10..255";
        }
      }
    }
    container tcp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global TCP configuration commands";
      tailf:cli-explicit-exit;
      leaf mss {
        tailf:info "Set the TCP initial maximum segment size";
        tailf:cli-full-command;
        type uint16 {
          tailf:info "<68-10000>;;TCP initial maximum segment size";
          range "68..10000";
        }
      }
      leaf selective-ack {
        tailf:info "Enable TCP selective-ACK";
        type empty;
      }
      container path-mtu-discovery {
        tailf:info "Enable Path MTU Discovery on new TCP connections";
        tailf:cli-delete-when-empty;
        tailf:cli-reset-container;
        presence true;
        leaf age-timer {
          type union {
            type uint8 {
              tailf:info "<10-30>;;Aging time (in minutes)";
            }
            type enumeration {
              enum infinite {
                tailf:info "Disable Path MTU aging timer";
              }
            }
          }
        }
      }
      leaf timestamp {
        tailf:info "Enable TCP timestamp option";
        type empty;
      }
      container directory {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf directory {
          tailf:cli-drop-node-name;
          type string {
            tailf:info "WORD;;Place debug files in this directory";
          }
        }
        leaf files {
          tailf:cli-break-sequence-commands;
          tailf:info "Set maximum debug files";
          type uint16 {
            tailf:info "<1-10000>;;Maximum debug files";
          }
        }
        leaf size {
          tailf:info "Set maximum file size";
          type uint32 {
            tailf:info "<1024-4294967295>;;Maximum file size in bytes";
            range "1024..4294967295";
          }
        }
      }
      leaf window-size {
        tailf:info "TCP receive window size";
        type uint32 {
          tailf:info "<2048-65535>;;Window size (bytes)";
        }
      }
    }
    container line {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Line subcommands";
      tailf:cli-explicit-exit;
      container console {
        tailf:info "console template";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-line;
        uses line-grouping;
      }
      container default {
        tailf:info "default template";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-line;
        uses line-grouping;
      }
      list template {
        tailf:info "user defined template";
        tailf:cli-mode-name config-line;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of template to configure";
          }
        }
        uses line-grouping;
      }
    }
    container pool {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Distributed Address Pool Service";
      tailf:cli-explicit-exit;
      list vrf {
        tailf:info "Specify VRF name";
        tailf:cli-mode-name config-pool-ipv4;
        key "vrf ipv4";
        leaf vrf {
          type string {
            tailf:info "WORD;;Enter the VRF name";
          }
        }
        leaf ipv4 {
          tailf:info "Specify IPv4 Pool name";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Enter the IPv4 Pool name";
          }
        }
        list network {
          tailf:info "Specify network for allocation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key prefix;
          leaf prefix {
            type ipv4-prefix {
              tailf:info "A.B.C.D/length;;IP Network";
            }
          }
        }
        list address-range {
          tailf:info "Specify address range for allocation";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key first_range;
          leaf first_range {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Specify first address in range";
            }
          }
          leaf last_range {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Specify last address in range";
            }
          }
        }
        container utilization-mark {
          tailf:info "Specify utilization mark";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf high {
            tailf:info "Specify high mark";
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<0-100>;;Specify numerical value as percentage";
              range "0..100";
            }
          }
          leaf low {
            tailf:info "Specify low mark";
            type uint8 {
              tailf:info "<0-100>;;Specify numerical value as percentage";
              range "0..100";
            }
          }
        }
      }
    }
    container vty-pool {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "VTY Pools";
      tailf:cli-explicit-exit;
      container default {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses vty-pool-grouping;
      }
      container eem {
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        uses vty-pool-grouping;
      }
      list pool-name-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        tailf:cli-incomplete-command;
        key pool-name;
        leaf pool-name {
          tailf:cli-disallow-value (eem|default);
          type string {
            tailf:info "WORD;;VTY range";
          }
        }
        uses vty-pool-grouping;
      }
    }
    container aps {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure SONET Automatic Protection Switching (APS)";
      tailf:cli-explicit-exit;
      list group {
        tailf:info "APS group to configure";
        tailf:cli-mode-name config-aps;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<1-255>;;Group number";
            range "1..255";
          }
        }
        leaf revert {
          tailf:info "Set revertive operation";
          type uint8 {
            tailf:info "<0-255>;;Revert time in minutes (default = 0 - non-revertive APS)";
          }
        }
        container timers {
          tailf:info "Set APS W-P communication timers";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf hello {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint8 {
              tailf:info "<1-255>;;Hello timer in seconds (default 1)";
              range "1..255";
            }
          }
          leaf hold {
            tailf:cli-drop-node-name;
            type uint8 {
              tailf:info "<1-255>;;Hold timer in seconds (default 3)";
              range "1..255";
            }
          }
        }
        list channel {
          tailf:info "Assign a channel to an APS group";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          key "id location";
          leaf id {
            type uint8 {
              tailf:info "<0-1>;;Channel number (0 = Protect, 1 = Working)";
              range "0..1";
            }
          }
          leaf location {
            type enumeration {
              enum local {
                tailf:info "Channel assignment to a local port";
              }
              enum remote {
                tailf:info "Channel assignment to a remote router port";
              }
            }
          }
          leaf preconfigure {
            tailf:info "Specify a preconfig";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf data {
            tailf:cli-drop-node-name;
            type union {
              type string {
                tailf:info "SONET;;SONET/SDH Port controller(s)";
              }
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Remote router IP address";
              }
            }
          }
        }
      }
    }
    container platform {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "platform specific configuration";
      tailf:cli-explicit-exit;
      container ip {
        tailf:info "ip keyword";
        container cef {
          tailf:info "cef keyword";
          leaf load-sharing {
            tailf:info "load balancing";
            type enumeration {
              enum dst-only {
                tailf:info "load balancing algorithm to include destination IP/L4 port";
              }
              enum full {
                tailf:info "default load balancing algorithm to include src/dst IPs/L4 ports";
              }
              enum ip-only {
                tailf:info "load balancing algorithm to include src/dst IP";
              }
            }
          }
        }
      }
      container qos {
        tailf:info "qos keyword";
        leaf qos-10g-only {
          tailf:alt-name 10g-only;
          tailf:info "qos pure 10G mode";
          type empty;
        }
        list protocol {
          tailf:info "protocol keyword";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-reset-container;
          key proto;
          leaf proto {
            type enumeration {
              enum isis;
              enum eigrp;
              enum ldp;
              enum ospf;
              enum rip;
              enum bgp;
              enum hsrp;
              enum bfd;
              enum ospfv3;
              enum bgpv2;
              enum ripng;
              enum neigh-discover;
              enum wlccp;
              enum rsvp;
              enum rsvpv6;
              enum arp;
              enum gre {
                tailf:info "gre (ipv4 and ipv6)";
              }
              enum mpls {
                tailf:info "mpls packet";
              }
            }
          }
          choice proto-choice {
            leaf pass-through {
              tailf:info "pass-through keyword";
              type empty;
            }
            container police {
              tailf:info "police keyword";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-sequence-commands;
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint64 {
                  tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) (postfix k, m, g optional; decimal point allo";
                  range "32000..128000000000";
                }
              }
              leaf burst {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2000000000>;;Normal burst bytes";
                  range "1..2000000000";
                }
              }
            }
            container precedence {
              tailf:info "change ip-precedence(used to map the dscp to cos value)";
              tailf:cli-compact-syntax;
              tailf:cli-reset-container;
              tailf:cli-sequence-commands;
              leaf cos {
                tailf:cli-drop-node-name;
                type uint8 {
                  tailf:info "<0-7>;;new cos value";
                  range "0..7";
                }
              }
              leaf bit-rate {
                tailf:cli-drop-node-name;
                type uint64 {
                  tailf:info "<32000-128000000000>;;Target Bit Rate (bits per second) (postfix k, m, g optional; decimal point allo";
                  range "32000..128000000000";
                }
              }
              leaf burst {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-2000000000>;;Normal burst bytes";
                  range "1..2000000000";
                }
              }
            }
          }
        }
      }
    }
    container control-plane {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Control Plane";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-ctrl;
      tailf:cli-explicit-exit;
      container management-plane {
        tailf:info "Configure management plane protection";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mpp;
        container inband {
          tailf:info "Configure an inband interface/protocol";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-mpp-inband;
          list interface {
            tailf:info "Configure an inband interface";
            tailf:cli-mode-name config-mpp-inband-xxx;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            list allow {
              tailf:info "Allow a protocol on this interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key proto;
              leaf proto {
                type control-plane-proto;
              }
            }
            container allow-peer {
              tailf:cli-drop-node-name;
              list allow {
                tailf:info "Allow a protocol on this interface";
                tailf:cli-mode-name config-xxx-peer;
                key "proto peer";
                leaf proto {
                  type control-plane-proto;
                }
                leaf peer {
                  type enumeration {
                    enum peer {
                      tailf:info "Configure peer address on this interface";
                    }
                  }
                }
                container address {
                  tailf:info "Configure peer address on this interface";
                  list ipv4 {
                    tailf:info "Configure peer IPv4 address on this interface";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key prefix;
                    leaf prefix {
                      type union {
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;Enter IPv4 address";
                        }
                        type ipv4-prefix {
                          tailf:info "A.B.C.D/length;;Enter IPv4 address with prefix";
                        }
                      }
                    }
                  }
                  list ipv6 {
                    tailf:info "Configure peer IPv6 address on this interface";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key prefix;
                    leaf prefix {
                      type union {
                        type tailf:ipv6-address-and-prefix-length {
                          tailf:info "X:X::X/length;;Enter IPv6 address with prefix";
                        }
                        type inet:ipv6-address {
                          tailf:info "X:X::X;;Enter IPv6 address";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        container out-of-band {
          tailf:info "Configure an out-of-band interface/protocol";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-mpp-outband;
          list interface {
            tailf:info "Configure an outband interface";
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            list allow {
              tailf:info "Allow a protocol on this interface";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key proto;
              leaf proto {
                type control-plane-proto;
              }
            }
            container allow-peer {
              tailf:cli-drop-node-name;
              list allow {
                tailf:info "Allow a protocol on this interface";
                key "proto peer";
                leaf proto {
                  type control-plane-proto;
                }
                leaf peer {
                  type enumeration {
                    enum peer {
                      tailf:info "Configure peer address on this interface";
                    }
                  }
                }
                container address {
                  tailf:info "Configure peer address on this interface";
                  list ipv4 {
                    tailf:info "Configure peer IPv4 address on this interface";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key address;
                    leaf address {
                      type union {
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;Enter IPv4 address";
                        }
                        type ipv4-prefix {
                          tailf:info "A.B.C.D/length;;Enter IPv4 address with prefix";
                        }
                      }
                    }
                  }
                  list ipv6 {
                    tailf:info "Configure peer IPv6 address on this interface";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key prefix;
                    leaf prefix {
                      type union {
                        type tailf:ipv6-address-and-prefix-length {
                          tailf:info "X:X::X/length;;Enter IPv6 address with prefix";
                        }
                        type inet:ipv6-address {
                          tailf:info "X:X::X;;Enter IPv6 address";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container ip {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IP configuration subcommands";
      tailf:cli-explicit-exit;
      container domain-lookup {
        tailf:info "Enable IP Domain Name System hostname translation";
        leaf do-lookup {
          tailf:cli-drop-node-name;
          type boolean;
          tailf:cli-boolean-no;
          default true;
        }
        leaf nsap {
          tailf:info "Enable IP DNS queries for CLNS NSAP addresses";
          type empty;
        }
      }
      leaf domain-name {
        tailf:info "Define the default domain name";
        type string {
          tailf:info "WORD;;Default domain name";
        }
      }
      container forward-protocol {
        tailf:info "Controls forwarding of physical and directed IP broadcasts";
        leaf nd {
          tailf:info "Sun's Network Disk protocol";
          type empty;
        }
        leaf sdns {
          tailf:info "Network Security Protocol";
          type empty;
        }
        leaf spanning-tree {
          tailf:info "Use transparent bridging to flood UDP broadcasts";
          type empty;
        }
        leaf turbo-flood {
          tailf:info "Fast flooding of UDP broadcasts";
          type empty;
        }
        leaf udp {
          tailf:info "Packets to a specific UDP port";
          type empty;
        }
      }
      container http {
        tailf:info "HTTP server configuration";
        leaf server {
          tailf:info "Enable http server";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
        leaf secure-server {
          tailf:info "Enable https server";
          tailf:cli-boolean-no;
          type boolean;
          default true;
        }
      }
      container pim {
        tailf:info "PIM global commands";
        container ssm {
          tailf:info "Configure Source Specific Multicast";
          choice ssm-choice {
            leaf default {
              tailf:info "Use 232/8 group range for SSM";
              type empty;
            }
            leaf range {
              tailf:info "ACL for group range to be used for SSM";
              type union {
                type uint8 {
                  tailf:info "<1-99>;;Access list number";
                  range "1..99";
                }
                type string {
                  tailf:info "WORD;;IP named access list";
                }
              }
            }
          }
        }
      }
      container route {
        tailf:info "Establish static routes";
        container vrf {
          tailf:info "Configure static route for a VPN Routing/Forwarding instance";
          tailf:cli-sequence-commands;
          tailf:cli-compact-syntax;
          leaf name {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          leaf dest {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination prefix";
            }
          }
          leaf dest-mask {
            tailf:cli-drop-node-name;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Destination prefix mask";
            }
          }
          choice vrf-choice {
            leaf forwarding-address {
              tailf:cli-drop-node-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Forwarding router's address";
              }
            }
            leaf GigabitEthernet {
              tailf:info "GigabitEthernet IEEE 802.3z";
              tailf:cli-allow-join-with-value {
                tailf:cli-display-joined;
              }
              type string;
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:interface/GigabitEthernet/id" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
        }
      }
      container multicast-routing {
        tailf:info "Enable IP multicast forwarding";
        presence true;
        tailf:cli-display-separated;
        leaf-list vrf {
          tailf:info "Select VPN Routing/Forwarding instance";
          tailf:cli-list-syntax;
          type string {
            tailf:info "WORD;;VPN Routing/Forwarding instance name";
          }
        }
      }
      container multicast {
        tailf:info "Global IP Multicast Commands";
        list vrf {
          tailf:info "Select VPN Routing/Forwarding instance";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;VPN Routing/Forwarding instance name";
            }
          }
          container route-limit {
            tailf:info "Maximum number of multicast routes";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf nr-routes {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;number of routes";
                range "1..2147483647";
              }
            }
            leaf threshold {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<1-2147483647>;;Threshold at which to generate warning message";
                range "1..2147483647";
              }
            }
          }
        }
      }
      container tftp {
        tailf:info "tftp configuration commands";
        container source-interface {
          tailf:info "Specify interface for source address in TFTP connections";
          uses interface-name-grouping;
        }
      }
      container ssh {
        tailf:info "Configure ssh options";
        leaf logging {
          tailf:info "Configure logging for SSH";
          type enumeration {
            enum events {
              tailf:info "Log SSH events";
            }
          }
        }
        leaf version {
          tailf:info "Specify protocol version to be supported";
          type uint8 {
            tailf:info "<1-2>;;Protocol version";
            range "1..2";
          }
        }
      }
    }
    container mirror {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "disk mirror enable command";
      list location {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
      }
    }
    container ipv4 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IPv4 configuration commands";
      tailf:cli-explicit-exit;
      container netmask-format {
        tailf:info "Display mode of ipv4 address mask";
        leaf bit-count {
          tailf:info "Display ipaddess mask in prefix length format";
          type empty;
        }
      }
      container assembler {
        tailf:info "IPv4 Fragmented Packet Assembler";
        leaf max-packets {
          tailf:info "Maxinum packets allowed in assembly queues";
          type uint8 {
            tailf:info "<1-50>;;Percentage of total packets available in the system (default: 1000 packets)";
            range "1..50";
          }
        }
        leaf timeout {
          tailf:info "Number of seconds an assembly queue will hold before timeout";
          type uint8 {
            tailf:info "<1-120>;;Number of seconds an assembly queue will hold before timeout";
            range "1..120";
          }
        }
      }
      container access-list {
        tailf:info "Configure access lists";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        list named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name config-ipv4-acl;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this access list";
            }
          }
          list rule {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483644>;;Sequence number for this entry";
              }
            }
            leaf line {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info
                  "deny;;Specify packets to reject
                   permit;;Specify packets to forward
                   remark;;Comment for access list";
                pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
              }
            }
          }
        }
      }
      container unnumbered {
        tailf:info "Enable IPv4 processing without an explicit address";
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          container traffic-eng {
            tailf:info "IPv4 commands for MPLS Traffic Engineering";
            uses interface-name-grouping;
          }
        }
      }
      container virtual {
        tailf:info "IPv4 virtual address for management interfaces options";
        container address-src {
          tailf:cli-drop-node-name;
          container address {
            leaf use-as-src-addr {
              tailf:info "Use as default src address on sourced packets?";
              type empty;
            }
          }
        }
        container address {
          tailf:info "IPv4 virtual address for management interfaces";
          list address-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "address mask";
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IPv4 address";
              }
            }
            leaf mask {
              type inet:ipv4-address {
                tailf:info "IP subnet mask";
              }
            }
          }
          list vrf {
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key name;
            leaf name {
              type string {
                tailf:info "Select VRF for which the virtual ip address is configured";
              }
            }
            list address-list {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key "address mask";
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address";
                }
              }
              leaf mask {
                type inet:ipv4-address {
                  tailf:info "IP subnet mask";
                }
              }
            }
          }
        }
      }
      uses ipv4-ipv6-common-grouping;
      leaf source-route {
        tailf:info "Process packets with source routing header options";
        tailf:cli-full-command;
        type empty;
      }
    }
    container ipv6 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global IPv6 configuration commands";
      tailf:cli-explicit-exit;
      leaf unicast-routing {
        tailf:info "Enable unicast routing";
        type empty;
      }
      container access-list {
        tailf:info "Configure access lists";
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        list named-acl {
          tailf:cli-drop-node-name;
          tailf:cli-full-command;
          tailf:cli-no-key-completion;
          tailf:cli-mode-name config-ipv6-acl;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;User selected string identifying this access list";
            }
          }
          list rule {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-2147483644>;;Sequence number for this entry";
              }
            }
            leaf line {
              tailf:cli-drop-node-name;
              tailf:cli-multi-value;
              type string {
                tailf:info
                  "deny;;Specify packets to reject
                   permit;;Specify packets to forward
                   remark;;Comment for access list";
                pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
              }
            }
          }
        }
      }
      container multicast {
        tailf:info "Configure multicast related commands";
        container rpf {
          tailf:info "Configure multicast RPF related commands";
          container backoff {
            tailf:info "Backoff delay after unicast routing change";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf initial {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<200-65535>;;Initial RPF backoff delay in milliseconds";
                range "200..65535";
              }
            }
            leaf max-backoff-delay {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<200-65535>;;Maximum RPF backoff delay in milliseconds";
                range "200..65535";
              }
            }
          }
          leaf use-bgp {
            tailf:info "Use BGP routes for multicast RPF lookup";
            type empty;
          }
        }
      }
      uses ipv4-ipv6-common-grouping;
      container mobile {
        tailf:info "MobileIP configuration";
        list pmipv6-domain {
          tailf:info "PMIPv6 domain configuration";
          tailf:cli-mode-name config-pmipv6-domain;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Domain Name";
            }
          }
          list nai {
            tailf:info "Network access identifier or Realm";
            tailf:cli-mode-name config-pmipv6-domain-nai;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;MN Identifier";
              }
            }
            leaf network {
              tailf:info "Network name (Address pool) for this MN";
              type string {
                tailf:info "WORD;;Network name";
              }
            }
            leaf service {
              tailf:info "Service type for this MN";
              type enumeration {
                enum dual {
                  tailf:info "dual service type";
                }
                enum ipv4 {
                  tailf:info "ipv4 service type";
                }
                enum ipv6 {
                  tailf:info "ipv6 service type";
                }
              }
            }
            leaf customer {
              tailf:info "Customer name for this MN";
              type string {
                tailf:info "WORD;;Customer name";
              }
            }
          }
        }
        list pmipv6-lma {
          tailf:info "PMIPv6 LMA configuration";
          tailf:cli-mode-name config-pmipv6-lma;
          key "name domain";
          leaf name {
            type string {
              tailf:info "WORD;;LMA name";
            }
          }
          leaf domain {
            tailf:cli-expose-key-name;
            tailf:info "PMIPv6 domain for this LMA";
            type string {
              tailf:info "WORD;;Domain name";
            }
          }
          container aaa {
            tailf:info "aaa config attributes for this LMA";
            container accounting {
              tailf:info "AAA accounting for this LMA";
              tailf:cli-delete-when-empty;
              presence true;
              leaf interim {
                tailf:info "Send interim accounting update messages";
                type uint32 {
                  tailf:info "<1-86400>;;Interim acounting interval(in minutes)";
                  range "1..86400";
                }
              }
            }
          }
          container dynamic {
            tailf:info "enable dynamic mag learning for LMA";
            container mag {
              tailf:info "learn mag dynamically for this LMA";
              leaf learning {
                tailf:info "learn mag dynamically for this LMA";
                type empty;
              }
            }
          }
          container enforce {
            tailf:info "enforce heartbeat values to MAG";
            leaf heartbeat-to-mag {
              tailf:info "send heartbeat values to MAG";
              type empty;
            }
          }
          container mobility-service {
            tailf:info "Service of this LMA";
            container mobile-local-loop {
              tailf:info "Wireless Private Routing service";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ipv6-lma-mll;
              presence true;
              list customer {
                tailf:info "customer configuration on this mobile local loop service";
                tailf:cli-mode-name config-ipv6-pmipv6-mll-cust;
                key "name vrf";
                leaf name {
                  type string {
                    tailf:info "WORD;;Customer name";
                  }
                }
                leaf vrf {
                  tailf:cli-expose-key-name;
                  tailf:info "Vrf for this customer";
                  type vrf-type;
                }
                container gre-key {
                  tailf:info "Customer specific GRE key";
                  leaf symmetric {
                    tailf:info "Customer specific symmetric GRE key";
                    type uint32 {
                      tailf:info "<1-4294967295>;;GRE key value";
                    }
                  }
                }
                container network {
                  tailf:info "network parameters for the customer";
                  choice network-choice {
                    leaf authorized {
                      tailf:info "not authorize the network prefixes";
                      type string {
                        tailf:info "WORD;;ASCII string";
                      }
                    }
                    leaf unauthorized {
                      tailf:info "not authorize the network prefixes";
                      type empty;
                    }
                  }
                }
                container auth-option {
                  tailf:info "Authentication option between PMIPV6 entities";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf spi {
                    tailf:info "Security parameter index";
                    tailf:cli-incomplete-command;
                    type string {
                      tailf:info "<0-ffffffff>;;SPI in hex value";
                    }
                  }
                  container key {
                    tailf:info "Security Key";
                    tailf:cli-flatten-container;
                    tailf:cli-compact-syntax;
                    leaf ascii {
                      tailf:info "Key in ASCII string";
                      type string {
                        tailf:info "WORD;;ASCII string";
                      }
                    }
                  }
                }
                container transport {
                  tailf:info "Customer transport attributes";
                  list vrf {
                    tailf:info "vrf for this transport";
                    tailf:cli-mode-name config-ipv6-pmipv6-mll-cust-tpt;
                    key name;
                    leaf name {
                      type string {
                        tailf:info "WORD;;Name of VRF";
                      }
                    }
                    container address {
                      tailf:info "Specify LMAs IPv4 and IPv6 address";
                      leaf ipv4 {
                        tailf:info "Configure IPv4 address for this LMA";
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;Transport IPv4 address";
                        }
                      }
                      leaf ipv6 {
                        tailf:info "Configure IPv6 address for this LMA";
                        type inet:ipv6-address {
                          tailf:info "X:X::X;;Transport IPv6 address";
                        }
                      }
                    }
                  }
                }
                container heartbeat {
                  tailf:info "heartbeat config for this Customer";
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  leaf interval {
                    tailf:info "interval value";
                    tailf:cli-incomplete-command;
                    type uint16 {
                      tailf:info "<10-3600>;;Specify the interval value in second";
                      range "10..3600";
                    }
                  }
                  leaf retries {
                    tailf:info "retry value";
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<1-10>;;Specify the retry value";
                      range "1..10";
                    }
                  }
                  leaf timeout {
                    tailf:info "timeout value";
                    type uint16 {
                      tailf:info "<1-3600>;;Specify the timeout value";
                      range "1..3600";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container frequency {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Frequency Synchronization configuration";
      tailf:cli-explicit-exit;
      container synchronization {
        tailf:info "Frequency Synchronization configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-freqsync;
        container quality {
          tailf:info "Quality level option selection";
          container itu-t {
            tailf:info "ITU-T QL options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf option {
              tailf:info "ITU-T QL options";
              type enumeration {
                enum 1 {
                  tailf:info "ITU-T QL option 1";
                }
                enum 2 {
                  tailf:info "ITU-T QL option 2";
                }
              }
            }
            leaf generation {
              tailf:info "ITU-T QL option 2 generation";
              when "../option = '2'" {
                tailf:xpath-root 3;
              }
              type enumeration {
                enum 1 {
                  tailf:info "ITU-T QL option 2, generation 1";
                }
                enum 2 {
                  tailf:info "ITU-T QL option 2, generation 2";
                }
              }
            }
          }
        }
        container clock-interface {
          tailf:info "Clock interface configuration";
          leaf timing-mode {
            tailf:info "Clock interface timing mode";
            type enumeration {
              enum independent {
                tailf:info "Use the line interfaces for clock-interface output, which is not looped back to the clock-interface input";
              }
              enum system {
                tailf:info "Use the system's selected timing source for clock-interface output";
              }
            }
          }
        }
        container system {
          tailf:info "System timing configuration";
          leaf timing-mode {
            tailf:info "System timing mod";
            type enumeration {
              enum clock-only {
                tailf:info "Use only clock-interfaces for system timing";
              }
              enum line-only {
                tailf:info "Use only line-interfaces for system timing";
              }
            }
          }
        }
        container log {
          tailf:info "Logging options";
          leaf selection {
            tailf:info "Selection logging options";
            type enumeration {
              enum changes {
                tailf:info "Log selection changes";
              }
              enum errors {
                tailf:info "Log selection errors";
              }
            }
          }
        }
      }
    }
    container cem {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure CEM parameters";
      list class {
        tailf:info "Configure a CEM class";
        tailf:cli-mode-name config-cem-class;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;CEM class name";
          }
        }
        leaf payload {
          tailf:info "Configure payload size of CEM frames";
          type uint16 {
            tailf:info "<32-1312>;;Payload size in bytes";
            range "32..1312";
          }
        }
        leaf dejitter {
          tailf:info "Configure dejitter buffer";
          type uint16 {
            tailf:info "<1-500>;;buffer size in milliseconds";
            range "1..500";
          }
        }
      }
    }
    container error-disable {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure error-disable";
      container recovery {
        tailf:info "Configure auto-recovery";
        container cause {
          tailf:info "Configure auto-recovery for a specific cause";
          container udld-timeout {
            tailf:info "Used when all UDLD neigbors on the link have timed out";
            tailf:cli-delete-when-empty;
            presence true;
            leaf interval {
              tailf:info "Configure an interval for the auto-recovery period";
              type uint32 {
                tailf:info "<30-1000000>;;Specify an interval for the auto-recovery period in seconds";
                range "30..1000000";
              }
            }
          }
        }
      }
    }
    container vtp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure global VTP state";
      tailf:cli-explicit-exit;
      leaf mode {
        tailf:info "Configure VTP device mode";
        type enumeration {
          enum client {
            tailf:info "Set the device to client mode.";
          }
          enum off {
            tailf:info "Set the device to off mode.";
          }
          enum server {
            tailf:info "Set the device to server mode.";
          }
          enum transparent {
            tailf:info "Set the device to transparent mode.";
          }
        }
      }
    }
    container arp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global ARP configuration for Static and Alias ARP entries";
      tailf:cli-explicit-exit;
      uses arp-grouping;
      list vrf {
        tailf:info "vrf;;Specify a non-default VRF";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-reset-container;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses arp-grouping;
      }
    }
    container cinetd {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global Cisco inetd configuration commands";
      tailf:cli-explicit-exit;
      leaf rate-limit {
        tailf:info "Cisco inetd rate-limit of service requests";
        type uint8 {
          tailf:info "<1-100>;;Number of service requests accepted per second (default 1)";
          range "1..100";
        }
      }
    }
    container xxml {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configuration for XML related services";
      tailf:alt-name xml;
      tailf:cli-explicit-exit;
      container tty-agent {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-no;
        container agent {
          tailf:info "Enable default agent for XML requests";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container tty {
            tailf:info "Enable tty agent for XML requests";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-xml-tty;
            presence true;
            container iteration {
              tailf:info "Iterator of the xml response";
              leaf off {
                tailf:info "Turn off the xml response iterator";
                type empty;
              }
            }
            leaf ipv4 {
              tailf:info "IPv4 Transport";
              type enumeration {
                enum enable;
                enum disable;
              }
            }
            leaf ipv6 {
              tailf:info "IPv6 Transport";
              type enumeration {
                enum enable;
                enum disable;
              }
            }
          }
        }
      }
      container ssl-agent {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-no;
        container agent {
          tailf:info "Enable default agent for XML requests";
          tailf:cli-incomplete-command;
          tailf:cli-incomplete-no;
          container ssl {
            tailf:info "Enable ssl agent for XML requests";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-xml-ssl;
            presence true;
            container session {
              tailf:info "session timeout for transport agents";
              leaf timeout {
                tailf:info "session timeout for agents";
                type uint16 {
                  tailf:info "<1-1440>;;Timeout in minutes";
                  range "1..1440";
                }
              }
            }
          }
        }
      }
      container other-agent {
        tailf:cli-drop-node-name;
        tailf:cli-incomplete-no;
        container agent {
          tailf:cli-add-mode;
          tailf:cli-mode-name config-xml-agent;
          presence true;
          leaf ipv4 {
            tailf:info "IPv4 Transport";
            type enumeration {
              enum enable;
              enum disable {
                tailf:info "Disable IPv4 Transport";
              }
            }
          }
          leaf ipv6 {
            tailf:info "IPv6 Transport";
            type enumeration {
              enum enable;
              enum disable;
            }
          }
          container iteration {
            tailf:info "Iterator of the xml response";
            choice iteration-choice {
              container on {
                tailf:info "Turn on the xml response iterator";
                leaf size {
                  tailf:info "Iterator size of the xml response";
                  type uint32 {
                    tailf:info "<1-100000>;;Size of the Iteration in Kbytes (default 48 Kbytes)";
                    range "1..100000";
                  }
                }
              }
              leaf off {
                tailf:info "Turn off the xml response iterator";
                type empty;
              }
            }
          }
        }
      }
    }
    container switch {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure switch command";
      tailf:cli-explicit-exit;
      container virtual {
        tailf:info "Virtual switch configuration mode";
        list domain {
          tailf:info "Virtual switch domain";
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Virtual switch domain number";
              range "1..255";
            }
          }
          leaf mac-address {
            tailf:info "router mac address scheme";
            type union {
              type string {
                tailf:info "H.H.H;;Manually set router mac address";
              }
              type enumeration {
                enum use-virtual {
                  tailf:info "Use mac-address range reserved for Virtual Switch System ";
                }
              }
            }
          }
          container switch {
            tailf:info "Configure switch command";
            leaf mode {
              type enumeration {
                enum virtual;
              }
            }
            list nr {
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-2>;;Virtual switch number";
                  range "1..2";
                }
              }
              leaf location {
                tailf:info "Virtual switch location";
                type string {
                  tailf:info "WORD;;Virtual switch location string. If you include spaces, you must enclose your entry in quotes (\"\").";
                }
              }
              leaf priority {
                tailf:info "Virtual switch priority";
                type uint8 {
                  tailf:info "<1-255>;;Virtual switch priority value";
                  range "1..255";
                }
              }
            }
          }
        }
      }
    }
    container key {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Key management";
      tailf:cli-explicit-exit;
      list chain {
        tailf:info "Key-chain management";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Key-chain name";
          }
        }
        list key {
          tailf:info "Configure a key";
          tailf:cli-full-command;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<0-2147483647>;;Key identifier";
              range "0..2147483647";
            }
          }
          container accept-lifetime {
            tailf:info "Set accept lifetime of key";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf local {
              tailf:info "Specify time in local timezone";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm:ss;;Time to start";
                pattern [0-9][0-9]:[0-9][0-9]:[0-9][0-9];
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-31>;;Day of the month to start";
                range "1..31";
              }
            }
            leaf start-year {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1993-2035>;;Year to start";
                range "1993..2035";
              }
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  tailf:info "Set key lifetime duration";
                  type uint32 {
                    tailf:info "<1-2147483646>;;Seconds";
                    range "1..2147483646";
                  }
                }
              }
              case stop-time {
                leaf stop-time {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "hh:mm:ss;;Time to stop";
                    pattern [0-9][0-9]:[0-9][0-9]:[0-9][0-9];
                  }
                }
                leaf stop-month {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum Jan;
                    enum Feb;
                    enum Mar;
                    enum Apr;
                    enum May;
                    enum Jun;
                    enum Jul;
                    enum Aug;
                    enum Sep;
                    enum Oct;
                    enum Nov;
                    enum Dec;
                  }
                }
                leaf stop-day {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-31>;;Day of the month to stop";
                    range "1..31";
                  }
                }
                leaf stop-year {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<1993-2035>;;Year to stop";
                    range "1993..2035";
                  }
                }
              }
              case infinite {
                leaf infinite {
                  tailf:info "Never expires";
                  type empty;
                }
              }
            }
          }
          container key-string {
            tailf:info "Configure a key value";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              tailf:cli-incomplete-command;
              type enumeration {
                enum clear {
                  tailf:info "Enter key string in cleartext form";
                }
                enum password {
                  tailf:info "Encrypted key string ";
                }
              }
            }
            leaf password {
              tailf:info "Encrypted key string ";
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:cli-disallow-value clear|password;
              tailf:meta-data secret-password;
              type string {
                tailf:info "LINE;;Cleartext key";
              }
            }
          }
          container send-lifetime {
            tailf:info "Set send lifetime of key";
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            tailf:cli-compact-syntax;
            leaf local {
              tailf:info "Specify time in local timezone";
              tailf:cli-optional-in-sequence;
              type empty;
            }
            leaf start-time {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "hh:mm:ss;;Time to start";
                pattern [0-9][0-9]:[0-9][0-9]:[0-9][0-9];
              }
            }
            leaf start-month {
              tailf:cli-drop-node-name;
              type month-type;
            }
            leaf start-day {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-31>;;Day of the month to start";
                range "1..31";
              }
            }
            leaf start-year {
              tailf:cli-drop-node-name;
              type uint16 {
                tailf:info "<1993-2035>;;Year to start";
                range "1993..2035";
              }
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  tailf:info "Set key lifetime duration";
                  type uint32 {
                    tailf:info "<1-2147483646>;;Seconds";
                    range "1..2147483646";
                  }
                }
              }
              case stop-time {
                leaf stop-time {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "hh:mm:ss;;Time to stop";
                    pattern [0-9][0-9]:[0-9][0-9]:[0-9][0-9];
                  }
                }
                leaf stop-month {
                  tailf:cli-drop-node-name;
                  type enumeration {
                    enum Jan;
                    enum Feb;
                    enum Mar;
                    enum Apr;
                    enum May;
                    enum Jun;
                    enum Jul;
                    enum Aug;
                    enum Sep;
                    enum Oct;
                    enum Nov;
                    enum Dec;
                  }
                }
                leaf stop-day {
                  tailf:cli-drop-node-name;
                  type uint8 {
                    tailf:info "<1-31>;;Day of the month to stop";
                    range "1..31";
                  }
                }
                leaf stop-year {
                  tailf:cli-drop-node-name;
                  type uint16 {
                    tailf:info "<1993-2035>;;Year to stop";
                    range "1993..2035";
                  }
                }
              }
              case infinite {
                leaf infinite {
                  tailf:info "Never expires";
                  type empty;
                }
              }
            }
          }
          leaf cryptographic-algorithm {
            tailf:info "Choose cryptographic algorithm";
            type enumeration {
              enum HMAC-MD5 {
                tailf:info "Configure HMAC-MD5 as cryptographic algorithm";
              }
              enum HMAC-SHA1-12 {
                tailf:info "Configure HMAC-SHA1-12 as cryptographic algorithm";
              }
              enum HMAC-SHA1-20 {
                tailf:info "Configure HMAC-SHA1-20 as cryptographic algorithm";
              }
              enum MD5 {
                tailf:info "Configure MD5 as cryptographic algorithm";
              }
              enum SHA-1 {
                tailf:info "Configure SHA-1-20 as cryptographic algorithm";
              }
            }
          }
        }
      }
    }
    container dhcp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Dynamic Host Configuration Protocol";
      tailf:cli-explicit-exit;
      container ipv4 {
        tailf:info "Configure IPv4 DHCP";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-dhcpv4;
        list vrf {
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key name;
          leaf name {
            tailf:info "VRF name";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          leaf relay {
            tailf:info "Assign a relay profile to VRF";
            type empty;
          }
          leaf profile {
            tailf:info "Enter profile name";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
        }
        list profile {
          tailf:info "Create or enter a profile";
          tailf:cli-mode-name config-dhcpv4-profile;
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          leaf type {
            type enumeration {
              enum relay {
                tailf:info "Create or enter relay profile";
              }
              enum proxy {
                tailf:info "Create or enter proxy profile";
              }
              enum server {
                tailf:info "Create or enter server profile";
              }
              enum snoop {
                tailf:info "Create or enter snoop profile";
              }
            }
          }
          leaf pool {
            tailf:info "Specify the Pool name";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Dap's pool name";
            }
          }
          leaf-list default-router {
            tailf:info "default routers";
            tailf:cli-flat-list-syntax;
            tailf:cli-replace-all;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Router's IP address";
            }
          }
          container giaddr {
            tailf:info "Specify gateway address policy";
            leaf policy {
              tailf:info "Specify gateway address policy";
              type enumeration {
                enum drop {
                  tailf:info "Drop client requests with non-zero gateway address";
                }
                enum replace {
                  tailf:info "Replace existing gateway address in client request";
                }
              }
            }
          }
          list helper-address {
            tailf:info "Specify the server address to relay packets";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            key "vrf address";
            leaf vrf {
              tailf:cli-expose-key-name;
              tailf:info "Specify server VRF";
              type vrf-type;
            }
            leaf address {
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Server address";
              }
            }
          }
          container relay {
            tailf:info "Specify Relay Agent Information Option configuration";
            container information {
              tailf:info "Specify Relay Agent Information Option configuration";
              leaf check {
                tailf:info "Check Relay Agent Information Option in server reply";
                type empty;
              }
              container option {
                tailf:info "Insert Relay Agent Information circuit ID and remote ID suboptions in client request";
                tailf:cli-delete-when-empty;
                presence true;
                leaf vpn {
                  tailf:info "Insert Relay Agent Information VPN suboptions in client request";
                  type empty;
                }
                leaf vpn-mode {
                  tailf:info "Relay Agent Information VPN suboptions mode";
                  type enumeration {
                    enum cisco {
                      tailf:info "Relay Agent Information VPN suboptions in CISCO proprietary";
                    }
                    enum rfc {
                      tailf:info "Relay Agent Information VPN suboptions in RFC compliance";
                    }
                  }
                }
                leaf allow-untrusted {
                  tailf:info "Forward untrusted packets";
                  type empty;
                }
              }
              leaf policy {
                tailf:info "Specify Relay Agent Information Option policy";
                type enumeration {
                  enum drop {
                    tailf:info "Drop client request packets with Relay Agent Information Option";
                  }
                  enum encapsulate {
                    tailf:info "Encapsulate existing Relay Agent Information Option in client request";
                  }
                  enum keep {
                    tailf:info "Keep existing Relay Agent Information Option in client request";
                  }
                }
              }
            }
          }
        }
        list interface {
          tailf:info "Assign a profile to interface";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf type {
            type enumeration {
              enum proxy {
                tailf:info "Assign a proxy profile to interface";
              }
              enum relay {
                tailf:info "Assign a relay profile to interface";
              }
              enum server {
                tailf:info "Assign a server profile to interface";
              }
            }
          }
          leaf profile {
            tailf:info "Enter profile name";
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
        }
      }
      container ipv6 {
        tailf:info "Configure IPv6 DHCP";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-dhcpv6;
        list interface {
          tailf:info "Enable IPv6 DHCP on an interface";
          tailf:cli-mode-name config-dhcpv6-if;
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf type {
            type enumeration {
              enum proxy;
              enum relay {
                tailf:info "Act as an IPv6 DHCP stateless relay agent";
              }
              enum server {
                tailf:info "Act as an IPv6 DHCP server";
              }
            }
          }
          leaf profile {
            tailf:info "Create or enter a profile";
            type string {
              tailf:info "WORD;;Enter profile Name";
            }
          }
          leaf destination {
            when "../type = 'relay'" {
              tailf:xpath-root 3;
              tailf:dependency "../type";
            }
            tailf:info "Configure relay destination";
            type inet:ipv6-address {
              tailf:info "X:X::X%zone;;IPv6 address";
            }
          }
        }
        list profile {
          tailf:info "Create or enter a profile";
          tailf:cli-mode-name config-dhcpv6-profile;
          key "name type";
          leaf name {
            type string {
              tailf:info "WORD;;Profile name";
            }
          }
          leaf type {
            type enumeration {
              enum relay {
                tailf:info "Create or enter relay profile";
              }
              enum proxy {
                tailf:info "Create or enter proxy profile";
              }
              enum server {
                tailf:info "Create or enter server profile";
              }
              enum snoop {
                tailf:info "Create or enter snoop profile";
              }
            }
          }
          list helper-address {
            tailf:info "Configure relay destination";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key "vrf address";
            leaf vrf {
              tailf:cli-expose-key-name;
              tailf:info "Specify server VRF";
              type vrf-type;
            }
            leaf address {
              type inet:ipv6-address {
                tailf:info "X:X::X;;Server Global unicast address";
              }
            }
          }
        }
      }
    }
    container snmp-server {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "SNMP configuration subcommands";
      tailf:cli-explicit-exit;
      container ifmib {
        tailf:info "IF-MIB configuration commands";
        container ifalias {
          tailf:info "Modify parameters for ifAlias object";
          leaf long {
            tailf:info "Enable support for ifAlias values longer than 64 characters";
            type empty;
          }
        }
        container stats {
          tailf:info "Modify IF-MIB statistics parameters";
          leaf cache {
            tailf:info "Get cached interface statistics";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      leaf packetsize {
        tailf:info "Message packet size";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<484-65500>;;Packet size (default 1500)";
          range "484..65500";
        }
      }
      leaf ifindex {
        tailf:info "Enable ifindex persistence";
        tailf:cli-full-command;
        type enumeration {
          enum persist {
            tailf:info "Persist interface indices";
          }
        }
      }
      container engineID {
        tailf:info "Configure a local or remote SNMPv3 engineID";
        leaf local {
          tailf:info "engineID of the local agent";
          type string {
            tailf:info "WORD;;engine ID octet string";
          }
        }
        list remote {
          tailf:info "engineID of the remote agent";
          tailf:cli-compact-syntax;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key ip-address;
          leaf ip-address {
            type string {
              tailf:info "A.B.C.D or X:X::X;;IP address of remote SNMP notification host";
            }
          }
          leaf engine-id {
            tailf:cli-drop-node-name;
            type string {
              tailf:info "WORD;;engine ID octet string";
            }
          }
          leaf udp-port {
            tailf:info "The remote notification host's UDP port number";
            type uint16 {
              tailf:info "<1-65535>;;UDP port number";
              range "1..65535";
            }
          }
        }
      }
      uses snmp-server-host-grouping;
      container entityindex {
        tailf:info "Configuration pertaining to entity indices";
        leaf persist {
          tailf:info "Persist indices";
          type empty;
        }
      }
      list vrf {
        tailf:info "SNMP VRF configuration commands";
        tailf:cli-mode-name config-snmp-vrf;
        key name;
        leaf name {
          tailf:info "VRF name";
          type string {
            tailf:info "WORD;;VRF name";
          }
        }
        uses snmp-server-host-grouping;
        list context {
          tailf:info "SNMP Context Name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Context Name";
            }
          }
        }
      }
      container ipv4 {
        tailf:info "Mark the dscp/precedence bit for ipv4 packets";
        choice ipv4-choice {
          leaf dscp {
            tailf:info "Set IP DSCP (DiffServ CodePoint)";
            type dscp-type;
          }
          leaf precedence {
            tailf:info "Set precedence";
            type precedence-type;
          }
        }
      }
      container context {
        tailf:info "Configure SNMP context";
        list context-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-disallow-value mapping;
            type string {
              tailf:info "WORD;;Context Name";
            }
          }
        }
      }
      list community {
        tailf:info "Enable SNMP; set community string and access privs";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
          }
        }
        leaf view {
          tailf:info "Restrict this community to a named MIB view";
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;MIB view to which this community has access";
          }
        }
        choice access-choice {
          leaf RO {
            tailf:info "Read-only access with this community string";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf RW {
            tailf:info "Read-write access with this community string";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
        choice owner-choice {
          leaf SDROwner {
            tailf:info "SDR Owner permissions for MIB Objects";
            tailf:cli-optional-in-sequence;
            type empty;
          }
          leaf SystemOwner {
            tailf:info "System Owner permissions for MIB objects";
            tailf:cli-optional-in-sequence;
            type empty;
          }
        }
        leaf access-list-type {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          tailf:cli-incomplete-command;
          type enumeration {
            enum IPv4 {
              tailf:info "Type of Access-list";
            }
            enum IPv6 {
              tailf:info "Type of Access-list";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value IPv4|IPv6|SDROwner|SystemOwner|RO|RW|view;
          type string {
            tailf:info "WORD;;Access-list";
          }
        }
      }
      container community-map {
        tailf:info "Community Mapping as per RFC-2576";
        list community-map-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;The UNENCRYPTED (cleartext) community string";
            }
          }
          leaf context {
            tailf:info "Context Name for the community mapping";
            type string {
              tailf:info "WORD;;SNMP Context Name";
            }
          }
        }
      }
      leaf queue-length {
        tailf:info "Message queue length for each TRAP host";
        tailf:cli-full-command;
        type uint32 {
          tailf:info "<1-5000>;;Queue length (default 100)";
          range "1..5000";
        }
      }
      leaf trap-timeout {
        tailf:info "Set timeout for TRAP message retransmissions";
        type uint16 {
          tailf:info "<1-1000>;;Timeout (default 30 seconds)";
          range "1..1000";
        }
        default 30;
      }
      leaf contact {
        tailf:info "Text for mib Object sysContact";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;identification of the contact person for this managed node";
        }
      }
      leaf location {
        tailf:info "Text for mib Object sysLocation";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;The physical location of this node";
        }
      }
      container trap-source {
        tailf:info "Assign an interface for the source address of all traps";
        uses interface-name-grouping;
        leaf port {
          tailf:info "Change the source port of all traps (default 161).";
          tailf:cli-full-command;
          type uint16 {
            tailf:info "<1024-65535>;;UDP port number";
            range "1024..65535";
          }
        }
      }
      container overload-control {
        tailf:info "Set overload-control params for handling incoming messages in critical processing mode";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands;
        leaf drop-time {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint16 {
            tailf:info "<0-300>;;Overload drop time (in seconds) for incoming queue (default 1 sec)";
            range "0..300";
          }
        }
        leaf throttle-rate {
          tailf:cli-drop-node-name;
          type uint16 {
            tailf:info "<0-1000>;;Overload throttle rate for incoming queue (default 500 msec)";
            range "0..1000";
          }
        }
      }
      container mroutemib {
        tailf:info "Configurations related to IPMROUTE-MIB";
        leaf send-all-vrf {
          tailf:info "enable sending all vrf interface info for cIpMRouteInterfaceTable";
          type empty;
        }
      }
      container mibs {
        tailf:info "MIB for configurations";
        container cbqosmib {
          tailf:info "Configure CBQoSMIB parameters";
          leaf persist {
            tailf:info "Persist CBQoSMIB config, service-policy and object indices";
            type empty;
          }
          container cache {
            tailf:info "Enable CBQoSMIB stats data caching";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-cbqosmibcache;
            container refresh {
              tailf:info "Cache refresh interval";
              leaf time {
                tailf:info "Cache refresh time in seconds ";
                type uint16 {
                  tailf:info "<5-60>;;Refresh time in secs";
                  range "5..60";
                }
              }
            }
            container service-policy {
              tailf:info "Maximum number of service policies to cache the statistics for";
              leaf count {
                tailf:info "Number of service-policy stats";
                type uint16 {
                  tailf:info "<1-5000>;;Number of service-policys";
                  range "1..5000";
                }
              }
            }
          }
        }
      }
      container trap {
        tailf:info "MIB trap configurations";
        leaf link {
          tailf:info "Link up/down trap configuration";
          tailf:cli-full-command;
          type enumeration {
            enum ietf {
              tailf:info "Set the varbind of linkupdown trap to the RFC specified varbinds (default cisco)";
            }
          }
        }
      }
      list user {
        tailf:info "Define a user who can access the SNMP engine";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        tailf:cli-incomplete-command;
        key username;
        leaf username {
          type string {
            tailf:info "WORD;;Name of the user";
          }
        }
        leaf groupname {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type string {
            tailf:info "WORD;;Group to which the user belongs";
          }
        }
        leaf version {
          tailf:cli-drop-node-name;
          type enumeration {
            enum v1 {
              tailf:info "user using the v1 security model";
            }
            enum v2c {
              tailf:info "user using the v2c security model";
            }
            enum v3 {
              tailf:info "user using the v3 security model";
            }
          }
        }
        container auth {
          when "../version = 'v3'" {
            tailf:xpath-root 3;
          }
          tailf:info "authentication parameters for the user";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf level {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type enumeration {
              enum md5 {
                tailf:info "Use HMAC MD5 algorithm for authentication";
              }
              enum sha {
                tailf:info "Use HMAC SHA algorithm for authentication";
              }
            }
          }
          choice password-choice {
            leaf auth-password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) authentication password";
              }
            }
            leaf clear {
              tailf:info "Specifies an UNENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) authentication password";
              }
            }
            leaf encrypted {
              tailf:info "Specifies an ENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The ENCRYPTED authentication password";
              }
            }
          }
        }
        container priv {
          when "../auth" {
            tailf:xpath-root 3;
          }
          tailf:info "encryption parameters for the user";
          tailf:cli-optional-in-sequence;
          tailf:cli-flatten-container;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          choice priv-level {
            leaf threedes {
              tailf:alt-name 3des;
              tailf:info "Use 168 bit 3DES algorithm for encryption";
              tailf:cli-incomplete-command;
              type empty;
            }
            leaf aes {
              tailf:info "AES - Advanced Encryption Standard.";
              tailf:cli-incomplete-command;
              type enumeration {
                enum 128 {
                  tailf:info "Use AES 128 bit encryption";
                }
                enum 192 {
                  tailf:info "Use AES 192 bit encryption";
                }
                enum 256 {
                  tailf:info "Use AES 256 bit encryption";
                }
              }
            }
            leaf des56 {
              tailf:info "Use 56 bit DES algorithm for encryption";
              tailf:cli-incomplete-command;
              type empty;
            }
          }
          choice password-choice {
            leaf priv-password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) privacy password";
              }
            }
            leaf clear {
              tailf:info "Specifies an UNENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) privacy password";
              }
            }
            leaf encrypted {
              tailf:info "Specifies an ENCRYPTED password will follow";
              type string {
                tailf:info "LINE;;The ENCRYPTED privacy password";
              }
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-optional-in-sequence;
          type string {
            tailf:info "WORD;;Access-list name";
          }
        }
        choice owner-choice {
          leaf SDROwner {
            tailf:info "SDR Owner permissions for MIB Objects";
            type empty;
          }
          leaf SystemOwner {
            tailf:info "System Owner permissions for MIB objects";
            type empty;
          }
        }
      }
      list view {
        tailf:info "Define an SNMPv2 MIB view";
        tailf:cli-suppress-mode;
        tailf:cli-incomplete-command;
        tailf:cli-compact-syntax;
        tailf:cli-delete-when-empty;
        key view-name;
        leaf view-name {
          type string {
            tailf:info "WORD;;Name of the view";
          }
        }
        list oid-list {
          tailf:cli-suppress-mode;
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          tailf:cli-compact-syntax;
          tailf:cli-delete-when-empty;
          key oid-tree;
          leaf oid-tree {
            type string {
              tailf:info "WORD;;MIB view family name";
            }
          }
          leaf viewmode {
            tailf:cli-drop-node-name;
            type enumeration {
              enum excluded {
                tailf:info "MIB family is excluded from the view";
              }
              enum included {
                tailf:info "MIB family is included in the view";
              }
            }
          }
        }
      }
      list group {
        tailf:info "Define a User Security Model group";
        tailf:cli-suppress-mode;
        tailf:cli-sequence-commands;
        tailf:cli-compact-syntax;
        tailf:cli-incomplete-command;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the group";
          }
        }
        choice version-choice {
          leaf v1 {
            tailf:info "group using the v1 security model";
            type empty;
          }
          leaf v2c {
            tailf:info "group using the v2c security model";
            type empty;
          }
          leaf v3 {
            tailf:info "group using the User Security Model (SNMPv3)";
            type enumeration {
              enum auth {
                tailf:info "group using the authNoPriv Security Level";
              }
              enum noauth {
                tailf:info "group using the noAuthNoPriv Security Level";
              }
              enum priv {
                tailf:info "group using authPriv Security Level";
              }
            }
          }
        }
        leaf read {
          tailf:info "specify a notify view for the group";
          tailf:cli-break-sequence-commands;
          type string {
            tailf:info "WORD;;read view name";
            length "1..64";
          }
        }
        leaf write {
          tailf:info "specify a write view for this group";
          type string {
            tailf:info "WORD;;write view name";
            length "1..64";
          }
        }
        leaf notify {
          tailf:info "specify a notify view for the group";
          type string {
            tailf:info "WORD;;notify view name";
            length "1..64";
          }
        }
        leaf context {
          tailf:info "Attach a SNMP context";
          type string {
            tailf:info "WORD;;SNMP Context Name";
          }
        }
        leaf access-list-type {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum IPv4 {
              tailf:info "Type of Access-list";
            }
            enum IPv6 {
              tailf:info "Type of Access-list";
            }
          }
        }
        leaf access-list {
          tailf:cli-drop-node-name;
          tailf:cli-disallow-value v1|v2c|v3|read|write|notify|context|IPv4|IPv6;
          type string {
            tailf:info "WORD;;Access-list name";
            length "1..64";
          }
        }
      }
      container interface {
        tailf:info "Enter the SNMP interface configuration commands";
        list subset {
          tailf:info "Add configuration for an interface subset";
          tailf:cli-mode-name config-snmp-if-subset;
          tailf:cli-sequence-commands;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;The interface subset number";
              range "1..255";
            }
          }
          leaf regular-expression {
            tailf:info "Interfaces matching regular expression";
            tailf:cli-hide-in-submode;
            type string {
              tailf:info "WORD;;Regular expression to match ifName";
            }
          }
          container notification {
            tailf:cli-break-sequence-commands;
            tailf:info "Allow an SNMP notification type";
            container linkupdown {
              tailf:info "SNMP linkUp and linkDown notifications";
              tailf:cli-delete-when-empty;
              presence true;
              leaf disable {
                tailf:info "Disable linkUp and linkDown notification";
                type empty;
              }
            }
          }
        }
        list interface-name {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-snmp-if;
          key ifname;
          leaf ifname {
            tailf:cli-disallow-value subset;
            type ifname;
          }
          container index {
            tailf:info "Configure ifIndex attributes";
            leaf persistence {
              tailf:info "Persistency across system reloads";
              type empty;
            }
          }
          container notification {
            tailf:info "Allow an SNMP notification type";
            container linkupdown {
              tailf:info "SNMP linkUp and linkDown notifications";
              tailf:cli-delete-when-empty;
              presence true;
              leaf disable {
                tailf:info "Disable linkUp and linkDown notification";
                type empty;
              }
            }
          }
        }
      }
      leaf chassis-id {
        tailf:info "String to uniquely identify this chassis";
        tailf:cli-full-command;
        tailf:cli-multi-value;
        type string {
          tailf:info "LINE;;Unique ID string";
        }
      }
      container traps {
        tailf:info "Enable SNMP traps";
        list traps-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            tailf:cli-multi-word-key;
            type string {
              tailf:info "WORD;;snmp-server traps <entry>";
            }
          }
        }
      }
      container timeouts {
        tailf:info "SNMP timeouts";
        leaf subagent {
          tailf:info "Sub-Agent Request timeout";
          type uint8 {
            tailf:info "<1-20>;;timeout in secs (default 10)";
            range "1..20";
          }
        }
      }
    }
    container srlg {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "SRLG configuration commands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      presence true;
    }
    list monitor-session {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Monitor-session configuration commands";
      tailf:cli-mode-name config-mon;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Session Name";
        }
      }
      choice type-choice {
        leaf ethernet {
          tailf:info "Specify the destination that traffic should be replicated to";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf ipv4 {
          tailf:info "Replicate IPv4 traffic";
          tailf:cli-hide-in-submode;
          type empty;
        }
        leaf ipv6 {
          tailf:info "Replicate IPv6 traffic";
          tailf:cli-hide-in-submode;
          type empty;
        }
      }
      container destination {
        tailf:info "Specify the destination that traffic should be replicated to";
        choice destination-choice {
          leaf pseudowire {
            tailf:info "Specify a pseudowire";
            type empty;
          }
          container interface {
            tailf:info "Specify a destination interface";
            uses interface-name-grouping;
          }
        }
      }
    }
    container spanning-tree {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Spanning Tree Subsystem";
      tailf:cli-explicit-exit;
      container extend {
        tailf:info "Spanning Tree 802.1t extensions";
        leaf system-id {
          tailf:info "Extend system-id into priority portion of the bridge id (PVST & Rapid PVST only)";
          type empty;
        }
      }
      leaf mode {
        tailf:info "Spanning tree operating mode";
        type enumeration {
          enum mst {
            tailf:info "Multiple spanning tree mode";
          }
          enum rapid-pvst {
            tailf:info "Per-Vlan rapid spanning tree mode";
          }
        }
      }
      container mst {
        tailf:info "Configure Multiple Spanning Tree Protocol.";
        list range {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-range-list-syntax;
          key id;
          leaf id {
            type uint8 {
              tailf:info "WORD;;MST instance range, example: 0-3,5,7-9";
            }
          }
          leaf priority {
            tailf:info "Set the bridge priority for the spanning tree";
            type uint16 {
              tailf:info "<0-61440>;;bridge priority in increments of 4096";
              range "0..61440";
            }
          }
        }
        list protocol-instance {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-mstp;
          key id;
          leaf id {
            type string {
              tailf:info "WORD;;Protocol Instance name.";
            }
          }
          leaf name {
            tailf:info "Configuration name";
            type string {
              tailf:info "WORD;;Configuration name";
            }
          }
          container maximum {
            tailf:info "Bridge maximums, such as max-age";
            leaf age {
              tailf:info "Bridge maximum age time.";
              type uint8 {
                tailf:info "<6-40>;;Bridge Maximum Age time in seconds.";
                range "6..40";
              }
            }
            leaf hops {
              tailf:info "Bridge maximum number of hops.";
              type uint8 {
                tailf:info "<6-40>;;Bridge Maximum number of hops.";
              }
            }
          }
          leaf revision {
            tailf:info "Bridge revision number.";
            type uint16 {
              tailf:info "<0-65535>;;Revision number.";
            }
          }
          container bringup {
            tailf:info "Bringup options.";
            container delay {
              tailf:info "Bringup delay for newly created interfaces.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf for {
                tailf:info "Specify length of time to delay bringup for";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-3600>;;Length of time to delay for (hours, minutes, or seconds)";
                }
              }
              leaf unit {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum seconds {
                    tailf:info "Time is in seconds";
                  }
                  enum minutes {
                    tailf:info "Time is in minutes";
                  }
                  enum hours {
                    tailf:info "Time is in hours";
                  }
                }
              }
            }
          }
          leaf forward-delay {
            tailf:info "Bridge forward delay time.";
            type uint8 {
              tailf:info "<4-30>;;Forward delay time in seconds.";
              range "4..30";
            }
          }
          container transmit {
            tailf:info "Bridge transmit options";
            leaf hold-count {
              tailf:info "Bridge Transmit Hold Count.";
              type uint8 {
                tailf:info "<1-10>;;Bridge Transmit Hold Count.";
              }
            }
          }
          leaf provider-bridge {
            tailf:info "Provider Bridge mode.";
            type empty;
          }
          list instance {
            tailf:info "Configure an MSTP instance.";
            tailf:cli-mode-name config-mstp-inst;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-4094>;;MSTI ID";
                range "0..4094";
              }
            }
            leaf priority {
              tailf:info "MSTI Priority.";
              type uint16 {
                tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                range "0..61440" {
                  tailf:step 4096;
                }
              }
            }
            leaf-list vlan-ids {
              tailf:info "Assign ranges of VLANs to the specified MSTI.";
              tailf:cli-range-list-syntax;
              tailf:cli-replace-all;
              type uint16 {
                tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
              }
            }
          }
          list interface {
            tailf:info "Enable and Configure MSTP on an interface.";
            tailf:cli-mode-name config-mstp-if;
            key ifname;
            leaf ifname {
              type ifname;
            }
            container portfast {
              tailf:info "Set PortFast on Interface.";
              presence true;
            }
            list instance {
              tailf:info "MSTI Specific configuration for this interface.";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<0-4094>;;MSTI ID";
                  range "0..4094";
                }
              }
              leaf cost {
                tailf:info "Cost of this port on this MSTI.";
                type uint32 {
                  tailf:info "<1-200000000>;;Port Cost";
                  range "1..200000000";
                }
              }
            }
            leaf link-type {
              tailf:info "Configure the Link Type of an Interface.";
              tailf:cli-full-command;
              type enumeration {
                enum multipoint {
                  tailf:info "Multipoint link.";
                }
                enum point-to-point {
                  tailf:info "Point to Point link.";
                }
              }
            }
            leaf external-cost {
              tailf:info "Interface External Cost.";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<1-200000000>;;Interface External Cost.";
                range "1..200000000";
              }
            }
          }
        }
      }
      leaf portfast {
        tailf:info "Spanning tree portfast options";
        type enumeration {
          enum disable {
            tailf:info "Disable portfast for this interface";
          }
          enum edge {
            tailf:info "Enable portfast edge on the interface";
          }
          enum network {
            tailf:info "Enable portfast network on the interface";
          }
        }
      }
      list mstag {
        tailf:info "Configure MST Access Gateway";
        tailf:cli-mode-name config-mstag;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }
        list interface {
          tailf:cli-mode-name config-mstag-if;
          key ifname;
          leaf ifname {
            type ifname;
          }
          leaf name {
            tailf:info "Configuration name";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;Configuration name";
            }
          }
          leaf port-id {
            tailf:info "Interface Port ID.";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-4095>;;Interface Port ID.";
              range "1..4095";
            }
          }
          leaf bridge-id {
            tailf:info "Set the Bridge ID this port should use";
            tailf:cli-full-command;
            type string {
              tailf:info "H.H.H;;MAC address";
              pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
            }
          }
          list instance {
            tailf:info "Enable and Configure an instance on this interface.";
            tailf:cli-mode-name config-mstag-if-inst;
            key id;
            leaf id {
              type uint16 {
                tailf:info "<0-4094>;;MSTI ID";
                range "0..4094";
              }
            }
            container cost {
              tailf:info "Cost of this port on this MSTI.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf cost-value {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<1-200000000>;;Port Cost";
                  range "1..200000000";
                }
              }
              leaf startup-value {
                tailf:info "Set the cost of this port on this MSTI to be used during pre-empt delay";
                type uint32 {
                  tailf:info "<1-200000000>;;Port Cost";
                  range "1..200000000";
                }
              }
            }
            leaf-list vlan-ids {
              tailf:info "Assign ranges of VLANs to the specified MSTI.";
              tailf:cli-range-list-syntax;
              type uint16 {
                tailf:info "WORD;;List of VLAN Ranges in the form a-b,c,d,e-f,g";
              }
            }
            container root-id {
              tailf:info "Set the Bridge ID of the root for this instance";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf root-id-value {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "H.H.H;;MAC address";
                  pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
                }
              }
              leaf startup-value {
                tailf:info "Set the Bridge ID to be used during pre-empt delay";
                type string {
                  tailf:info "H.H.H;;MAC address";
                  pattern "[0-9a-fA-F]+\\.[0-9a-fA-F]+\\.[0-9a-fA-F]+";
                }
              }
            }
            container priority {
              tailf:info "MSTI Priority.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf priority-value {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step 4096;
                  }
                }
              }
              leaf startup-value {
                tailf:info "Set the MSTI Priority to be used during pre-empt delay";
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step 4096;
                  }
                }
              }
            }
            container root-priority {
              tailf:info "Priority of the root for this instance.";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf priority-value {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step 4096;
                  }
                }
              }
              leaf startup-value {
                tailf:info "Set the priority of the root for this instance to be used during pre-empt delay";
                type uint16 {
                  tailf:info "<0-61440>;;MSTI Priority. Must be a multiple of 4096.";
                  range "0..61440" {
                    tailf:step 4096;
                  }
                }
              }
            }
          }
        }
      }
      list repag {
        tailf:info "Configure REP Access Gateway";
        tailf:cli-mode-name config-repag;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Protocol Instance name.";
          }
        }
        list interface {
          tailf:cli-mode-name config-repag-if;
          key ifname;
          leaf ifname {
            type ifname;
          }
        }
      }
    }
    container redundancy {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Interchassis redundancy configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-redundancy;
      tailf:cli-explicit-exit;
      container iccp {
        tailf:info "configure iccp parameter";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-redundancy-iccp;
        list group {
          tailf:info "group configuration";
          tailf:cli-mode-name config-redundancy-iccp-group;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-4294967295>;;Enter group number";
              range "1..4294967295";
            }
          }
          container mlacp {
            tailf:info "Multi-chassis Link Aggregation Control Protocol commands";
            leaf node {
              tailf:info "Set mLACP node ID to use in this ICCP Group";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-7>;;Unique node ID in the ICCP Group for this system.";
                range "0..7";
              }
            }
            container system {
              tailf:info "Set the default system parameters for LACP bundles";
              leaf mac {
                tailf:info "The LACP System ID to be used in this ICCP Group.";
                tailf:cli-full-command;
                type string {
                  tailf:info "H.H.H;;Unique ID for this system. Any non-zero value is permitted.";
                }
              }
              leaf priority {
                tailf:info "Set the LACP system priority to be used in this ICCP Group.";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<1-65535>;;Priority for this system. Lower value is higher priority.";
                  range "1..65535";
                }
              }
            }
            container connect {
              tailf:info "Specify configuration options for connecting to mLACP peers.";
              leaf timeout {
                tailf:info "Specify time to wait before assuming mLACP peer is down.";
                type uint16 {
                  tailf:info "<0-65534>;;Number of seconds to wait before assuming mLACP peer is down.";
                  range "0..65534";
                }
              }
            }
          }
          container member {
            tailf:info "configure ICCP members";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-redundancy-group-iccp-member;
            leaf neighbor {
              tailf:info "configure interchassis group ICCP members";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;neighbor ip address";
              }
            }
          }
          container mode {
            tailf:info "Set the group mode";
            leaf singleton {
              tailf:info "Run the group in singleton mode";
              type empty;
            }
          }
          container backbone {
            tailf:info "configure ICCP backbone interfaces";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-redundancy-group-iccp-backbone;
            list interface {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }
            }
          }
          container isolation {
            tailf:info "Set the isolation parameters";
            leaf recovery-delay {
              tailf:info "Specify delay before clearing isolation condition after recovery from failure";
              type uint16 {
                tailf:info "<30-600>;;Recovery delay in seconds.";
                range "30..600";
              }
            }
          }
          container nv {
            tailf:info "Network Virtualization configuration";
            container satellite {
              tailf:info "Satellite configuration";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-nV;
              leaf system-mac {
                tailf:info "System MAC for this redundancy-group";
                type string {
                  tailf:info "H.H.H;;Optional system MAC address.";
                }
              }
            }
          }
        }
      }
    }
    container ssh {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Secure Shell configuration";
      tailf:cli-explicit-exit;
      container client {
        tailf:info "Provide SSH client service";
        container source-interface {
          tailf:info "Source interface for ssh client sessions";
          uses interface-name-grouping;
        }
        leaf dscp {
          tailf:info "DSCP value for ssh client sessions";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-63>;;DSCP value range";
            range "0..63";
          }
        }
      }
      container server {
        tailf:info "Provide SSH server service";
        leaf dscp {
          tailf:info "Cisco ssh server DSCP";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-63>;;DSCP value range";
            range "0..63";
          }
        }
        leaf logging {
          tailf:info "Enable ssh server logging";
          tailf:cli-full-command;
          type empty;
        }
        container netconf {
          tailf:info "start ssh service for netcon";
          tailf:cli-delete-when-empty;
          presence true;
          leaf port {
            tailf:info "start ssh service on port";
            type uint16 {
              tailf:info "<1-65535>;;port number on which ssh service to be started for netconf";
            }
          }
        }
        leaf rate-limit {
          tailf:info "Cisco sshd rate-limit of service requests";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-600>;;Limit in term of number of request per minute(default 60)";
            range "1..600";
          }
        }
        leaf session-limit {
          tailf:info "Cisco sshd session-limit of service requests";
          tailf:cli-full-command;
          type uint32 {
            tailf:info "<1-1024>;;Number of allowable concurrent incoming ssh sessions";
            range "1..1024";
          }
        }
        leaf v2 {
          tailf:info "Cisco sshd force protocol version 2 only";
          tailf:cli-full-command;
          type empty;
        }
        list vrf {
          tailf:info "Cisco sshd VRF name";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter vrf name";
            }
          }
          container ipv4 {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:info "IPv4 access list for ssh server";
            leaf access-list {
              tailf:info "Configure IPv4 access-list";
              type string {
                tailf:info "WORD;;Name of IPv4 access list - Max 32 characters";
              }
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv4/access-list/named-acl/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
          container ipv6 {
            tailf:cli-compact-syntax;
            tailf:cli-flatten-container;
            tailf:info "IPv6 access list for ssh server";
            leaf access-list {
              tailf:info "Configure IPv6 access-list";
              type string {
                tailf:info "WORD;;Name of IPv6 access list - Max 32 characters";
              }
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:ipv6/access-list/named-acl/name" {
                  tailf:xpath-root 3;
                }
              }
            }
          }
        }
      }
      leaf timeout {
        tailf:info "Set timeout value for SSH";
        type uint8 {
          tailf:info "<5-120>;;Timeout value between 5-120 seconds";
          range "5..120";
        }
      }
    }
    list track {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Track";
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;track name";
        }
      }
      container type {
        tailf:info "Set track type";
        container rtr {
          tailf:info "track type ipsla";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands;
          leaf ipsla-no {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint16 {
              tailf:info "<1-2048>;;ipsla operation number";
              range "1..2048";
            }
          }
          leaf reachability {
            tailf:info "Tracks whether the route is reachable";
            type empty;
          }
        }
        container line-protocol {
          tailf:info "track type line-protocol";
          container state {
            tailf:info "track type line-protocol state";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-track-line-prot;
            container interface {
              tailf:info "Set track interface";
              uses interface-name-grouping;
            }
          }
        }
      }
    }
    container ipsla {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "IPSLA configuration commands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      list operation {
        tailf:info "IPSLA operation configuration";
        tailf:cli-mode-name config-ipsla-op;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-2048>;;Operation number";
            range "1..2048";
          }
        }
        container type {
          tailf:info "Type of operation";
          list udp {
            tailf:info "UDP operation types";
            tailf:cli-mode-name config-ipsla-udp;
            key name;
            leaf name {
              type enumeration {
                enum echo {
                  tailf:info "UDP echo operation type";
                }
                enum jitter {
                  tailf:info "UDP jitter operation type";
                }
              }
            }
            uses ipsla-operation-type-grouping;
          }
          list icmp {
            tailf:info "ICMP operation types";
            tailf:cli-mode-name config-ipsla-icmp;
            key name;
            leaf name {
              type enumeration {
                enum echo {
                  tailf:info "ICMP echo operation type";
                }
                enum path-echo {
                  tailf:info "ICMP path-echo operation type";
                }
                enum path-jitter {
                  tailf:info "ICMP path-jitter operation type";
                }
              }
            }
            uses ipsla-operation-type-grouping;
          }
          container mpls {
            tailf:info "MPLS operation types";
            list lsp {
              tailf:info "MPLS LSP operation types";
              tailf:cli-mode-name config-ipsla-mpls-lsp;
              key name;
              leaf name {
                type enumeration {
                  enum ping {
                    tailf:info "MPLS Echo operation type";
                  }
                  enum trace {
                    tailf:info "MPLS Trace operation type";
                  }
                }
              }
              uses ipsla-operation-type-grouping;
            }
          }
        }
      }
      container reaction {
        tailf:info "IPSLA reaction configuration";
        list operation {
          tailf:info "Reaction configuration for operation";
          tailf:cli-mode-name config-ipsla-react;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-2048>;;Operation number";
              range "1..2048";
            }
          }
          container react {
            tailf:info "Specify an element to be monitored for reaction";
            container connection-loss {
              tailf:info "Reaction on connection loss of monitored operation";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ipsla-react-cond;
              uses ipsla-reaction-operation-react-grouping;
            }
            container packet-loss {
              tailf:info "Reaction on packet loss value violation";
              container dest-to-source {
                tailf:info "Packet loss  destination to source(DS) violation";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-ipsla-react-cond;
                uses ipsla-reaction-operation-react-grouping;
              }
              container source-to-dest {
                tailf:info "Packet loss source to destination (SD) violation";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-ipsla-react-cond;
                uses ipsla-reaction-operation-react-grouping;
              }
            }
            container timeout {
              tailf:info "Reaction on timeout of monitored operation";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ipsla-react-cond;
              container action {
                tailf:info "Type of action to be taken on threshold violation(s)";
                leaf logging {
                  tailf:info "Generate a syslog alarm on threshold violation";
                  type empty;
                }
                leaf trigger {
                  tailf:info "Generate trigger to active reaction triggered operation(s)";
                  type empty;
                }
              }
              container threshold {
                tailf:info "Configure threshold parameters on monitored element";
                container type {
                  tailf:info "Threshold type";
                  choice type-choice {
                    leaf consecutive {
                      tailf:info "Take action after a number of consecutive violations";
                      type uint8 {
                        tailf:info "<1-16>;;Number of consecutive violations";
                        range "1..16";
                      }
                    }
                    leaf immediate {
                      tailf:info "Take action immediately upon threshold violation";
                      type empty;
                    }
                    container xofy {
                      tailf:info "Take action upon X violations in Y probe operations";
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf x-value {
                        tailf:cli-drop-node-name;
                        type uint8 {
                          tailf:info "<1-16>;;Number of threshold violations (X value)";
                          range "1..16";
                        }
                      }
                      leaf y-value {
                        tailf:cli-drop-node-name;
                        type uint8 {
                          tailf:info "<1-16>;;Number of probes observing the violations (Y value)";
                          range "1..16";
                        }
                      }
                    }
                  }
                }
              }
            }
            container rtt {
              tailf:info "Reaction on round trip time violation";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ipsla-react-cond;
              uses ipsla-reaction-operation-react-grouping;
            }
          }
        }
      }
      container schedule {
        tailf:info "Schedule an operation";
        list operation {
          tailf:info " Specify an operation";
          tailf:cli-mode-name config-ipsla-sched;
          key id;
          leaf id {
            type uint16 {
              tailf:info "<1-2048>;;Operation number";
              range "1..2048";
            }
          }
          container start-time {
            tailf:info "Start time of the operation";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            choice start-time-choice {
              leaf after {
                tailf:info "Schedule operation after specified time";
                type string {
                  tailf:info "hh:mm:ss;;Start after (hh:mm:ss) has elapsed";
                }
              }
              leaf now {
                tailf:info "Schedule operation now";
                type empty;
              }
              leaf pending {
                tailf:info "Keep operation in the pending state";
                type empty;
              }
              leaf time {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "hh:mm[:ss];;Start time (hh:mm:[ss])";
                }
              }
            }
          }
          leaf life {
            tailf:info "Length of the time to execute (default 3600 seconds)";
            type union {
              type enumeration {
                enum forever {
                  tailf:info "Schedule operation to run indefinitely";
                }
              }
              type uint32 {
                tailf:info "<1-2147483647>;;Life in seconds. (default 3600 seconds)";
                range "1..2147483647";
              }
            }
          }
          leaf ageout {
            tailf:info "How long to keep this entry after it becomes inactive";
            type uint32 {
              tailf:info "<0-2073600>;;Ageout interval in seconds (default 0, never ageout)";
              range "0..2073600";
            }
          }
        }
      }
      leaf key-chain {
        tailf:info "Use MD5 authentication for IPSLA control message";
        tailf:cli-full-command;
        type string {
          tailf:info "WORD;;Name of key-chain";
        }
      }
      container responder {
        tailf:info "IPSLA responder configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-ipsla-resp;
        presence true;
        container twamp {
          tailf:info "Setup TWAMP responder";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-twamp-ref;
          presence true;
        }
      }
    }
    container performance-mgmt {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Performance Management configuration & operation subcommands";
      tailf:cli-explicit-exit;
      container statistics {
        tailf:info "Configure statistics for data collection";
        container interface {
          tailf:info "Configure statistics collection for interfaces";
          container basic-counters {
            tailf:info "Configure data collection for basic counters";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name config-stats-cntr;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
          container data-rates {
            tailf:info "Configure data collection for data rates";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name config-stats-cntr;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
        }
      }
      container thresholds {
        tailf:info "Configure thresholds for collected data";
        container node {
          tailf:info "Configure thresholds for node";
          container cpu {
            tailf:info "Configure thresholds for cpu";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name config-threshold-cpu;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
          container process {
            tailf:info "Configure thresholds for process";
            list template {
              tailf:info "Specify template";
              tailf:cli-mode-name config-threshold-proc;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Template name";
                }
              }
              uses performance-mgmt-grouping;
            }
          }
        }
      }
      list apply {
        tailf:info "Start data collection and/or threshold monitoring";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          tailf:cli-multi-word-key;
          type string {
            tailf:info "WORD;;performance-mgmt object";
          }
        }
      }
    }
    container vlan {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Vlan commands";
      tailf:cli-explicit-exit;
      container internal {
        tailf:info "internal VLAN";
        container allocation {
          tailf:info "internal VLAN allocation";
          leaf policy {
            tailf:info "internal VLAN allocation policy";
            type enumeration {
              enum ascending {
                tailf:info "Allocate internal VLAN in ascending order";
              }
              enum descending {
                tailf:info "Allocate internal VLAN in descending order";
              }
            }
          }
        }
      }
      container access-log {
        tailf:info "Configure VACL logging";
        leaf maxflow {
          tailf:info "Set vacl logging maximum flow number";
          type uint16 {
            tailf:info "<0-2048>;;Maximum flow number";
            range "0..2048";
          }
        }
        leaf ratelimit {
          tailf:info "Set vacl logging rate limiter ";
          type uint16 {
            tailf:info "<0-5000>;;Maximum number of packets logged per second";
            range "0..5000";
          }
        }
        leaf threshold {
          tailf:info "Set vacl log-update threshold";
          type uint32 {
            tailf:info "<0-2147483647>;;log-update threshold (number of hits)";
            range "0..2147483647";
          }
        }
      }
      list vlan-list {
        tailf:cli-drop-node-name;
        tailf:cli-mode-name config-vlan;
        tailf:cli-range-list-syntax;
        key id;
        leaf id {
          type uint16 {
            tailf:info "WORD;;ISL VLAN IDs 1-4094";
            range "1..4094";
          }
        }
        leaf name {
          tailf:info "Ascii name of the VLAN";
          tailf:cli-full-command;
          tailf:cli-multi-value;
          type string {
            tailf:info "WORD;;The ascii name for the VLAN";
          }
        }
        leaf uni-vlan {
          tailf:info "Configure a UNI VLAN";
          tailf:cli-full-command;
          type enumeration {
            enum community {
              tailf:info "UNI/ENI community VLAN";
            }
            enum isolated {
              tailf:info "UNI/ENI isolated VLAN";
            }
          }
        }
      }
    }
    container lldp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global LLDP configuration subcommands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      presence true;
      leaf holdtime {
        tailf:info "Specify the holdtime (in sec) to be sent in packets";
        type uint16 {
          tailf:info "<0-65535>;;Length  of time  (in sec) that receiver must keep this packet ";
        }
      }
      leaf reinit {
        tailf:info "Delay (in sec) for LLDP initialization on any interface";
        type uint8 {
          tailf:info "<2-5>;;Specify the delay (in secs) for LLDP to initialize";
          range "2..5";
        }
      }
      leaf run {
        tailf:info "Enable LLDP";
        type empty;
      }
      leaf timer {
        tailf:info "Specify the rate at which LLDP packets are sent (in sec)";
        type uint16 {
          tailf:info "<5-65534>;;Rate at which LLDP packets are sent (in sec)";
          range "5..65534";
        }
      }
    }
    container igmp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "IPv4 Address Family";
      container snooping {
        tailf:info "Enter IGMP snooping subcommands";
        list profile {
          tailf:info "Enter IGMP snooping profile name";
          tailf:cli-mode-name config-igmp-snooping-profile;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Profile name - maximum 32 characters";
            }
          }
          leaf system-ip-address {
            tailf:info "Source address for generated IGMP messages";
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;Enter a valid ip address";
            }
          }
          container internal-querier {
            tailf:info "Configure the IGMP internal-querier";
            presence true;
          }
        }
      }
    }
    container switch-fabric {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      list service-policy {
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name of the service policy";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:policy-map/name" {
              tailf:xpath-root 3;
            }
          }
        }
      }
    }
    container lpts {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "lpts configuration commands";
      tailf:cli-explicit-exit;
      container pifib {
        tailf:info "pre-ifib configuration commands";
        container hardware {
          tailf:info "hardware configuration commands";
          container police {
            tailf:info "ingress policers configuration command";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-pifib-policer-global;
            uses lpts-grouping;
            list location {
              tailf:info "Location Specification";
              tailf:cli-mode-name config-pifib-policer-per-node;
              key node-id;
              leaf node-id {
                type string {
                  tailf:info "WORD;;Enter Location";
                }
              }
              uses lpts-grouping;
            }
          }
        }
      }
      container punt {
        tailf:info "punt configuration commands";
        container police {
          tailf:info "ingress policers configuration command";
          list location {
            tailf:info "Configure line card location";
            tailf:cli-mode-name config-punt-policer-per-node;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Fully qualified line card specification";
              }
            }
          }
        }
      }
    }
    container hw-module {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure h/w module";
      tailf:cli-explicit-exit;
      container qos {
        container pol-gran {
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf granularity {
            tailf:cli-drop-node-name;
            type uint8 {
              range "8..64";
            }
          }
          leaf location {
            type string;
          }
        }
        container queue-auto-defrag {
          container disable {
            list location {
              key id;
              leaf id {
                type string;
              }
            }
          }
        }
        container account {
          container layer2 {
            container encapsulation {
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              choice encapsulation-choice {
                leaf arpa {
                  type empty;
                }
                leaf dot1q {
                  type empty;
                }
                leaf length {
                  type uint8 {
                    range "1..50";
                  }
                }
              }
              leaf location {
                type string;
              }
            }
          }
        }
        container multicast {
          tailf:cli-compact-syntax;
          leaf location {
            type string;
          }
          container priorityq {
            container disable {
              leaf location {
                type string;
              }
            }
          }
        }
      }
      container pse {
        container allocate {
          container tcam {
            list location {
              key id;
              leaf id {
                type string;
              }
              list region {
                key "name num";
                leaf name {
                  type string;
                }
                leaf num {
                  type uint32;
                }
              }
            }
          }
        }
      }
      container mac-move {
        tailf:info "Configure mac-move behavior.";
        leaf police-mode {
          tailf:info "Control the mode for mac-move.";
          type enumeration {
            enum on {
              tailf:info "Switch on mac-move policing.";
            }
            enum off {
              tailf:info "Switch off mac-move policing.";
            }
          }
        }
      }
      container location {
        tailf:info "Configure line card location";
        list location-breakout-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-incomplete-command;
          key "id port";
          leaf id {
            type string {
              tailf:info "WORD;;Fully qualified line card specification";
            }
          }
          leaf port {
            tailf:info "CPAK port configuration";
            tailf:cli-expose-key-name;
            type uint8 {
              tailf:info "<0-7>;;CPAK port number";
              range "0..7";
            }
          }
          leaf breakout {
            tailf:info "breakout interface types";
            type string {
              tailf:info "WORD;;Interface mode";
            }
          }
        }
      }
      list subslot {
        tailf:info "Configure subslot h/w module";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        leaf cardtype {
          tailf:info "Configure the SPA physical interface type";
          tailf:cli-full-command;
          type enumeration {
            enum e1 {
              tailf:info "E1 interface type";
            }
            enum e3 {
              tailf:info "E3 interface type";
            }
            enum sdh {
              tailf:info "SDH interface type";
            }
            enum sonet {
              tailf:info "Sonet interface type";
            }
            enum t1 {
              tailf:info "T1 interface type";
            }
            enum t3 {
              tailf:info "T3 interface type(default)";
            }
          }
        }
        container shutdown {
          tailf:info "Shutdown a subslot h/w module";
          tailf:cli-delete-when-empty;
          presence true;
          leaf option {
            tailf:cli-drop-node-name;
            type enumeration {
              enum powered {
                tailf:info "Keep the shutdown module powered (default)";
              }
              enum unpowered {
                tailf:info "Keep the shutdown module unpowered";
              }
            }
          }
        }
      }
      list port {
        tailf:info "The port";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key id;
        leaf id {
          type uint8 {
            tailf:info "<0-15>;;Port number on the specified Linecard";
            range "0..15";
          }
        }
        list srp {
          tailf:info "set port in SRP mode";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key location;
          leaf location {
            tailf:info "Fully qualified location";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;fully qualified port location";
            }
          }
          leaf spa-bay {
            tailf:info "Execute subslot h/w module operations";
            type uint8 {
              tailf:info "<0-5>;;spa_to_configure";
              range "0..5";
            }
          }
        }
      }
    }
    list class-map {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure QoS Class Map";
      tailf:cli-mode-name config-cmap;
      tailf:cli-exit-command end-class-map;
      key name;
      leaf name {
        tailf:cli-disallow-value end-class-map;
        type string {
          tailf:info "WORD;;class-map name";
        }
      }
      leaf type {
        tailf:info "The type of class-map";
        tailf:cli-prefix-key;
        type enumeration {
          enum traffic {
            tailf:info "Traffic class-map";
          }
        }
      }
      leaf prematch {
        tailf:cli-drop-node-name;
        tailf:cli-prefix-key;
        type enumeration {
          enum match-all {
            tailf:info "Logical-AND all matching statements under this classmap";
          }
          enum match-any {
            tailf:info "Logical-OR all matching statements under this classmap";
          }
        }
        default match-all;
      }
      leaf description {
        tailf:info "Class-Map description";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description of this class-map (up to 200 characters)";
        }
      }
      container match {
        tailf:info "classification criteria";
        uses class-map-match-grouping;
        container not {
          tailf:info "Negate match criteria";
          uses class-map-match-grouping;
        }
      }
    }
    list policy-map {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure a policymap";
      tailf:cli-mode-name config-pmap;
      tailf:cli-exit-command end-policy-map {
        tailf:info "End policy map configuration";
      }
      key name;
      leaf name {
        tailf:cli-disallow-value end-policy-map;
        type string {
          tailf:info "WORD;;Name of the policymap";
        }
      }
      leaf type {
        tailf:info "The type of policymap";
        tailf:cli-prefix-key;
        type enumeration {
          enum pbr {
            tailf:info "PBR policy-map";
          }
          enum performance-traffic {
            tailf:info "Performance traffic policy-map";
          }
          enum redirect {
            tailf:info "Redirect policy-map";
          }
          enum traffic {
            tailf:info "Traffic policy-map";
          }
        }
      }
      leaf description {
        tailf:info "Set description for this policy-map";
        tailf:cli-multi-value;
        tailf:cli-preformatted;
        tailf:cli-full-command;
        type string {
          tailf:info "LINE;;Description for this policy-map";
        }
      }
      container class {
        tailf:info "Class map";
        list class-ref {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-pmap-c;
          tailf:cli-full-command;
          ordered-by user;
          key map;
          leaf map {
            tailf:cli-disallow-value class-default;
            type string {
              tailf:info "WORD;;Name of class";
            }
            tailf:non-strict-leafref {
              path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:class-map/name" {
                tailf:xpath-root 3;
              }
            }
          }
          uses policy-map-class-grouping;
        }
        list class-default {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-pmap-c;
          tailf:cli-full-command;
          key map;
          leaf map {
            type enumeration {
              enum class-default {
                tailf:info "The default class";
              }
            }
          }
          uses policy-map-class-grouping;
        }
      }
    }
    container crypto {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global Crypto configuration command";
    }
    container flow {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure a flexible flow object";
      tailf:cli-explicit-exit;
      list exporter-map {
        tailf:info "Configure a flow exporter map";
        tailf:cli-mode-name config-fem;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Exporter map name - maximum 32 characters";
          }
        }
        container version {
          tailf:info "Specify export version parameters";
          container v9 {
            tailf:info "Use version 9 export format";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-fem-ver;
            container options {
              tailf:info "Specify export of options template";
              container interface-table {
                tailf:info "Export interface table";
                tailf:cli-delete-when-empty;
                presence true;
                leaf timeout {
                  tailf:info "Specify export timeout";
                  type uint32 {
                    tailf:info "<1-604800>;;1Timeout value in seconds";
                    range "1..604800";
                  }
                }
              }
              container sampler-table {
                tailf:info "Export sampler table";
                tailf:cli-delete-when-empty;
                presence true;
                leaf timeout {
                  tailf:info "Specify export timeout";
                  type uint32 {
                    tailf:info "<1-604800>;Timeout value in seconds";
                    range "1..604800";
                  }
                }
              }
            }
            container template {
              tailf:info "Specify template export parameters";
              leaf timeout {
                tailf:info "Specify custom timeout for the template";
                type uint32 {
                  tailf:info "<1-604800>;Timeout value in seconds";
                  range "1..604800";
                }
              }
              container data {
                tailf:info "Data template configuration options";
                leaf timeout {
                  tailf:info "Specify custom timeout for the template";
                  type uint32 {
                    tailf:info "<1-604800>;;Timeout value in seconds";
                    range "1..604800";
                  }
                }
              }
              container options {
                tailf:info "Options template configuration options";
                leaf timeout {
                  tailf:info "Specify custom timeout for the template";
                  type uint32 {
                    tailf:info "<1-604800>;;Timeout value in seconds";
                    range "1..604800";
                  }
                }
              }
            }
          }
        }
        leaf dscp {
          tailf:info "Specify DSCP value for export packets";
          tailf:cli-full-command;
          type uint8 {
            tailf:info "<0-63>;;Differentiated services codepoint value";
            range "0..63";
          }
        }
        container transport {
          tailf:info "Specify the transport protocol for export packets";
          leaf udp {
            tailf:info "Use UDP as transport protocol";
            type uint16 {
              tailf:info "<1024-65535>;;Destination UDP port value";
              range "1024..65535";
            }
          }
        }
        container source {
          tailf:info "Source interface";
          uses interface-name-grouping;
        }
        container destination {
          tailf:info "Export destination configuration";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf address {
            tailf:cli-drop-node-name;
            type inet:host {
              tailf:info "Hostname or A.B.C.D  Destination IP address";
            }
          }
          leaf vrf {
            tailf:info "Configure VRF to be used for reaching export destination";
            type vrf-type;
          }
        }
      }
      list monitor-map {
        tailf:info "Configure a flow monitor map";
        tailf:cli-mode-name config-fmm;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Monitor map name - maximum 32 characters";
          }
        }
        container record {
          tailf:info "Specify a flow record map name";
          choice record-choice {
            container ipv4 {
              tailf:info "IPv4 raw record format";
              presence true;
              choice record-ipv4-choice {
                leaf peer-as {
                  tailf:info "Record peer AS";
                  type empty;
                }
                leaf destination-tos {
                  tailf:info "IPv4 Destination Based NetFlow Accounting TOS";
                  type empty;
                }
              }
            }
            container ipv6 {
              tailf:info "IPv6 raw record format";
              presence true;
              leaf peer-as {
                tailf:info "Record peer AS";
                type empty;
              }
            }
            container mpls {
              tailf:info "MPLS record format";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              presence true;
              leaf fields-fmt {
                tailf:cli-drop-node-name;
                tailf:cli-optional-in-sequence;
                type enumeration {
                  enum ipv4-fields {
                    tailf:info "MPLS with IPv4 fields format";
                  }
                  enum ipv4-ipv6-fields {
                    tailf:info "MPLS with IPv4 and IPv6 fields format";
                  }
                  enum ipv6-fields {
                    tailf:info "MPLS with IPv6 fields format";
                  }
                }
              }
              leaf labels {
                tailf:info "Labels to be used for Hashing";
                type uint8 {
                  tailf:info "<1-6>;;Number of Labels to be used for Hashing";
                  range "1..6";
                }
              }
            }
          }
        }
        leaf exporter {
          tailf:info "Specify flow exporter map name";
          type string {
            tailf:info "WORD;;Exporter map name - maximum 32 characters";
          }
          tailf:non-strict-leafref {
            path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:flow/exporter-map/name" {
              tailf:xpath-root 3;
            }
          }
        }
        container cache {
          tailf:info "Specify flow cache attributes";
          leaf entries {
            tailf:info "Specify the number of entries in the flow cache";
            type uint32 {
              tailf:info "<4096-1000000>;;Number of flow cache entries";
              range "4096..1000000";
            }
          }
          container timeout {
            tailf:info "Specify the flow cache timeouts";
            leaf active {
              tailf:info "Specify the active flow timeout";
              type uint32 {
                tailf:info "<1-604800>;;Timeout value in seconds";
                range "1..604800";
              }
            }
            leaf inactive {
              tailf:info "Specify the inactive flow timeout";
              type uint32 {
                tailf:info "<1-604800>;;Timeout value in seconds";
                range "1..604800";
              }
            }
            leaf rate-limit {
              tailf:info "Maximum number of entries to age each second";
              type uint32 {
                tailf:info "<1-1000000>;;Entries per second";
                range "1..1000000";
              }
            }
            leaf update {
              tailf:info "Specify the update timeout";
              type uint32 {
                tailf:info "<1-604800>;;Timeout value in seconds";
                range "1..604800";
              }
            }
          }
        }
      }
    }
    list sampler-map {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure a sampler map";
      tailf:cli-mode-name config-sm;
      tailf:cli-explicit-exit;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Sampler map name - maximum 32 characters";
        }
      }
      container random {
        tailf:info "Use random mode for sampling packets";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf number-of-packets {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type enumeration {
            enum 1 {
              tailf:info "<1-1>;;Number of packets to be sampled in the sampling interval";
            }
          }
        }
        leaf out-of {
          tailf:info "Sample one packet out of";
          tailf:cli-incomplete-command;
          type empty;
        }
        leaf sampling-interval {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<1-65535>;;Sampling interval in units of packets";
            range "1..65535";
          }
        }
      }
    }
    container clock-interface {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Clock interface configuration commands";
      tailf:cli-explicit-exit;
      list sync {
        tailf:info "Synchronization clock interface";
        tailf:cli-mode-name config-clock-if;
        key "id location";
        leaf id {
          type uint32 {
            tailf:info "<0-4294967295>;;Clock interface port number";
          }
        }
        leaf shutdown {
          tailf:info "Disable the SyncE Port";
          type empty;
        }
        leaf location {
          tailf:info "Specify the clock interface location";
          tailf:cli-expose-key-name;
          type string {
            tailf:info "WORD;;Fully qualified location specification";
          }
        }
        container port-parameters {
          tailf:info "clock port parameter setting";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-clk-parms;
          container bits-input {
            tailf:info "BITS RX interface";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf mode {
              tailf:cli-drop-node-name;
              type enumeration {
                enum 2m {
                  tailf:info "2m mode";
                }
                enum 64k-input-only {
                  tailf:info "64k-input-only mode";
                }
                enum e1 {
                  tailf:info "e1 mode";
                }
                enum t1 {
                  tailf:info "t1 mode";
                }
              }
            }
            leaf mode1 {
              tailf:cli-drop-node-name;
              type enumeration {
                enum d4 {
                  tailf:info "d4 mode";
                }
                enum esf {
                  tailf:info "esf mode";
                }
                enum crc-4 {
                  tailf:info "crc4 mode";
                }
                enum non-crc-4 {
                  tailf:info "non-crc-4 mode";
                }
              }
            }
            leaf sa {
              when "../mode1 = 'crc-4'" {
                tailf:xpath-root 3;
              }
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum sa4 {
                  tailf:info "SSM on Sa4 bit channel";
                }
                enum sa5 {
                  tailf:info "SSM on Sa5 bit channel";
                }
                enum sa6 {
                  tailf:info "SSM on Sa6 bit channel";
                }
                enum sa7 {
                  tailf:info "SSM on Sa7 bit channel";
                }
                enum sa8 {
                  tailf:info "SSM on Sa8 bit channel";
                }
              }
            }
            leaf mode2 {
              tailf:cli-drop-node-name;
              type union {
                type enumeration {
                  enum ami {
                    tailf:info "ami mode";
                  }
                  enum b8zs {
                    tailf:info "b8zs mode";
                  }
                  enum hdb3 {
                    tailf:info "hdb3 mode";
                  }
                }
                type string;
              }
            }
          }
        }
        container frequency {
          tailf:info "Frequency Synchronization configuration";
          container synchronization {
            tailf:info "Frequency Synchronization configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-clk-freqsync;
            container selection {
              tailf:info "Selection configuration commands";
              leaf input {
                tailf:info "Enable this source for selection";
                type empty;
              }
            }
            leaf priority {
              tailf:info "Source priority";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-254>;;Source priority";
                range "1..254";
              }
            }
            leaf wait-to-restore {
              tailf:info "Set the wait-to-restore time";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<0-12>;;Wait-to-restore time, in minutes";
                range "0..12";
              }
            }
            container ssm {
              tailf:info "SSM configuration commands";
              leaf disable {
                tailf:info "Disable sending of SSMs";
                type empty;
              }
            }
            container quality {
              tailf:info "Quality level configuration";
              container receive {
                tailf:info "Adjust the received quality level";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                uses freqsync-quality-grouping;
              }
            }
          }
        }
      }
    }
    container l2 {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Layer 2 configuration";
      tailf:cli-explicit-exit;
      list vfi {
        tailf:info "Configure a virtual forwarding instance";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;VFI name";
          }
        }
        leaf mode {
          tailf:cli-drop-node-name;
          tailf:cli-hide-in-submode;
          type enumeration {
            enum manual;
            enum autodiscovery {
              tailf:info "Multipoint autodiscovery configuration mode";
            }
          }
        }
        container vpn {
          tailf:info "VPN configuration";
          leaf id {
            tailf:info "VPN id";
            type uint32 {
              tailf:info "<1-4294967295>;;VPN id value";
              range "1..4294967295";
            }
          }
        }
      }
    }
    container auto {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Automation";
      tailf:cli-explicit-exit;
      leaf qos {
        tailf:info "Configure AutoQoS";
        type enumeration {
          enum default {
            tailf:info "Configure AutoQoS Default";
          }
        }
      }
    }
    container ethernet-services {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Ethernet related services";
      tailf:cli-explicit-exit;
      list access-list {
        tailf:cli-mode-name config-es-acl;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Access list name - maximum 32 characters";
            length "1..32";
          }
        }
        list rule {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key id;
          leaf id {
            type uint32 {
              tailf:info "<1-2147483646>;;Sequence number for this entry";
              range "1..2147483646";
            }
          }
          leaf line {
            tailf:cli-drop-node-name;
            tailf:cli-multi-value;
            type string {
              tailf:info
                "deny;;Specify packets to reject
                 permit;;Specify packets to forward
                 remark;;Comment for access list";
              pattern "(deny.*)|(permit.*)|(remark.*)|(no.*)";
            }
          }
        }
      }
    }
    container interface {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Select an interface to configure";
      tailf:cli-explicit-exit;
      uses interface-grouping;
      container preconfigure {
        tailf:info "Specify a preconfig";
        uses interface-grouping;
      }
    }
    container controller {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Controller configuration subcommands";
      tailf:cli-explicit-exit;
      uses controller-grouping;
      container preconfigure {
        tailf:info "Specify a preconfig";
        uses controller-grouping;
      }
    }
    container evpn {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure E-VPN commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-evpn;
      tailf:cli-explicit-exit;
      list evi {
        tailf:info "Configure Ethernet VPN ID(EVI)";
        tailf:cli-mode-name config-evpn-evi;
        key id;
        leaf id {
          type uint16 {
            tailf:info "<1-65534>;;Ethernet VPN ID to set";
            range "1..65534";
          }
        }
        container bgp {
          tailf:cli-add-mode;
          tailf:cli-mode-name config-evpn-evi-bgp;
          presence true;
          leaf rd {
            tailf:info "Set the Route Distinguisher";
            tailf:cli-full-command;
            type string {
              tailf:info "WORD;;AS-number or IPv4 address:index";
            }
          }
          container route-target {
            tailf:info "Set the Route Target";
            list import {
              tailf:info "Import Route Target";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;AS-number or IPv4 address:index";
                }
              }
              leaf stitching {
                tailf:info " Route Target for Fabric side";
                type empty;
              }
            }
            list export {
              tailf:info "Export Route Target";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;AS-number or IPv4 address:index";
                }
              }
              leaf stitching {
                tailf:info " Route Target for Fabric side";
                type empty;
              }
            }
          }
        }
        container network-controller {
          tailf:info "Configure EVPN Network Controller Settings";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-evpn-evi-nc;
          leaf vni {
            tailf:info "Layer 3 VXLAN VNI";
            type uint16 {
              tailf:info "<0-65535>;;Layer 3 VXLAN VNI";
              range "0..65535";
            }
          }
          list host {
            tailf:info "Host Configuration";
            tailf:cli-mode-name config-evpn-evi-nc-host;
            key mac;
            leaf mac {
              tailf:info "Host MAC address";
              tailf:cli-expose-key-name;
              type string {
                tailf:info "H.H.H;;Host MAC address";
              }
            }
            leaf ip-address {
              tailf:info "Host IP Address";
              tailf:cli-hide-in-submode;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;Host IP Address";
              }
            }
            container ipv4 {
              tailf:info "IPv4 Address Family";
              leaf address {
                tailf:info "IPv4 Address of a host";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP Address for the host";
                }
              }
            }
            leaf switch {
              tailf:info "Switch the host is connected to";
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;IP Address of the Switch the host is connected to";
              }
            }
            container gateway {
              tailf:info "Gateway for the host";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf ip-address {
                tailf:cli-drop-node-name;
                type union {
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Gateway IP Address for the host";
                  }
                  type inet:ipv4-prefix {
                    tailf:info "A.B.C.D/prefix;;Gateway IPv4 Address/prefix";
                  }
                }
              }
              leaf netmask {
                tailf:cli-drop-node-name;
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IP subnet mask";
                }
              }
            }
            leaf vlan {
              tailf:info "VLAN the host is on";
              type uint16 {
                tailf:info "<1-4094>;;VLAN the host is on";
                range "1..4094";
              }
            }
          }
        }
        list interface {
          tailf:info "Assign interface to EVPN";
          tailf:cli-mode-name config-evpn-ac;
          key name;
          leaf name {
            type ifname;
          }
          container ethernet-segment {
            tailf:info "Ethernet Segment configuration commands";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-evpn-ac-es;
            container identifier {
              tailf:info "Ethernet Segment identifier (ESI)";
              list type {
                tailf:info "ESI Type";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key esi;
                leaf esi {
                  type enumeration {
                    enum 0 {
                      tailf:info "Type 0 (arbitrary 9-octet ESI value)";
                    }
                  }
                }
                leaf value {
                  tailf:cli-drop-node-name;
                  type string {
                    tailf:info "<0-ff>.;;9-octet ESI value";
                  }
                }
              }
            }
            container bgp {
              tailf:info "Configure BGP";
              leaf route-target {
                tailf:info "Set ES-Import Route Target";
                type string {
                  tailf:info "H.H.H;;Route Target value (6-octet)";
                }
              }
            }
          }
        }
      }
      list interface {
        tailf:info "Assign interface to EVPN";
        tailf:cli-mode-name config-evpn-ac;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        container ethernet-segment {
          tailf:info "Ethernet Segment configuration commands";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-evpn-ac-es;
          container identifier {
            tailf:info "Ethernet Segment identifier (ESI)";
            list type {
              tailf:info "ESI Type";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key esi-type;
              leaf esi-type {
                type enumeration {
                  enum 0 {
                    tailf:info "Type 0 (arbitrary 9-octet ESI value)";
                  }
                }
              }
              leaf esi-identifier {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "<0-ff>.;;9-octet ESI value";
                }
              }
            }
          }
          container bgp {
            tailf:info "Configure BGP";
            leaf route-target {
              tailf:info "Set ES-Import Route Target";
              type string {
                tailf:info "H.H.H;;Route Target value (6-octet)";
              }
            }
          }
        }
      }
    }
    container l2vpn {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure l2vpn commands";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-l2vpn;
      tailf:cli-explicit-exit;
      presence true;
      leaf router-id {
        tailf:info "Global L2VPN Router ID";
        tailf:cli-full-command;
        type inet:ipv4-address {
          tailf:info "A.B.C.D;;IP Address";
        }
      }
      leaf nsr {
        tailf:info "Configure Non-Stop Routing";
        tailf:cli-full-command;
        type empty;
      }
      leaf pw-grouping {
        tailf:info "Enable PW-Grouping";
        tailf:cli-full-command;
        type empty;
      }
      container pw-status {
        tailf:info "Configure PW status";
        tailf:cli-delete-when-empty;
        presence true;
        leaf disable {
          tailf:info "Disable PW status";
          type empty;
        }
      }
      container autodiscovery {
        tailf:info "Configure global auto-discovery attributes";
        container bgp {
          tailf:info "auto discovery type bgp";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-l2vpn-ad;
          container signaling-protocol {
            tailf:info "Configure global signaling protocol attributes";
            container bgp {
              tailf:info "signaling protocol type bgp";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-l2vpn-ad-sig;
              container mtu {
                tailf:info mtu;
                container mismatch {
                  tailf:info "mtu mismatch";
                  leaf ignore {
                    tailf:info "Ignore MTU mismatch for auto-discovered PWs";
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
      container logging {
        tailf:info "Configure l2vpn logging commands";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-l2vpn-log;
        tailf:cli-delete-when-empty;
        presence true;
        leaf nsr {
          tailf:info "Enable Non-Stop Routing logging";
          tailf:cli-full-command;
          type empty;
        }
        container pseudowire {
          tailf:info "Enable pseudowire logging";
          tailf:cli-delete-when-empty;
          presence true;
          leaf status {
            type empty;
          }
        }
      }
      container load-balancing {
        tailf:info "Global L2VPN Load Balancing";
        leaf flow {
          tailf:info "Enable Flow based load balancing";
          type enumeration {
            enum src-dst-ip {
              tailf:info "Use source and destination IP addresses for hashing";
            }
            enum src-dst-mac {
              tailf:info "Use source and destination MAC addresses for hashing";
            }
          }
        }
      }
      leaf capability {
        tailf:info "Global capability mode";
        tailf:cli-full-command;
        type enumeration {
          enum high-mode {
            tailf:info "Compute global capability as the highest node capability";
          }
          enum single-mode {
            tailf:info "Disable global capability re-computation";
          }
        }
      }
      leaf ignore-mtu-mismatch {
        tailf:info "Ignore MTU mismatch for all L2VPN(cisco-support)";
        tailf:cli-full-command;
        type empty;
      }
      container redundancy {
        tailf:info Redundancy;
        tailf:cli-add-mode;
        tailf:cli-mode-name config-l2vpn-red;
        container iccp {
          tailf:info "Inter-Chassis Communication Protocol";
          list group {
            tailf:info "Group configuration";
            tailf:cli-mode-name config-l2vpn-red-grp;
            key id;
            leaf id {
              type uint32 {
                tailf:info "<1-4294967295>;;Enter group number";
              }
            }
            container multi-homing {
              tailf:info "ICCP-based service multi-homing";
              leaf node-id {
                tailf:info "Enter multi-homing node ID";
                type uint8 {
                  tailf:info "<0-254>;;Node ID";
                  range "0..254";
                }
              }
            }
            list interface {
              tailf:info "Interface name";
              tailf:cli-mode-name config-l2vpn-red-grp-intf;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }
              container primary {
                tailf:info "Primary VLAN configuration";
                leaf-list vlan {
                  tailf:info "Assign primary VLANs";
                  tailf:cli-range-list-syntax;
                  tailf:cli-replace-all;
                  type uint16 {
                    tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                    range "1..4094";
                  }
                }
              }
              container secondary {
                tailf:info "Secondary VLAN configuration";
                leaf-list vlan {
                  tailf:info "Assign secondary VLANs";
                  tailf:cli-range-list-syntax;
                  tailf:cli-replace-all;
                  type uint16 {
                    tailf:info "WORD;;List of VLAN IDs in the form of 1-3,5,8-11";
                    range "1..4094";
                  }
                }
              }
              container recovery {
                tailf:info "Failure recovery reversion delay timer.  Default is revertive after 180 seconds.";
                leaf delay {
                  tailf:info "Specify delay before recovery reversion after failure clears";
                  type uint16 {
                    tailf:info "<30-3600>;;input time in seconds";
                    range "30..3600";
                  }
                }
              }
            }
          }
        }
      }
      list pw-class {
        tailf:info "Pseudowire class template";
        tailf:cli-mode-name config-l2vpn-pwc;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Pseudowire-class name";
          }
        }
        container encapsulation {
          tailf:info "Pseudowire encapsulation";
          container l2tpv3 {
            tailf:cli-add-mode;
            tailf:cli-mode-name config-l2vpn-pwc-l2tpv3;
            leaf protocol {
              tailf:info "Set the dynamic pseudowire signaling protocol";
              type enumeration {
                enum l2tpv3 {
                  tailf:info "Set L2TPv3 as the signaling protocol for this pseudowire class";
                }
              }
            }
            leaf ttl {
              tailf:info "Set the Time To Live (TTL)";
              type uint8 {
                tailf:info "<1-255>;;TTL value";
                range "1..255";
              }
            }
          }
          container mpls {
            tailf:cli-add-mode;
            tailf:cli-mode-name config-l2vpn-pwc-mpls;
            leaf control-word {
              tailf:info "Enable Control word";
              type empty;
            }
            container protocol {
              tailf:info "Set the dynamic pseudowire signaling protocol";
              leaf ldp {
                tailf:info "Set LDP as the signaling protocol for this pseudowire class";
                type empty;
              }
            }
            container vccv {
              tailf:info "VCCV settings";
              container verification-type {
                tailf:info "Enable or disable VCCV verification type";
                leaf none {
                  tailf:info "No VCCV verification";
                  type empty;
                }
              }
            }
            container transport-mode {
              tailf:info "Remote transport mode";
              choice transport-mode-choice {
                leaf ethernet {
                  tailf:info "Ethernet port mode";
                  type empty;
                }
                container vlan {
                  tailf:info "Vlan tagged mode";
                  tailf:cli-delete-when-empty;
                  presence true;
                  leaf passthrough {
                    tailf:info "passthrough incoming tags";
                    type empty;
                  }
                }
              }
            }
            container preferred-path {
              tailf:info "Preferred path tunnel settings";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf interface {
                tailf:info "Use tunnel interface for preferred path";
                tailf:cli-incomplete-command;
                type enumeration {
                  enum tunnel-ip {
                    tailf:info "Specify IP tunnel interface name for preferred path";
                  }
                  enum tunnel-te {
                    tailf:info "Specify TE tunnel interface name for preferred path";
                  }
                  enum tunnel-tp {
                    tailf:info "Specify TP tunnel interface name for preferred path";
                  }
                }
              }
              leaf id {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-65535>;;Specify tunnel number for preferred path";
                }
              }
              leaf fallback {
                tailf:info "Fallback option for preferred path";
                type enumeration {
                  enum disable {
                    tailf:info "Disable fallback for preferred path";
                  }
                }
              }
            }
            container ipv4 {
              tailf:info "Set the local source IPv4 address";
              leaf source {
                tailf:info "The local source IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;The source address";
                }
              }
            }
            container redundancy {
              tailf:info "PW redundancy settings";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-l2vpn-pwc-mpls-pw;
              leaf one-way {
                tailf:info "Force one-way PW redundancy behavior in Redundancy Group";
                type empty;
              }
            }
          }
        }
      }
      container xconnect {
        tailf:info "Configure cross connect commands";
        list group {
          tailf:info "Specify the group the cross connects belong to";
          tailf:cli-mode-name config-l2vpn-xc;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name of the cross connects group";
            }
          }
          list mp2mp {
            tailf:info "Specify the MP2MP instance name";
            tailf:cli-mode-name config-l2vpn-xc-mp2mp;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the MP2MP instance";
              }
            }
            leaf vpn-id {
              tailf:info "VPN Identifier (VPN ID)";
              type uint32 {
                tailf:info "<1-4294967295>;;Value of the VPN ID";
                range "1..4294967295";
              }
            }
            leaf mtu {
              tailf:info "Set maximum transmission unit (payload) for this VPN MP2MP Instance";
              type uint32 {
                tailf:info "<64-4294967295>;;Value of the MTU";
                range "64..4294967295";
              }
            }
            leaf l2-encapsulation {
              tailf:info "Configure the L2 encapsulation for this L2VPN MP2MP Instance";
              type enumeration {
                enum ethernet {
                  tailf:info "Ethernet encapsulation";
                }
                enum vlan {
                  tailf:info "Ethernet VLAN encapsulation";
                }
              }
            }
            container control-word {
              tailf:info "Set control-word option for this VPN MP2MP Instance";
              leaf disable {
                tailf:info "Disable control-word";
                type empty;
              }
            }
            container autodiscovery {
              tailf:info "Enable auto-discovery in this MP2MP";
              container bgp {
                tailf:info "Enable BGP auto-discovery in this MP2MP";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-l2vpn-xc-mp2mp-ad;
                leaf rd {
                  tailf:info "route distinguisher";
                  type string {
                    tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                  }
                }
                uses route-target-import-export-grouping;
                container signaling-protocol {
                  tailf:info "Enable signaling protocol in this MP2MP";
                  container bgp {
                    tailf:info "Enable BGP signaling protocol this MP2MP";
                    tailf:cli-add-mode;
                    tailf:cli-mode-name config-l2vpn-xc-mp2mp-ad-sig;
                    list ce-id {
                      tailf:cli-mode-name config-l2vpn-xc-mp2mp-ad-sig-ce;
                      key id;
                      leaf id {
                        type uint16 {
                          tailf:info "<1-16384>;;Value of the local CE ID";
                          range "1..16384";
                        }
                      }
                      list interface {
                        tailf:info "Specify the attachment circuit";
                        tailf:cli-suppress-mode;
                        tailf:cli-delete-when-empty;
                        tailf:cli-incomplete-command;
                        key name;
                        leaf name {
                          type string {
                            tailf:info "WORD;;Interface Name";
                          }
                        }
                        leaf remote-ce-id {
                          tailf:info "Remote Customer Edge Identifier";
                          type uint16 {
                            tailf:info "<1-16384>;;Value of the remote CE ID";
                            range "1..16384";
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          list p2p {
            tailf:info "Configure point to point cross connect commands";
            tailf:cli-mode-name config-l2vpn-xc-p2p;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Name of the point to point cross connect";
              }
            }
            list interface {
              tailf:info "Specify the attachment circuit";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }
            }
            leaf monitor-session {
              tailf:info "Specify the monitor session";
              type string {
                tailf:info "WORD;;Name of the monitor session";
              }
              tailf:non-strict-leafref {
                path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:monitor-session/name" {
                  tailf:xpath-root 3;
                }
              }
            }
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name config-l2vpn-xc-p2p-pw;
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                }
              }
              leaf ip-version {
                tailf:cli-drop-node-name;
                tailf:cli-prefix-key;
                type enumeration {
                  enum ipv4 {
                    tailf:info "Specify IPv4 address or hostname";
                  }
                  enum ipv6 {
                    tailf:info "Specify IPv6 address or host name";
                  }
                }
              }
              container mpls {
                tailf:info "MPLS L2VPN PW command";
                container static {
                  tailf:info "MPLS L2VPN static settings";
                  container label {
                    tailf:info "MPLS L2VPN static labels";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf local {
                      tailf:info "Local pseudowire label";
                      tailf:cli-incomplete-command;
                      type uint32 {
                        tailf:info "<16-1048575>;;Local pseudowire label";
                        range "16..1048575";
                      }
                    }
                    leaf remote {
                      tailf:info "Remote pseudowire label";
                      type uint32 {
                        tailf:info "<16-1048575>;;Remote pseudowire label";
                        range "16..1048575";
                      }
                    }
                  }
                }
              }
              leaf pw-class {
                tailf:info "PW class template name to use for this XC";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }
              container tag-impose {
                tailf:info "tag impose mode";
                leaf vlan {
                  tailf:info "vlan tagged mode";
                  type uint16 {
                    tailf:info "<1-4094>;;vlan tagged mode";
                    range "1..4094";
                  }
                }
              }
              container l2tp {
                tailf:info "L2TP PW";
                container static {
                  tailf:info "L2TP PW static";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-l2vpn-xc-p2p-pw-l2tp;
                  container local {
                    tailf:info "L2TP PW static local";
                    container cookie {
                      tailf:info "L2TP PW static local cookie settings";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf size {
                        tailf:info "L2TP PW static local cookie size settings";
                        type enumeration {
                          enum 0 {
                            tailf:info "The cookie size is zero bytes";
                          }
                          enum 4 {
                            tailf:info "The cookie size is four bytes";
                          }
                          enum 8 {
                            tailf:info "The cookie size is eight bytes";
                          }
                        }
                      }
                      container value {
                        tailf:info "The value of the cookie";
                        tailf:cli-flatten-container;
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        when "../size != 0" {
                          tailf:xpath-root 3;
                        }
                        leaf value-1 {
                          tailf:cli-drop-node-name;
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                          }
                        }
                        leaf value-2 {
                          tailf:cli-drop-node-name;
                          when "../../size != 4" {
                            tailf:xpath-root 3;
                          }
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                          }
                        }
                      }
                    }
                  }
                  container remote {
                    tailf:info "L2TP PW static remote";
                    container cookie {
                      tailf:info "L2TP PW static remote cookie settings";
                      tailf:cli-flatten-container;
                      tailf:cli-compact-syntax;
                      tailf:cli-sequence-commands {
                        tailf:cli-reset-siblings;
                      }
                      leaf size {
                        tailf:info "L2TP PW static remote cookie size settings";
                        type enumeration {
                          enum 0 {
                            tailf:info "The cookie size is zero bytes";
                          }
                          enum 4 {
                            tailf:info "The cookie size is four bytes";
                          }
                          enum 8 {
                            tailf:info "The cookie size is eight bytes";
                          }
                        }
                      }
                      container value {
                        tailf:info "The value of the cookie";
                        tailf:cli-flatten-container;
                        tailf:cli-compact-syntax;
                        tailf:cli-sequence-commands;
                        when "../size != 0" {
                          tailf:xpath-root 3;
                        }
                        leaf value-1 {
                          tailf:cli-drop-node-name;
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Lower 4 bytes value";
                          }
                        }
                        leaf value-2 {
                          tailf:cli-drop-node-name;
                          when "../../size != 4" {
                            tailf:xpath-root 3;
                          }
                          type string {
                            tailf:info "<0x0-0xffffffff>;;Higher 4 bytes value";
                          }
                        }
                      }
                    }
                  }
                }
              }
              leaf source {
                tailf:info "Source address of PW";
                type inet:ipv6-address {
                  tailf:info "X:X::X;;Source IPv6 address of PW";
                }
              }
              container backup {
                tailf:info "Backup pseudowire for the cross connect";
                list neighbor {
                  tailf:info "Specify the peer to cross connect";
                  tailf:cli-mode-name config-l2vpn-xc-p2p-pw-backup;
                  key "address pw-id";
                  leaf address {
                    type string {
                      tailf:info "IP address of the peer";
                    }
                  }
                  leaf pw-id {
                    tailf:info "Specify the pseudowire id";
                    tailf:cli-expose-key-name;
                    type uint32 {
                      tailf:info "<1-4294967295>;;Pseudowire ID";
                    }
                  }
                  leaf pw-class {
                    tailf:info "PW class template name to use for this XC backup";
                    tailf:cli-full-command;
                    type string {
                      tailf:info "WORD;;Pseudowire-class name";
                    }
                  }
                }
              }
            }
            leaf description {
              tailf:info "Description for cross connect";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;Cross connect description string";
              }
            }
          }
        }
      }
      container bridge {
        tailf:info "Configure bridge commands";
        list group {
          tailf:info "Specify the group the bridge belongs to";
          tailf:cli-mode-name config-l2vpn-bg;
          key group-name;
          leaf group-name {
            tailf:info "Name of the bridge group";
            type string {
              tailf:info "WORD;;Name of the bridge group";
            }
          }
          list bridge-domain {
            tailf:info "Configure bridge domain";
            tailf:cli-mode-name config-l2vpn-bg-bd;
            key bridge-domain-name;
            leaf bridge-domain-name {
              tailf:info "Name of the bridge domain";
              type string {
                tailf:info "WORD;;Name of the bridge domain";
              }
            }
            list evi {
              tailf:info "Ethernet VPN identifier";
              tailf:cli-mode-name config-l2vpn-bg-bd-evi;
              max-elements 1;
              key id;
              leaf id {
                type uint16 {
                  tailf:info "<1-65534>;;Ethernet VPN ID to set";
                  range "1..65534";
                }
              }
            }
            uses storm-control-grouping;
            list interface {
              tailf:info "Assign interface to bridge domain";
              tailf:cli-mode-name config-l2vpn-bg-bd-ac;
              key name;
              leaf name {
                tailf:info "Interface Name";
                type string {
                  tailf:info "WORD;;Interface Name";
                }
              }
              container mac {
                tailf:info "MAC configuration commands";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-l2vpn-bg-bd-ac-mac;
                uses l2vpn-bridge-domain-mac-grouping;
              }
              uses storm-control-grouping;
              container igmp {
                tailf:info "IGMP protocol";
                container snooping {
                  tailf:info "Set the snooping profile";
                  leaf profile {
                    tailf:info "Attach a IGMP profile";
                    type string {
                      tailf:info "WORD;;IGMP Snooping profile name";
                    }
                  }
                }
              }
              container split-horizon {
                tailf:info "Configure split horizon group";
                leaf group {
                  tailf:info "Configure split horizon group";
                  type empty;
                }
              }
            }
            list neighbor {
              tailf:info "Specify the peer to cross connect";
              tailf:cli-mode-name config-l2vpn-bg-bd-pw;
              key "address pw-id";
              leaf address {
                type string {
                  tailf:info "IP address of the peer";
                }
              }
              leaf pw-id {
                tailf:info "Specify the pseudowire id";
                tailf:cli-expose-key-name;
                type uint32 {
                  tailf:info "<1-4294967295>;;Pseudowire ID";
                  range "1..4294967295";
                }
              }
              container mpls {
                tailf:info "MPLS L2VPN PW command";
                container static {
                  tailf:info "MPLS L2VPN static settings";
                  container label {
                    tailf:info "MPLS L2VPN static labels";
                    tailf:cli-compact-syntax;
                    tailf:cli-sequence-commands {
                      tailf:cli-reset-siblings;
                    }
                    leaf local {
                      tailf:info "Local pseudowire label";
                      tailf:cli-incomplete-command;
                      type uint32 {
                        tailf:info "<16-1048575>;;Local pseudowire label";
                        range "16..1048575";
                      }
                    }
                    leaf remote {
                      tailf:info "Remote pseudowire label";
                      type uint32 {
                        tailf:info "<16-1048575>;;Remote pseudowire label";
                        range "16..1048575";
                      }
                    }
                  }
                }
              }
              leaf pw-class {
                tailf:info "PW class template name to use for this pseudowire";
                tailf:cli-full-command;
                type string {
                  tailf:info "WORD;;Pseudowire-class name";
                }
              }
              uses storm-control-grouping;
              container split-horizon {
                tailf:info "Configure split horizon group";
                leaf group {
                  tailf:info "Configure split horizon group";
                  type empty;
                }
              }
            }
            container mac {
              tailf:info "MAC configuration commands";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-l2vpn-bg-bd-mac;
              container aging {
                tailf:info "MAC-Aging configuration commands";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-l2vpn-bg-bd-mac-aging;
                leaf time {
                  tailf:info "Mac aging";
                  type uint16 {
                    tailf:info "<300-30000>;;MAC address aging time in seconds";
                    range "300..3000";
                  }
                }
              }
              uses l2vpn-bridge-domain-mac-grouping;
              container withdraw {
                tailf:info "MAC withdraw";
                choice withdraw-choice {
                  leaf state-down {
                    tailf:info "MAC withdraw sent on bridge port down";
                    type empty;
                  }
                  leaf optimize {
                    tailf:info "Optimized LDP MAC withdraw (when port goes down)";
                    type empty;
                  }
                  leaf disable {
                    tailf:info "Disable MAC withdraw";
                    type empty;
                  }
                }
              }
            }
            leaf mtu {
              tailf:info "Maximum transmission unit (payload) for this Bridge Domain";
              type uint16 {
                tailf:info "<46-65535>;;Maximum transmission unit size (payload) in bytes";
                range "46..65535";
              }
            }
            container flooding {
              tailf:info "Traffic flooding";
              leaf disable {
                tailf:info "Disable flooding";
                type empty;
              }
              container unknown-unicast {
                tailf:info "Traffic flooding unknown unicast";
                leaf disable {
                  tailf:info "Disable Unknown Unicast flooding";
                  type empty;
                }
              }
            }
            container igmp {
              tailf:info "IGMP protocol";
              container snooping {
                tailf:info "Set the snooping profile";
                leaf profile {
                  tailf:info "Attach an IGMP profile";
                  type string {
                    tailf:info "WORD;;IGMP Snooping profile name";
                  }
                }
              }
            }
            container routed {
              tailf:info "Bridge domain L3 interface";
              list interface {
                tailf:info "Assign interface to bridge domain";
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                key name;
                leaf name {
                  type string {
                    tailf:info "BVI;;Bridge-Group Virtual Interface";
                  }
                }
              }
            }
            container member {
              tailf:info "Bridge domain member";
              list vni {
                tailf:info "Assign VxLAN Network Identifier to bridge domain";
                tailf:cli-mode-name config-l2vpn-bg-bd-vni;
                max-elements 1;
                key id;
                leaf id {
                  type uint32 {
                    tailf:info "<1-16777215>;;Specify VxLAN Network Identifier value";
                    range "1..16777215";
                  }
                }
              }
            }
            list vfi {
              tailf:info "Specify the virtual forwarding interface name";
              tailf:cli-mode-name config-l2vpn-bg-bd-vfi;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Name of the Virtual Forwarding Interface";
                }
              }
              leaf vpn-id {
                tailf:info "VPN Identifier (VPN ID)";
                type uint32 {
                  tailf:info "<1-4294967295>;;Value of the VPN ID";
                  range "1..4294967295";
                }
              }
              container autodiscovery {
                tailf:info "Enable auto-discovery in this VFI";
                container bgp {
                  tailf:info "Enable BGP auto-discovery in this VFI";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-l2vpn-bg-bd-vfi-ad;
                  leaf rd {
                    tailf:info "route distinguisher";
                    tailf:cli-full-command;
                    type string {
                      tailf:info "WORD;;AS-number, IPv4 address:index or 'auto'";
                    }
                  }
                  uses route-target-import-export-grouping;
                  container signaling-protocol {
                    tailf:info "Enable signaling protocol for this VFI";
                    container bgp {
                      tailf:info "Enable BGP signaling protocol for this VFI";
                      tailf:cli-add-mode;
                      tailf:cli-mode-name config-l2vpn-bg-bd-vfi-ad-sig;
                      presence true;
                      leaf ve-id {
                        tailf:info "Local Virtual Edge Identifier (VE ID)";
                        type uint16 {
                          tailf:info "<1-16384>;;Value of the local VE ID";
                          range "1..16384";
                        }
                      }
                      leaf ve-range {
                        tailf:info "Local Virtual Edge Block Configurable Range";
                        type uint16 {
                          tailf:info "<11-100>;;Value of the VE Range";
                          range "11..100";
                        }
                      }
                    }
                    container ldp {
                      tailf:info "Enable LDP signaling protocol for this VFI";
                      tailf:cli-add-mode;
                      tailf:cli-mode-name config-l2vpn-bg-bd-vfi-ad-sig;
                      presence true;
                      leaf vpls-id {
                        tailf:info "VPLS ID";
                        type union {
                          type string {
                            tailf:info "<1-65535>;;Two Byte AS number";
                          }
                          type inet:ipv4-address {
                            tailf:info "A.B.C.D;;IP address";
                          }
                        }
                      }
                    }
                  }
                }
              }
              list neighbor {
                tailf:info "Specify the peer to cross connect";
                tailf:cli-mode-name config-l2vpn-bg-bd-vfi-pw;
                key "address pw-id";
                leaf address {
                  type string {
                    tailf:info "IP address of the peer";
                  }
                }
                leaf pw-id {
                  tailf:info "Specify the pseudowire id";
                  tailf:cli-expose-key-name;
                  type uint32 {
                    tailf:info "<1-4294967295>;;Pseudowire ID";
                  }
                }
                leaf pw-class {
                  tailf:info "PW class template name to use for this pseudowire";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;Pseudowire-class name";
                  }
                }
              }
            }
            container evpn {
              tailf:info "Specify the Ethernet VPN interface name";
              leaf evi {
                tailf:info "Ethernet VPN identifier";
                type uint16 {
                  tailf:info "<1-65534>;;Ethernet VPN ID to set";
                  range "1..65534";
                }
              }
            }
            container pbb {
              tailf:info "Configure Provider Backbone Bridge";
              list edge {
                tailf:info "PBB edge bridge domain";
                tailf:cli-mode-name config-l2vpn-bg-bd-pbb-edge;
                key "i-sid core-bridge";
                leaf i-sid {
                  tailf:cli-expose-key-name;
                  tailf:info "Configure Service Instance Identifier";
                  type uint32 {
                    tailf:info "<256-16777214>;;Service Instance ID";
                    range "256..16777214";
                  }
                }
                leaf core-bridge {
                  tailf:cli-expose-key-name;
                  tailf:info "Specifiy PBB core bridge domain to associate with";
                  type string {
                    tailf:info "WORD;;Name of the PBB core bridge domain";
                  }
                }
                leaf unknown-unicast-bmac {
                  tailf:info "Unknown Unicast backbone MAC address";
                  type string {
                    tailf:info "H.H.H;;Unknown Unicast backbone MAC address";
                  }
                }
              }
              container core {
                tailf:info "PBB core bridge domain";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-l2vpn-bg-bd-pbb-core;
                presence true;
                container evpn {
                  tailf:info "Specify the Ethernet VPN interface name";
                  leaf evi {
                    tailf:info "Ethernet VPN identifier";
                    type uint16 {
                      tailf:info "<1-65534>;;Ethernet VPN ID to set";
                      range "1..65534";
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container extcommunity-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define an extended community set";
      list rt {
        tailf:info "BGP Route Target (RT) extended community";
        tailf:cli-mode-name config-ext;
        tailf:cli-exit-command end-set;
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Route Target type extcommunity set name";
          }
        }
        uses set-list-grouping;
      }
      list soo {
        tailf:info "BGP Site of Origin (SoO) extended community";
        tailf:cli-mode-name config-ext;
        tailf:cli-exit-command end-set;
        tailf:cli-full-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Site of Origin type extcommunity set name";
          }
        }
        uses set-list-grouping;
      }
    }
    list rd-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a BGP VPN route-distinguisher set";
      tailf:cli-mode-name config-rd;
      tailf:cli-exit-command end-set;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Route Distinguisher set name";
        }
      }
      uses set-list-grouping;
    }
    list prefix-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a prefix set";
      tailf:cli-mode-name config-pfx;
      tailf:cli-exit-command end-set;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Prefix setname";
        }
      }
      uses set-list-grouping;
    }
    list as-path-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define an AS-path set";
      tailf:cli-mode-name config-as;
      tailf:cli-exit-command end-set;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;AS-path set name";
        }
      }
      uses set-list-grouping;
      leaf ios-regex {
        tailf:info "Traditional IOS style regular expression";
        tailf:cli-multi-value;
        type string {
          tailf:info "regex;;Enter an AS-path regular expression enclosed in single quotes";
        }
      }
    }
    list community-set {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a community set";
      tailf:cli-mode-name config-comm;
      tailf:cli-exit-command end-set;
      tailf:cli-full-command;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Community set name";
        }
      }
      uses set-list-grouping;
    }
    container rpl {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "RPL commands";
      leaf editor {
        tailf:info "Set default RPL editor";
        type enumeration {
          enum emacs {
            tailf:info "Set default RPL editor to Emacs";
          }
          enum nano {
            tailf:info "Set default RPL editor to nano";
          }
          enum vim {
            tailf:info "Set default RPL editor to Vim";
          }
        }
      }
    }
    list route-policy {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Define a route policy";
      tailf:cli-mode-name config-rpl;
      tailf:cli-delete-when-empty;
      tailf:cli-exit-command end-policy;
      tailf:cli-full-command;
      tailf:cli-reset-container;
      key name;
      leaf name {
        tailf:cli-multi-word-key;
        type string {
          tailf:info "WORD;;Route Policy name";
        }
      }
      leaf value {
        tailf:cli-drop-node-name;
        type string {
          tailf:info "WORD;;route-policy contents as a single quoted string.";
        }
      }
    }
    list generic-interface-list {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../ncs:module) or ../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Interface list";
      tailf:cli-mode-name config-gen-if-list;
      key name;
      leaf name {
        type string {
          tailf:info "WORD;;Interface-list name";
        }
      }
      list interface {
        tailf:info "Specify an interface";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type ifname;
        }
      }
    }
    container ospf {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global OSPF configuration commands";
      tailf:cli-explicit-exit;
      leaf name-lookup {
        tailf:info "Display OSPF router ids as DNS names";
        type empty;
      }
    }
    container router-convergence {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure Router Convergence Monitoring";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-rcmd;
      tailf:cli-explicit-exit;
      list collect-diagnostics {
        tailf:info "Collect diagnostics on specified node";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Specified location";
          }
        }
      }
    }
    container router {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable a routing process";
      tailf:cli-explicit-exit;
      container static {
        tailf:info "Static route configuration subcommands";
        tailf:cli-add-mode;
        uses router-static-grouping;
        list vrf {
          tailf:info "VRF Static route configuration subcommands";
          tailf:cli-mode-name config-static-vrf;
          key name;
          leaf name {
            tailf:info "VRF name";
            type string {
              tailf:info "WORD;;VRF name";
            }
          }
          uses router-static-grouping;
        }
      }
      container igmp {
        tailf:info "IPv4 Address Family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-igmp;
        presence true;
        uses router-igmp-grouping;
        list vrf {
          tailf:info "VRF configs";
          tailf:cli-mode-name config-igmp-vrf;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter VRF name";
            }
          }
          uses router-igmp-grouping;
        }
      }
      container isis {
        tailf:info "ISO IS-IS";
        tailf:cli-incomplete-command;
        list tag {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-isis;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;ISO routing area tag";
            }
          }
          container set-overload-bit {
            tailf:info "Signal other routers not to use us in SPF";
            tailf:cli-delete-when-empty;
            presence true;
            leaf on-startup {
              tailf:info "Set overload-bit temporarily after reboot";
              type union {
                type uint32 {
                  tailf:info "<5-86400>;;Time in seconds to advertise ourself as overloaded after reboot";
                  range "5..86400";
                }
                type enumeration {
                  enum wait-for-bgp {
                    tailf:info "Let BGP decide when to unset the overload bit";
                  }
                }
              }
            }
            list level-list {
              tailf:info "Set overload-bit for one level only";
              tailf:cli-drop-node-name;
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-sequence-commands;
              key level;
              leaf level {
                tailf:cli-expose-key-name;
                type uint8 {
                  tailf:info "<1-2>;;Level";
                  range "1..2";
                }
              }
              leaf on-startup {
                tailf:info "Set overload-bit temporarily after reboot";
                tailf:cli-prefix-key;
                type union {
                  type uint32 {
                    tailf:info "<5-86400>;;Time in seconds to advertise ourself as overloaded after reboot";
                    range "5..86400";
                  }
                  type enumeration {
                    enum wait-for-bgp {
                      tailf:info "Let BGP decide when to unset the overload bit";
                    }
                  }
                }
              }
              container advertise {
                tailf:info "If overload-bit set advertise the following types of IP prefixes";
                tailf:cli-compact-syntax;
                leaf external {
                  tailf:info "If overload-bit set advertise IP prefixes learned from other protocols";
                  type empty;
                }
                leaf interlevel {
                  tailf:info "If overload-bit set advertise IP prefixes learned from another ISIS level";
                  type empty;
                }
              }
            }
            container suppress {
              tailf:info "If overload-bit set, suppress the following types of IP prefixes";
              tailf:cli-compact-syntax;
              leaf external {
                tailf:info "If overload-bit set, don't advertise IP prefixes learned from other protocols";
                type empty;
              }
              leaf interlevel {
                tailf:info "If overload-bit set, don't advertise IP prefixes learned from another ISIS level";
                type empty;
              }
            }
          }
          leaf is-type {
            tailf:info "IS Level for this routing process (OSI only)";
            type enumeration {
              enum level-1 {
                tailf:info "Act as a station router only";
              }
              enum level-1-2 {
                tailf:info "Act as both a station router and an area router";
              }
              enum level-2-only {
                tailf:info "Act as an area router only";
              }
            }
          }
          list net {
            tailf:info "A Network Entity Title for this process (OSI only)";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            key id;
            leaf id {
              type string {
                tailf:info "XX.XXXX. ... .XXX.XX;;Network entity title (NET)";
              }
            }
          }
          container nsf {
            tailf:info "Non-stop forwarding";
            choice nsf-choice {
              container advertise {
                tailf:info "Send information to neighbors";
                leaf holdtime {
                  tailf:info "Adjust holdtime advertised in IIH when RR set";
                  type uint16 {
                    tailf:info "<5-3600>;;Seconds";
                    range "5..3600";
                  }
                }
              }
              leaf cisco {
                tailf:info "Checkpoint method";
                type empty;
              }
              leaf ietf {
                tailf:info "IETF method";
                type empty;
              }
              container interface {
                tailf:info "Interface properties";
                leaf wait {
                  tailf:info "Maximum time to wait for interface up";
                  type uint8 {
                    tailf:info "<1-60>;;Seconds";
                    range "1..60";
                  }
                }
              }
              leaf interval {
                tailf:info "Minimum required stable interval between restarts";
                type uint16 {
                  tailf:info "<0-1440>;;Minutes";
                  range "0..1440";
                }
              }
              container t3 {
                tailf:info "Time to set overload-bit if LSPDB synchronization not completed (T3 expiration)";
                choice t3-choice {
                  leaf adjacency {
                    tailf:info "Use minimum advertised adjacency holdtime for NSF T3 timeout";
                    type empty;
                  }
                  leaf manual {
                    tailf:info "Manually configure NSF T3 timeout";
                    type uint16 {
                      tailf:info "<5-3600>;;Seconds";
                      range "5..3600";
                    }
                  }
                }
              }
            }
            leaf lifetime {
              tailf:info "Maximum route lifetime following restart (seconds)";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<5-300>;;second";
                range "5..300";
              }
            }
            leaf interface-timer {
              tailf:info "Timer used to wait for a restart ACK (seconds)";
              tailf:cli-full-command;
              type uint8 {
                tailf:info "<1-20>;;seconds";
                range "1..20";
              }
            }
          }
          leaf nsr {
            tailf:info "Enable NSR";
            tailf:cli-full-command;
            type empty;
          }
          container distribute {
            tailf:info "Distribute routing information to external services";
            container bgp-ls {
              tailf:info "Set external routing service to BGP-LS";
              tailf:cli-compact-syntax;
              leaf level {
                tailf:info "Set distribution for one level only";
                type uint8 {
                  tailf:info "<1-2>;;Level";
                  range "1..2";
                }
              }
              leaf throttle {
                tailf:info "Set throttle update in seconds";
                type uint8 {
                  tailf:info "<5-20>;;Seconds";
                  range "5..20";
                }
              }
            }
          }
          container log {
            tailf:info "Log changes in adjacency state";
            container adjacency {
              tailf:info "Enable logging of adjacency state";
              leaf changes {
                tailf:info "Enable logging adjacency state changes";
                type empty;
              }
            }
            container pdu {
              tailf:info "Enable PDU logging";
              leaf drops {
                tailf:info "Enable logging PDU drops";
                type empty;
              }
            }
          }
          container lsp-gen-interval {
            tailf:info "System and Pseudonode LSP generation scheduling parameters";
            tailf:cli-compact-syntax;
            leaf maximum-wait {
              tailf:info "Maximum delay before generating an LSP";
              type uint32 {
                tailf:info "<0-120000>;;Delay in milliseconds";
                range "0..120000";
              }
            }
            leaf initial-wait {
              tailf:info "Initial delay before generating an LSP";
              type uint32 {
                tailf:info "<0-120000>;;Delay in milliseconds";
                range "0..120000";
              }
            }
            leaf secondary-wait {
              tailf:info "Secondary delay before generating an LSP";
              type uint32 {
                tailf:info "<0-120000>;;Delay in milliseconds";
                range "0..120000";
              }
            }
          }
          leaf lsp-check-interval {
            tailf:info "Set LSP checksum check interval(cisco-support)";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<10-65535>;;LSP checksum check interval time in seconds";
              range "10..65535";
            }
          }
          leaf lsp-refresh-interval {
            tailf:info "Set LSP refresh interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<1-65535>;;LSP refresh time in seconds";
              range "1..65535";
            }
          }
          leaf lsp-mtu {
            tailf:info "Set maximum LSP size";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<128-4352>;;Max LSP size in bytes";
              range "128..4352";
            }
          }
          container lsp-password {
            tailf:info "Configure the area password";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            leaf auth-type {
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum hmac-md5 {
                  tailf:info "Use HMAC-MD5 authentication";
                }
                enum text {
                  tailf:info "Use cleartext password authentication";
                }
              }
            }
            leaf enc-type {
              tailf:info "The encryption type";
              tailf:cli-drop-node-name;
              tailf:cli-optional-in-sequence;
              type enumeration {
                enum clear {
                  tailf:info "Specifies an unencrypted password will follow";
                }
                enum encrypted {
                  tailf:info "Specifies an encrypted password will follow";
                }
              }
            }
            choice password-choice {
              leaf password {
                tailf:info "The password";
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;The unencrypted (clear text) LSP/SNP password";
                }
              }
              leaf keychain {
                tailf:info "Specifies a Key Chain name will follow";
                type string {
                  tailf:info "WORD;;The Key Chain name";
                }
                tailf:non-strict-leafref {
                  path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
            }
            leaf level {
              tailf:cli-break-sequence-commands;
              tailf:info "Set lsp-password for one level only";
              type uint8 {
                tailf:info "<1-2>;;Set lsp-password for LSPs/SNPs at this level only";
                range "1..2";
              }
            }
            leaf send-only {
              tailf:info "Authenticate outgoing LSPs/SNPs only";
              type empty;
            }
            leaf snp {
              tailf:info "Specify SNP packets authentication mode";
              type empty;
            }
          }
          leaf max-lsp-lifetime {
            tailf:info "Set maximum LSP lifetime";
            type uint16 {
              tailf:info "<1-65535>;;Maximum LSP lifetime in seconds";
              range "1..65535";
            }
          }
          container address-family {
            tailf:info "Enter the IS-IS address-family configuration submode";
            container ipv4 {
              tailf:info "IPV4 address family";
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name config-isis-af;
                presence true;
                uses router-isis-common-grouping;
                uses router-isis-common-af-grouping;
                uses router-isis-af-grouping;
              }
            }
            container ipv6 {
              tailf:info "IPV6 address family";
              container unicast {
                tailf:cli-add-mode;
                tailf:cli-mode-name config-isis-af;
                presence true;
                uses router-isis-common-grouping;
                uses router-isis-common-af-grouping;
                uses router-isis-af-grouping;
              }
            }
          }
          list interface {
            tailf:info "Enter the IS-IS interface configuration submode";
            tailf:cli-mode-name config-isis-if;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface Name";
              }
            }
            leaf interface-type {
              tailf:cli-drop-node-name;
              tailf:cli-full-command;
              type enumeration {
                enum active;
                enum passive {
                  tailf:info "Do not establish adjacencies over this interface";
                }
                enum suppressed {
                  tailf:info "Do not advertise connected prefixes of this interface";
                }
                enum shutdown {
                  tailf:info "Shutdown IS-IS on this interface";
                }
              }
            }
            leaf circuit-type {
              tailf:info "Configure circuit type for interface";
              type enumeration {
                enum level-1 {
                  tailf:info "Form level-1 adjacencies only";
                }
                enum level-1-2 {
                  tailf:info "Form level-1 and level-2 adjacencies";
                }
                enum level-2-only {
                  tailf:info "Form level-2 adjacencies only";
                }
              }
            }
            container bfd {
              tailf:info "Configure BFD parameters";
              leaf fast-detect {
                tailf:info "Enable Fast detection";
                tailf:cli-full-command;
                type enumeration {
                  enum ipv4 {
                    tailf:info "Address Family";
                  }
                  enum ipv6 {
                    tailf:info "Address Family";
                  }
                  enum disable;
                }
              }
              leaf minimum-interval {
                tailf:info "Hello interval";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<3-30000>;;hello interval in milli-seconds";
                }
              }
              leaf multiplier {
                tailf:info "Detect multiplier";
                tailf:cli-full-command;
                type uint16 {
                  tailf:info "<2-50>;;Detect multiplier";
                }
              }
            }
            leaf priority {
              tailf:info "Set priority for Designated Router election";
              type uint8 {
                tailf:info "<0-127>;;Priority value";
                range "0..127";
              }
            }
            leaf point-to-point {
              tailf:info "Treat active LAN interface as point-to-point";
              tailf:cli-full-command;
              type empty;
            }
            container lsp-interval {
              tailf:info "Set LSP transmission interval";
              leaf milliseconds {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                type uint32 {
                  tailf:info "<1-4294967295>;;LSP transmission interval (milliseconds)";
                  range "1..4294967295";
                }
              }
            }
            leaf hello-interval {
              tailf:info "Set Hello interval in seconds";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Hello interval value";
              }
            }
            leaf hello-padding {
              tailf:info "Add padding to IS-IS hello packets";
              tailf:cli-full-command;
              type enumeration {
                enum disable {
                  tailf:info "Disable hello-padding";
                }
                enum enable {
                  tailf:info "Enable hello-padding during adjacency formation only";
                }
                enum sometimes {
                  tailf:info "Enable hello-padding during adjacency formation only";
                }
              }
            }
            container hello-password {
              tailf:info "Configure the IIH password";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-all-siblings;
              }
              tailf:cli-incomplete-command;
              choice authentication-choice {
                leaf keychain {
                  tailf:info "Specifies a Key Chain name will follow";
                  tailf:cli-optional-in-sequence;
                  tailf:cli-disallow-value keychain|accept|hmac-md5|text|clear|encrypted;
                  type string {
                    tailf:info "WORD;;The Key Chain name";
                  }
                }
                leaf accept {
                  tailf:info "Use password for incoming authentication only";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
                leaf hmac-md5 {
                  tailf:info "Use HMAC-MD5 authentication";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
                leaf text {
                  tailf:info "Use cleartext password authentication";
                  tailf:cli-optional-in-sequence;
                  type empty;
                }
              }
              choice password-choice {
                leaf clear {
                  when "not(../keychain)" {
                    tailf:xpath-root 3;
                    tailf:dependency "../keychain";
                  }
                  tailf:info "Specifies an unencrypted password will follow";
                  type string {
                    tailf:info "WORD;;The unencrypted (clear text) hello password";
                  }
                }
                leaf encrypted {
                  when "not(../keychain)" {
                    tailf:xpath-root 3;
                    tailf:dependency "../keychain";
                  }
                  tailf:info "Specifies an encrypted password will follow";
                  type string {
                    tailf:info "WORD;;The encrypted hello password";
                  }
                }
                leaf password {
                  when "not(../keychain)" {
                    tailf:xpath-root 3;
                    tailf:dependency "../keychain";
                  }
                  tailf:cli-drop-node-name;
                  tailf:cli-disallow-value keychain|accept|hmac-md5|text|clear|encrypted|level|send-only;
                  type string {
                    tailf:info "WORD;;The unencrypted (clear text) hello password";
                  }
                }
              }
              leaf level {
                tailf:info "Set hello-password for one level only";
                tailf:cli-optional-in-sequence;
                type uint8 {
                  tailf:info "<1-2>;;Set hello-password for IIHs at this level only";
                  range "1..2";
                }
              }
              leaf send-only {
                tailf:info "Do not require authentication of incoming IIHs";
                type empty;
              }
            }
            container link-down {
              tailf:info "Configure interface down event parameters";
              leaf fast-detect {
                tailf:info "Enable high priority detection";
                type empty;
              }
            }
            container address-family {
              tailf:info "Enter the IS-IS interface address-family configuration submode";
              container ipv4 {
                tailf:info "IPV4 address family";
                container unicast {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-isis-if-af;
                  presence true;
                  uses router-isis-common-af-grouping;
                  uses router-isis-if-af-grouping;
                }
              }
              container ipv6 {
                tailf:info "IPV6 address family";
                container unicast {
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-isis-if-af;
                  presence true;
                  uses router-isis-common-af-grouping;
                  uses router-isis-if-af-grouping;
                }
              }
            }
          }
          container authentication {
            tailf:info "ISIS authentication for LSPs";
            container key-chain {
              tailf:info "Authentication key-chain";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf ref {
                tailf:cli-drop-node-name;
                type string;
                tailf:non-strict-leafref {
                  path "/ncs:devices/ncs:device/ncs:config/cisco-ios-xr:key/chain/name" {
                    tailf:xpath-root 3;
                  }
                }
              }
              leaf level {
                tailf:cli-drop-node-name;
                type enumeration {
                  enum level-1 {
                    tailf:info "ISIS authentication for level-1";
                  }
                  enum level-2 {
                    tailf:info "ISIS authentication for level-2";
                  }
                }
              }
            }
            container mode {
              tailf:info "Authentication mode";
              choice mode-choice {
                container md5 {
                  tailf:info "Keyed message digest";
                  presence true;
                  leaf level {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum level-1 {
                        tailf:info "ISIS authentication for level-1";
                      }
                      enum level-2 {
                        tailf:info "ISIS authentication for level-2";
                      }
                    }
                  }
                }
                container text {
                  tailf:info "Clear text password";
                  presence true;
                  leaf level {
                    tailf:cli-drop-node-name;
                    type enumeration {
                      enum level-1 {
                        tailf:info "ISIS authentication for level-1";
                      }
                      enum level-2 {
                        tailf:info "ISIS authentication for level-2";
                      }
                    }
                  }
                }
              }
            }
          }
          container bfd {
            tailf:info "BFD configuration commands";
            leaf all-interfaces {
              tailf:info "Enable BFD on all interfaces";
              type empty;
            }
            leaf check-ctrl-plane-failure {
              tailf:info "BFD check control plane failure";
              type empty;
            }
          }
          container mpls {
            tailf:info "Configure MPLS routing protocol parameters";
            leaf ldp {
              tailf:info "routing protocol commands for MPLS LDP";
              type enumeration {
                enum sync {
                  tailf:info "Configure LDP-IGP Synchronization";
                }
              }
            }
            container traffic-eng {
              tailf:info "routing protocol commands for MPLS Traffic Engineering";
              leaf level-1 {
                tailf:info "Run MPLS TE on IS-IS level 1 only";
                type empty;
              }
              leaf level-2 {
                tailf:info "Run MPLS TE on IS-IS level 2 only";
                type empty;
              }
              leaf multicast-intact {
                tailf:info "MPLS TE and PIM interaction";
                type empty;
              }
              leaf router-id {
                tailf:info "Traffic Engineering stable IP address for system";
                type empty;
              }
              leaf scanner {
                tailf:info "Timer parameters for TE database";
                type empty;
              }
            }
          }
          uses router-isis-common-grouping;
        }
      }
      list ospf {
        tailf:info "OSPF configuration subcommands";
        tailf:cli-mode-name config-ospf;
        key name;
        leaf name {
          tailf:info "Name for this OSPF process";
          type string {
            tailf:info "WORD;;Name for this OSPF process";
          }
        }
        uses router-ospf-authentication-grouping;
        uses router-ospf-grouping;
        container mpls {
          tailf:info "Configure MPLS routing protocol parameters";
          container traffic-eng {
            tailf:info "Routing protocol commands for MPLS Traffic Engineering";
            container router-id {
              tailf:info "Traffic Engineering stable IP address for system";
              uses interface-name-grouping;
            }
            leaf multicast-intact {
              tailf:info "Publish multicast-intact paths to RIB";
              tailf:cli-full-command;
              type empty;
            }
          }
          container ldp {
            tailf:info "Configure LDP parameters";
            leaf sync {
              tailf:info "Enable LDP IGP synchronization";
              tailf:cli-full-command;
              type empty;
            }
            leaf auto-config {
              tailf:info "Enable LDP IGP interface auto-configuration";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        list vrf {
          tailf:info "Enter the OSPF vrf configuration submode";
          tailf:cli-mode-name config-ospf-vrf;
          key name;
          leaf name {
            tailf:info "Name for this OSPF vrf";
            type string {
              tailf:info "WORD;;Name for this OSPF vrf";
            }
          }
          uses router-ospf-grouping;
        }
      }
      list ospfv3 {
        tailf:info "IPv6 Open Shortest Path First protocol (OSPFv3)";
        tailf:cli-mode-name config-ospfv3;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Name for this OSPFv3 process";
          }
        }
        uses router-ospfv3-grouping;
        list vrf {
          tailf:info "Enter the OSPFv3 vrf configuration submode";
          tailf:cli-mode-name config-ospfv3-vrf;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Name for this OSPFv3 vrf";
            }
          }
          uses router-ospfv3-grouping;
        }
      }
      container bgp {
        tailf:info "BGP configuration subcommand";
        list bgp-no-instance {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-bgp;
          key id;
          leaf id {
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;Autonomous system number";
                range "1..4294967295";
              }
              type string {
                tailf:info "<1.0-XX.YY>;;Autonomous system number";
                pattern "[0-9]+\\.[0-9]+";
              }
            }
          }
          uses router-bgp-grouping;
        }
        list bgp-instance {
          tailf:cli-drop-node-name;
          tailf:cli-mode-name config-bgp;
          key "id instance";
          leaf id {
            tailf:info "Autonomous system number";
            type union {
              type uint32 {
                tailf:info "<1-4294967295>;;Autonomous system number";
                range "1..4294967295";
              }
              type string {
                tailf:info "<1.0-XX.YY>;;Autonomous system number";
                pattern "[0-9]+\\.[0-9]+";
              }
            }
          }
          leaf instance {
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;instance name (maximum length 32 characters)";
            }
          }
          uses router-bgp-grouping;
        }
      }
      container mld {
        tailf:info "IPv6 address family";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mld;
        uses router-mld-grouping;
        list vrf {
          tailf:info "VRF configs";
          tailf:cli-mode-name config-mld-vrf;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter VRF name";
            }
          }
          uses router-mld-grouping;
        }
      }
      container pim {
        tailf:info "PIM configuration subcommands";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-pim;
        uses router-pim-grouping;
        list vrf {
          tailf:info "VRF configs";
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter VRF name";
            }
          }
          uses router-pim-grouping;
        }
      }
      container rip {
        tailf:info "RIP configuration subcommands";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-rip;
        presence true;
        uses router-rip-grouping;
        list vrf {
          tailf:info "VRF configs";
          tailf:cli-mode-name config-rip-vrf;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Enter VRF name";
            }
          }
          uses router-rip-grouping;
        }
      }
      container vrrp {
        tailf:info "VRRP configuration subcommands";
        tailf:cli-add-mode;
        list interface {
          tailf:cli-mode-name config-vrrp-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          container bfd {
            tailf:info "Configure BFD parameters";
            leaf minimum-interval {
              tailf:info "Hello interval";
              type uint16 {
                tailf:info "<3-30000>;;hello interval in milli-seconds";
                range "3..30000";
              }
            }
            leaf multiplier {
              tailf:info "Detect multiplier";
              type uint8 {
                tailf:info "<2-50>;;Detect multiplier";
                range "2..50";
              }
            }
          }
          container address-family {
            tailf:info "VRRP address family";
            container ipv4 {
              tailf:info "IPv4 address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-vrrp-address-family;
              list vrrp {
                tailf:cli-mode-name config-vrrp-virtual-router;
                key id;
                leaf id {
                  type uint8 {
                    tailf:info "<1-255>;;VRID Virtual Router Identifier";
                    range "1..255";
                  }
                }
                uses router-vrrp-if-af-vrrp-grouping;
                list address {
                  tailf:info "Enable VRRP and specify IP address(es)";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  key ip;
                  leaf ip {
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;VRRP IPv4 address";
                    }
                  }
                  leaf secondary {
                    tailf:info "Set Secondary VRRP IP address";
                    type empty;
                  }
                }
                container bfd {
                  tailf:info "Configure BFD parameters";
                  container fast-detect {
                    tailf:info "Enable Fast detection";
                    container peer {
                      tailf:info "Information about VRRP peer for BFD monitoring";
                      leaf ipv4 {
                        tailf:info "BFD peer interface IPv4 address";
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;VRRP BFD remote interface IP address";
                        }
                      }
                    }
                  }
                }
                leaf text-authentication {
                  tailf:info "Set plain text authentication string";
                  type string {
                    tailf:info "WORD;;Authentication password, 8 chars max";
                    length "1..8";
                  }
                }
              }
            }
            container ipv6 {
              tailf:info "IPv6 address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-vrrp-address-family;
              list vrrp {
                tailf:cli-mode-name config-vrrp-virtual-router;
                key id;
                leaf id {
                  type uint8 {
                    tailf:info "<1-255>;;VRID Virtual Router Identifier";
                    range "1..255";
                  }
                }
                uses router-vrrp-if-af-vrrp-grouping;
                container address {
                  tailf:info "Enable VRRP and specify IP address(es)";
                  list global {
                    tailf:info "Global VRRP IPv6 address";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    tailf:cli-compact-syntax;
                    key ip;
                    leaf ip {
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;Set Global VRRP IPv6 address";
                      }
                    }
                  }
                  leaf linklocal {
                    tailf:info "VRRP IPv6 linklocal address";
                    type union {
                      type inet:ipv6-address {
                        tailf:info "X:X::X;;VRRP IPv6 linklocal address ";
                      }
                      type enumeration {
                        enum autoconfig {
                          tailf:info "Autoconfigure the VRRP IPv6 linklocal address";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      container hsrp {
        tailf:info "HSRP configuration subcommands";
        tailf:cli-add-mode;
        list interface {
          tailf:info "VRRP interface configuration subcommands";
          tailf:cli-mode-name config-hsrp-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          container hsrp {
            tailf:info "HSRP configuration";
            container bfd {
              tailf:info "Configure BFD parameters";
              leaf minimum-interval {
                tailf:info "Hello interval";
                type uint16 {
                  tailf:info "<3-30000>;;hello interval in milli-seconds";
                  range "3..30000";
                }
              }
              leaf multiplier {
                tailf:info "Detect multiplier";
                type uint8 {
                  tailf:info "<2-50>;;Detect multiplier";
                  range "2..50";
                }
              }
            }
            container delay {
              tailf:info "Set activation delay for hsrp";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              leaf minimum {
                tailf:info "Set minimum delay on every interface up event";
                type uint16 {
                  tailf:info "<0-10000>;;Minimum delay in seconds";
                  range "0..10000";
                }
              }
              leaf reload {
                tailf:info "Set reload delay for first interface up even";
                type uint16 {
                  tailf:info "<0-10000>;;Reload delay in seconds";
                  range "0..10000";
                }
              }
            }
            leaf use-bia {
              tailf:info "Use burned-in address";
              tailf:cli-full-command;
              type empty;
            }
          }
          container address-family {
            tailf:info "HSRP address family";
            container ipv4 {
              tailf:info "IPv4 address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-hsrp-ipv4;
              container hsrp {
                tailf:info "HSRP group configuration";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-hsrp-gp;
                uses router-hsrp-ipv4-group-grouping;
              }
              container hsrp-version1-list {
                tailf:cli-drop-node-name;
                list hsrp {
                  tailf:cli-mode-name config-hsrp-gp;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                      range "0..4095";
                    }
                  }
                  uses router-hsrp-ipv4-group-grouping;
                }
              }
              container hsrp-version2 {
                tailf:cli-drop-node-name;
                container hsrp {
                  tailf:info "HSRP group configuration";
                  list version {
                    tailf:info "HSRP version";
                    tailf:cli-mode-name config-hsrp-gp;
                    key version;
                    leaf version {
                      type enumeration {
                        enum 2;
                      }
                    }
                    uses router-hsrp-ipv4-group-grouping;
                  }
                }
              }
              container hsrp-version2-list {
                tailf:cli-drop-node-name;
                list hsrp {
                  tailf:cli-mode-name config-hsrp-gp;
                  key "id version";
                  leaf id {
                    type uint16 {
                      tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                      range "0..4095";
                    }
                  }
                  leaf version {
                    tailf:info "HSRP version";
                    tailf:cli-expose-key-name;
                    type uint8 {
                      tailf:info "<2>;;HSRP version number";
                      range 2;
                    }
                  }
                  uses router-hsrp-ipv4-group-grouping;
                }
              }
            }
            container ipv6 {
              tailf:info "IPv6 address family";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-hsrp-ipv6;
              container hsrp {
                tailf:info "HSRP group configuration";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-hsrp-gp;
                uses router-hsrp-ipv6-group-grouping;
              }
              container hsrp-version1-list {
                tailf:cli-drop-node-name;
                list hsrp {
                  tailf:cli-mode-name config-hsrp-gp;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                      range "0..4095";
                    }
                  }
                  uses router-hsrp-ipv6-group-grouping;
                }
              }
              container hsrp-version2 {
                tailf:cli-drop-node-name;
                container hsrp {
                  tailf:info "HSRP group configuration";
                  list version {
                    tailf:info "HSRP version";
                    tailf:cli-mode-name config-hsrp-gp;
                    key version;
                    leaf version {
                      type enumeration {
                        enum 2;
                      }
                    }
                    uses router-hsrp-ipv6-group-grouping;
                  }
                }
              }
              container hsrp-version2-list {
                tailf:cli-drop-node-name;
                list hsrp {
                  tailf:cli-mode-name config-hsrp-gp;
                  key "id version";
                  leaf id {
                    type uint16 {
                      tailf:info "<0-4095>;;group number (version 1 0-255, version 2 0-4095)";
                      range "0..4095";
                    }
                  }
                  leaf version {
                    tailf:info "HSRP version";
                    tailf:cli-expose-key-name;
                    type uint8 {
                      tailf:info "<2>;;HSRP version number";
                      range 2;
                    }
                  }
                  uses router-hsrp-ipv6-group-grouping;
                }
              }
            }
          }
        }
      }
    }
    container service-policy {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure global service policy";
      leaf-list apply-order {
        tailf:info "Configure service policy ordering";
        tailf:cli-flat-list-syntax;
        tailf:cli-replace-all;
        ordered-by user;
        type enumeration {
          enum pbr {
            tailf:info "Policy based routing";
          }
          enum qos {
            tailf:info "Quality of service";
          }
        }
      }
    }
    container service-function-chaining {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "configure service function chaining";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-service-function-chain;
      tailf:cli-explicit-exit;
      list sf {
        tailf:info "service function";
        tailf:cli-mode-name config-service-function-chain-sf;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;service function name";
          }
        }
        list locator {
          tailf:info "Specify service function locator id";
          tailf:cli-mode-name config-service-function-chain-sfl;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Specify locator id";
              range "1..255";
            }
          }
          container transport {
            tailf:info "Choose SFL transport";
            container vxlan-gpe {
              tailf:info "transport vxlan-gpe";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-service-function-chain-vxl;
              tailf:cli-compact-syntax;
              container source-address {
                tailf:info "Local IP address";
                tailf:cli-flatten-container;
                leaf ipv4 {
                  tailf:info "setup IPv4  path";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Local IP address";
                  }
                }
              }
              container destination-address {
                tailf:info "Remote IP address";
                tailf:cli-flatten-container;
                leaf ipv4 {
                  tailf:info "setup IPv4  path";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Remote IP address";
                  }
                }
              }
              leaf source-port {
                tailf:info "Local port";
                type uint16 {
                  tailf:info "<1-65535>;;Enter local port";
                  range "1..65535";
                }
              }
              leaf vni {
                tailf:info "vni value";
                type uint16 {
                  tailf:info "<1-65535>;;Enter vni value";
                  range "1..65535";
                }
              }
            }
          }
        }
      }
      list sff {
        tailf:info "service function forwarder";
        tailf:cli-mode-name config-service-function-chain-sf;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;service function name";
          }
        }
        list locator {
          tailf:info "Specify service function locator id";
          tailf:cli-mode-name config-service-function-chain-sfl;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Specify locator id";
              range "1..255";
            }
          }
          container transport {
            tailf:info "Choose SFL transport";
            container vxlan-gpe {
              tailf:info "transport vxlan-gpe";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-service-function-chain-vxl;
              tailf:cli-compact-syntax;
              container source-address {
                tailf:info "Local IP address";
                tailf:cli-flatten-container;
                leaf ipv4 {
                  tailf:info "setup IPv4  path";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Local IP address";
                  }
                }
              }
              container destination-address {
                tailf:info "Remote IP address";
                tailf:cli-flatten-container;
                leaf ipv4 {
                  tailf:info "setup IPv4  path";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Remote IP address";
                  }
                }
              }
              leaf source-port {
                tailf:info "Local port";
                type uint16 {
                  tailf:info "<1-65535>;;Enter local port";
                  range "1..65535";
                }
              }
              leaf vni {
                tailf:info "vni value";
                type uint16 {
                  tailf:info "<1-65535>;;Enter vni value";
                  range "1..65535";
                }
              }
            }
          }
        }
      }
      list metadata {
        tailf:info "metadata imposition";
        tailf:cli-mode-name config-sfc-metadata;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;metadata profile name";
          }
        }
        list type {
          tailf:info "Specify metadata type";
          tailf:cli-mode-name config-sfc-metadata-type;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type enumeration {
              enum 1 {
                tailf:info "Type 1 metadata";
              }
            }
          }
          leaf format {
            tailf:info "Specify metadata format";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum dc-allocation {
                tailf:info "format dc-allocation";
              }
            }
          }
          leaf tenant-id {
            tailf:info "Specify tenant id";
            type uint32 {
              tailf:info "<1-16777215>;;Enter 24-bit tenant id";
              range "1..16777215";
            }
          }
        }
      }
      list path {
        tailf:info "Configure service function path";
        tailf:cli-mode-name config-service-function-chain-path;
        key id;
        leaf id {
          type uint32 {
            tailf:info "<1-16777215>;;Specify the service function path id";
            range "1..16777215";
          }
        }
        list terminate-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Specify the id of service function";
              range "1..255";
            }
          }
          leaf terminate {
            tailf:info "Configure terminate";
            tailf:cli-incomplete-command;
            type empty;
          }
          leaf metadata-disposition {
            tailf:info "Specify metadata-disposition name";
            tailf:cli-incomplete-command;
            type string {
              tailf:info "WORD;,metadata-disposition name";
            }
          }
          container default-action {
            tailf:info "Configure the default action for service function path";
            tailf:cli-flatten-container;
            tailf:cli-compact-syntax;
            container redirect {
              tailf:info "Configure redirect action";
              tailf:cli-flatten-container;
              tailf:cli-compact-syntax;
              container ipv4 {
                tailf:info "Enter ipv4 configuration";
                tailf:cli-flatten-container;
                tailf:cli-compact-syntax;
                container nexthop {
                  tailf:info "Configure the nexthop action";
                  tailf:cli-flatten-container;
                  tailf:cli-compact-syntax;
                  choice nexthop-choice {
                    leaf address {
                      tailf:cli-drop-node-name;
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;IPv4 nexthop address";
                      }
                    }
                    leaf vrf {
                      tailf:info "Enter vrf name for the nexthop";
                      type string {
                        tailf:info "WORD;;Enter VRF name";
                      }
                    }
                  }
                }
              }
            }
          }
        }
        list sf-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id sf";
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Specify the id of service function";
              range "1..255";
            }
          }
          leaf sf {
            tailf:info "service function";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;service function name";
            }
          }
        }
        list sff-list {
          tailf:cli-drop-node-name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key "id sff";
          leaf id {
            type uint8 {
              tailf:info "<1-255>;;Specify the id of service function";
              range "1..255";
            }
          }
          leaf sff {
            tailf:info "service function forwarder";
            tailf:cli-expose-key-name;
            type string {
              tailf:info "WORD;;service function name";
            }
          }
        }
      }
      list metadata-disposition {
        tailf:info "metadata disposition";
        tailf:cli-mode-name config-sfc-disposition;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;specify service disposition name";
          }
        }
        list type {
          tailf:info "Specify disposition allocation type";
          tailf:cli-mode-name config-sfc-metadata-type;
          tailf:cli-incomplete-command;
          key id;
          leaf id {
            type enumeration {
              enum 1 {
                tailf:info "Allocation format Type 1";
              }
            }
          }
          leaf format {
            tailf:info "Specify allocation format";
            tailf:cli-hide-in-submode;
            type enumeration {
              enum dc-allocation {
                tailf:info "data center allocation";
              }
            }
          }
          list match-entry {
            tailf:info "Specify the match entry name";
            tailf:cli-mode-name config-sfc-disposition-match;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;match-entry name";
              }
            }
            container tenant-id {
              tailf:info "Specify the tenant-ids";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-sfc-disposition-action;
              tailf:cli-incomplete-command;
              leaf id {
                tailf:cli-drop-node-name;
                tailf:cli-hide-in-submode;
                type uint32 {
                  tailf:info "<0-4294967295>;;tenant id";
                }
              }
              container redirect {
                tailf:info "Configure redirect action";
                container ipv4 {
                  tailf:info "Enter ipv4 configuration";
                  container nexthop {
                    tailf:info "Configure the nexthop action";
                    choice nexthop-choice {
                      leaf address {
                        tailf:cli-drop-node-name;
                        type inet:ipv4-address {
                          tailf:info "A.B.C.D;;IPv4 nexthop address";
                        }
                      }
                      leaf vrf {
                        tailf:info "Enter vrf name for the nexthop";
                        type string {
                          tailf:info "WORD;;Enter VRF name";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container flowspec {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "FlowSpec configuration";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-flowspec;
      container local-install {
        tailf:info "Local installation of flowspec policy";
        leaf interface-all {
          tailf:info "Install flowspec policy on all interfaces";
          type empty;
        }
      }
      container address-family {
        tailf:info "Address Family Identifier Type (IPv4/IPv6)";
        container ipv4 {
          tailf:info "IPv4 flow";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-flowspec-af;
          container local-install {
            tailf:info "Local installation of flowspec policy";
            leaf interface-all {
              tailf:info "Install flowspec policy on all interfaces";
              type empty;
            }
          }
          list service-policy {
            tailf:info "Service Policy configuration";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-full-command;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Policy map name";
              }
            }
            leaf type {
              tailf:info "Type of the service policy";
              tailf:cli-prefix-key;
              type enumeration {
                enum pbr {
                  tailf:info "PBR policy type";
                }
              }
            }
          }
        }
      }
    }
    container rsvp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Global RSVP configuration commands";
      tailf:cli-add-mode;
      tailf:cli-explicit-exit;
      list interface {
        tailf:info "Enable RSVP on an interface";
        tailf:cli-mode-name config-rsvp-if;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Interface Name";
          }
        }
        container bandwidth {
          tailf:info "Configure RSVP bandwidth parameters";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          tailf:cli-delete-when-empty;
          presence true;
          choice bandwidth-choice {
            case percentage-case {
              leaf percentage {
                tailf:info "Supply bandwidths as percentages of physical link bandwidth";
                type empty;
              }
              leaf total-reservable-percent {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<0-10000>;;Total reservable bandwidth as percentage of physical link bandwidth";
                  range "0..10000";
                }
              }
            }
            case rsvp-case {
              leaf total-reservable {
                tailf:cli-drop-node-name;
                type uint32 {
                  tailf:info "<0-4294967295>;;Total reservable bandwidth (in Kbps, Mbps or Gbps)";
                }
              }
              leaf total-reservable-unit {
                when "../total-reservable" {
                  tailf:xpath-root 3;
                  tailf:dependency "../total-reservable";
                }
                tailf:cli-drop-node-name;
                type enumeration {
                  enum Gbps {
                    tailf:info "BW in Gbps";
                  }
                  enum Kbps {
                    tailf:info "BW in Kbps (Default)";
                  }
                  enum Mbps {
                    tailf:info "BW in Mbps";
                  }
                }
              }
            }
            case rdm-case {
              container rdm {
                tailf:info "Russian Doll Model";
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                leaf bc0 {
                  tailf:info "BC0 pool";
                  type uint32 {
                    tailf:info "<0-4294967295>;;Total reservable bandwidth";
                  }
                }
                leaf largest-reservable-flow {
                  tailf:cli-drop-node-name;
                  tailf:cli-optional-in-sequence;
                  type uint32 {
                    tailf:info "<0-4294967295>;;Largest reservable flow";
                  }
                }
                leaf bc1 {
                  tailf:info "BC1 pool";
                  type uint32 {
                    tailf:info "<0-4294967295>;;Reservable bandwidth in sub-pool";
                  }
                }
              }
            }
          }
        }
        container signalling {
          tailf:info "Configure RSVP signalling parameters";
          leaf dscp {
            tailf:info "Set DSCP for RSVP signalling messages";
            type uint8 {
              tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
              range "0..63";
            }
          }
        }
      }
      container signalling {
        tailf:info "Configure global RSVP signalling parameters";
        container graceful-restart {
          tailf:info "Configure RSVP Graceful-Restart parameters";
          presence true;
        }
        container message-bundle {
          tailf:info "Sending bundled messages(cisco-support)";
          leaf disable {
            tailf:info "Disable bundling of outgoing RSVP messages";
            type empty;
          }
        }
      }
      container authentication {
        tailf:info "Configure RSVP authentication parameters";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-rsvp-auth;
        container key-source {
          tailf:info "Specify key-source for authenticating RSVP signalling messages";
          leaf key-chain {
            tailf:info "Use key-chain to authenticate RSVP signalling messages";
            type string {
              tailf:info "WORD;;Name of key-chain";
            }
          }
        }
      }
    }
    container lmp {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure OLM/LMP application settings";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-lmp;
      tailf:cli-explicit-exit;
      presence true;
      container gmpls {
        tailf:info "Configure LMP GMPLS application settings";
        container optical-uni {
          tailf:info "Configure GMPLS Optical UNI application settings";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-lmp-gmpls-uni;
          list controller {
            tailf:info "Enable LMP GMPLS UNI on a controller";
            tailf:cli-mode-name config-lmp-gmpls-uni-cntl;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface/controller name";
              }
            }
            container neighbor {
              tailf:info "Neighbor LMP GMPLS UNI configuration commands";
              leaf name {
                tailf:cli-drop-node-name;
                tailf:cli-full-command;
                tailf:cli-disallow-value interface-id|link-id;
                type string {
                  tailf:info "WORD;;LMP Neighbor name";
                }
              }
              container link-id {
                tailf:info "LMP Neighbor link identifier address";
                container ipv4 {
                  tailf:info "Neighbor Link identifier address (IPv4 Address)";
                  leaf unicast {
                    tailf:info "Unicast address";
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Neighbor Link identifier address (IPv4 Address)";
                    }
                  }
                }
              }
              container interface-id {
                tailf:info "LMP Neighbor interface identifier";
                leaf unnumbered {
                  tailf:info "Neighbor link unnumbered interface identifier";
                  type uint32 {
                    tailf:info "<1-4294967295>;;Neighbor unnumbered interface identifier";
                    range "1..4294967295";
                  }
                }
              }
            }
            container link-id {
              tailf:info "Local LMP GMPLS UNI link identifier address";
              container ipv4 {
                tailf:info "Local link identifier address (IPv4 Address)";
                leaf unicast {
                  tailf:info "Unicast address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Local Link identifier address (IPv4 Address)";
                  }
                }
              }
            }
          }
          list neighbor {
            tailf:info "The GMPLS UNI LMP neighbor configuration submode";
            tailf:cli-mode-name config-lmp-gmpls-uni-nbr;
            key name;
            leaf name {
              type string {
                tailf:info "WORD;;Interface/controller name";
              }
            }
            container ipcc {
              tailf:info "IPCC manipulation commands";
              leaf routed {
                tailf:info "Create a routed IPCC";
                type empty;
              }
            }
            container router-id {
              tailf:info "GMPLS UNI LMP neighbor router ID";
              container ipv4 {
                tailf:info "IPv4 address";
                leaf unicast {
                  tailf:info "Unicast address";
                  type inet:ipv4-address {
                    tailf:info "A.B.C.D;;Remote LMP neighbor router ID (IPv4 Address)";
                  }
                }
              }
            }
          }
          container router-id {
            tailf:info "GMPLS UNI LMP local node ID";
            container ipv4 {
              tailf:info "IPv4 address";
              leaf unicast {
                tailf:info "Unicast address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;GMPLS UNI LMP router id address";
                }
              }
            }
          }
        }
      }
    }
    container mpls {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Configure MPLS parameters";
      tailf:cli-explicit-exit;
      container label {
        tailf:info "Label properties";
        leaf protocol {
          tailf:info "Set platform default label distribution protocol";
          type enumeration {
            enum ldp {
              tailf:info "Use LDP (default)";
            }
            enum tdp {
              tailf:info "Use TDP";
            }
          }
        }
        container range {
          tailf:info "Label range";
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-siblings;
          }
          leaf min {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<16-524287>;;Minimum label value for dynamic label range";
              range "16..524287";
            }
          }
          leaf max {
            tailf:cli-drop-node-name;
            tailf:cli-incomplete-command;
            type uint32 {
              tailf:info "<11000-524287>;;Maximum label value for dynamic label range";
              range "11000..524287";
            }
          }
        }
      }
      container traffic-eng {
        tailf:info "Go into the MPLS-TE submode";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mpls-te;
        container auto-tunnel {
          tailf:info "Automatically created tunnel configuration";
          container p2p {
            tailf:info "Enter the auto-tunnel p2p configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-auto-p2p;
            container tunnel-id {
              tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf min {
                tailf:info "Minimum tunnel ID for auto-tunnel p2p";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel p2p";
                }
              }
              leaf max {
                tailf:info "Maximum tunnel ID for auto-tunnel p2p";
                type uint16 {
                  tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel p2p";
                }
              }
            }
          }
          container pcc {
            tailf:info "Enter the auto-tunnel stateful PCE client configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-auto-pcc;
            container tunnel-id {
              tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf min {
                tailf:info "Minimum tunnel ID for stateful PCE client auto-tunnels";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;Minimum tunnel ID value for stateful PCE client auto-tunnels";
                }
              }
              leaf max {
                tailf:info "Maximum tunnel ID for stateful PCE client auto-tunnels";
                type uint16 {
                  tailf:info "<0-65535>;;Maximum tunnel ID value for stateful PCE client auto-tunnels";
                }
              }
            }
          }
          container backup {
            tailf:info "Enter the auto-tunnel backup configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-mpls-te-auto-bk;
            container timers {
              tailf:info "Auto-tunnel backups related timers";
              container removal {
                tailf:info "Auto-tunnel backups removal timers";
                leaf unused {
                  tailf:info "Auto-tunnel backups unused removal timer";
                  type uint16 {
                    tailf:info "<0-10080>;;Auto-tunnel backup unused timeout in minutes (0=never timeout)";
                    range "0..10080";
                  }
                }
              }
            }
            container tunnel-id {
              tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf min {
                tailf:info "Minimum tunnel ID for auto-tunnel backups";
                type uint16 {
                  tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel backups";
                }
              }
              leaf max {
                tailf:info "Maximum tunnel ID for auto-tunnel backups";
                type uint16 {
                  tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel backups";
                }
              }
            }
          }
          container mesh {
            tailf:info "Enter the auto-tunnel mesh configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-auto-mesh;
            list group {
              tailf:info "Enter the auto-tunnel mesh group configuration submode";
              tailf:cli-mode-name config-te-mesh-group;
              key id;
              leaf id {
                type uint32 {
                  tailf:info "<0-4294967295>;;Auto-tunnel mesh group ID";
                }
              }
              leaf onehop {
                tailf:info "Automatically create tunnel to all next-hops";
                type empty;
              }
              leaf attribute-set {
                tailf:info "Attribute-set name of type auto-mesh";
                type string {
                  tailf:info "WORD;;Specify attribute-set name (max 64 char)";
                }
              }
              leaf destination-list {
                tailf:info "Destination-list (prefix-list) name";
                type string {
                  tailf:info "WORD;;Specify destination-list (prefix-list) (max 32 char)";
                }
              }
            }
            container tunnel-id {
              tailf:info "Specify Tunnel ID range (modify may result auto-tunnel delete)";
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              leaf min {
                tailf:info "Minimum tunnel ID for auto-tunnel mesh";
                tailf:cli-incomplete-command;
                type uint16 {
                  tailf:info "<0-65535>;;Minimum value of tunnel ID for auto-tunnel mesh";
                }
              }
              leaf max {
                tailf:info "Maximum tunnel ID for auto-tunnel mesh";
                type uint16 {
                  tailf:info "<0-65535>;;Maximum value of tunnel ID for auto-tunnel mesh";
                }
              }
            }
          }
        }
        list interface {
          tailf:info "Enable MPLS-TE on an interface";
          tailf:cli-mode-name config-mpls-te-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          container bfd {
            tailf:info "Configure BFD parameters";
            leaf fast-detect {
              tailf:info "Enable Fast detection";
              type empty;
            }
          }
          container auto-tunnel {
            tailf:info "Auto-tunnel configuration";
            container backup {
              tailf:info "Enable the auto-tunnel backup feature on an interface";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-mpls-te-if-auto-backup;
              presence true;
              container exclude {
                tailf:info "Restrict auto-tunnel backup path based on specific criteria.";
                container srlg {
                  tailf:info "Backup requires SRLG exclusion from protected interface";
                  tailf:cli-delete-when-empty;
                  tailf:cli-reset-container;
                  presence true;
                  leaf preferred {
                    tailf:info "SRLG exclusion is preferred but not mandatory";
                    type empty;
                  }
                }
              }
            }
          }
          leaf attribute-flags {
            tailf:info "Set user defined interface attribute flags";
            type string {
              tailf:info "<0x0-0xffffffff>;;User defined interface attribute flags";
            }
          }
          container attribute-names {
            tailf:info "Specify one or more attribute names";
            leaf name {
              tailf:cli-drop-node-name;
              tailf:cli-disallow-value index;
              type string {
                tailf:info "WORD;;User defined attribute name";
              }
            }
            list index {
              tailf:info "Specify the entry index";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-incomplete-command;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<1-8>;;Index number";
                  range "1..8";
                }
              }
              leaf name {
                tailf:cli-drop-node-name;
                type string {
                  tailf:info "WORD;;User defined attribute name";
                }
              }
            }
          }
          leaf admin-weight {
            tailf:info "Set administrative weight for the interface";
            type uint32 {
              tailf:info "<0-4294967295>;;Administrative weight for the interface";
            }
          }
          container backup-path {
            tailf:info "Configure an MPLS TE backup for this interface";
            leaf tunnel-te {
              tailf:info "Tunnel interface number";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-65535>;;Tunnel interface number";
                range "0..65535";
              }
            }
          }
        }
        container pce {
          tailf:info "MPLS Traffic Engineering PCE functionality";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-mpls-te-pce;
          container peer {
            tailf:info "PCE peer related configuration";
            container source {
              tailf:info "Peer source";
              leaf ipv4 {
                tailf:info "IPv4 address";
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the source";
                }
              }
            }
            list ipv4 {
              tailf:info "IPv4 address";
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              key address;
              leaf address {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;IPv4 address of the peer";
                }
              }
            }
          }
          leaf segment-routing {
            tailf:info "Enable segment-routing capability";
            type empty;
          }
          container stateful-client {
            tailf:info "Enter the stateful PCE client configuration submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-mpls-te-pce-stateful;
            leaf instantiation {
              tailf:info "Enable stateful instantiate capability";
              type empty;
            }
            leaf cisco-extension {
              tailf:info "Enable processing of PCEP Cisco extension";
              type empty;
            }
          }
        }
        container logging {
          tailf:info "MPLS Traffic-Eng. logging configuration";
          container events {
            tailf:info "Global logging events";
            leaf all {
              tailf:info "Enable all logging for all events";
              tailf:cli-full-command;
              type empty;
            }
            leaf frr-protection {
              tailf:info "Enable protection change Syslog";
              tailf:cli-full-command;
              type empty;
            }
            leaf preemption {
              tailf:info "Enable Tunnel Preemption alarms";
              tailf:cli-full-command;
              type empty;
            }
          }
        }
        list affinity-map {
          tailf:info "Affinity Map Configuration";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Affinity attribute name";
            }
          }
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type string {
              tailf:info "<0x1-0x80000000>;;Affinity attribute value";
            }
          }
          leaf bit-position {
            tailf:info "Bit Position for Affinity attribute value";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<0-255>;;Bit Position";
            }
          }
        }
        list attribute-set {
          tailf:info "Specify attribute set";
          tailf:cli-mode-name config-te-attribute-set;
          key "type pathname";
          leaf type {
            type enumeration {
              enum path-option {
                tailf:info "Attribute-set of a path option";
              }
              enum auto-backup {
                tailf:info "Attribute-set of auto-backup type";
              }
              enum auto-mesh {
                tailf:info "Attribute-set of auto mesh type";
              }
              enum p2mp-te {
                tailf:info "Attribute-set of p2mp-te type";
              }
              enum path-protection-aps {
                tailf:info "Attribute-set of path protection";
              }
              enum xro {
                tailf:info "An XRO attribute-set";
              }
              enum p2p-te {
                tailf:info "Attribute-set of p2p-te type";
              }
            }
          }
          leaf pathname {
            type string {
              tailf:info "WORD;;Specify attribute-set name";
            }
          }
          container affinity {
            tailf:info "Link attributes for links traversed by tunnel";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf value {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type string {
                tailf:info "<0x0-0xffffffff>;;Affinity value";
              }
            }
            leaf mask {
              type string {
                tailf:info "<0x0-0xffffffff>;;Affinity mask value";
              }
            }
          }
          container logging {
            tailf:info "Per-interface logging configuration";
            container events {
              tailf:info "Per-interface logging events";
              uses lsp-status-grouping;
            }
          }
          leaf bandwidth {
            tailf:info "Set the bandwidth of an interface";
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-4294967295>;;bandwidth in kbps";
            }
          }
          container priority {
            tailf:info "Tunnel priority";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf setup {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint8 {
                tailf:info "<0-7>;;Setup Priority";
                range "0..7";
              }
            }
            leaf hold {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<0-7>;;Hold Priority";
                range "0..7";
              }
            }
          }
          container signalled-bandwidth {
            tailf:info "Tunnel bandwidth requirement to be signalled";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf bw-req {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<0-4294967295>;;Bandwidth requirement in kbps";
                range "0..4294967295";
              }
            }
            leaf class-type {
              tailf:info "Specify the bandwidth class type";
              type uint8 {
                tailf:info "<0-1>;;Class type number";
                range "0..1";
              }
            }
          }
          container autoroute {
            tailf:info "Parameters for IGP routing over tunnel";
            leaf announce {
              tailf:info "Announce tunnel to IGP";
              type empty;
            }
          }
          container fast-reroute {
            tailf:info "Specify MPLS tunnel can be fast-rerouted";
            tailf:cli-delete-when-empty;
            presence true;
            leaf-list protect {
              tailf:info "Enable protection request";
              tailf:cli-flat-list-syntax;
              tailf:cli-replace-all;
              type enumeration {
                enum node {
                  tailf:info "Enable node protection request";
                }
                enum bandwidth {
                  tailf:info "Enable bandwidth protection request";
                }
              }
            }
          }
          container policy-class {
            tailf:info "Specify class for policy-based tunnel selection";
            tailf:cli-delete-when-empty;
            presence true;
            leaf value {
              tailf:cli-drop-node-name;
              type uint8 {
                tailf:info "<1-7>;;Tunnel policy class";
                range "1..7";
              }
            }
          }
          leaf record-route {
            tailf:info "Record the route used by the tunnel";
            tailf:cli-full-command;
            type empty;
          }
          leaf forward-class {
            tailf:info "Specify tunnel forward class for policy based routing";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<1-7>;;Forward class for the tunnel (default value 0)";
              range "1..7";
            }
          }
          list exclude {
            tailf:info "Specify exclusions for path diversity";
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands {
              tailf:cli-reset-siblings;
            }
            key "source destination tunnel-id extended-tunnel-id";
            leaf mode {
              tailf:cli-drop-node-name;
              tailf:cli-prefix-key;
              type enumeration {
                enum best-effort {
                  tailf:info "Specified condition should be met if possible";
                }
                enum strict {
                  tailf:info "Specified condition must be met";
                }
              }
            }
            leaf lsp {
              tailf:info "Specify path-diversity from another LSP";
              tailf:cli-prefix-key;
              type empty;
            }
            leaf source {
              tailf:info "The source of the LSP from which a diverse path is required";
              tailf:cli-expose-key-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The LSP's source address";
              }
            }
            leaf destination {
              tailf:info "The destination of the LSP from which a diverse path is required";
              tailf:cli-expose-key-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The LSP's destination address";
              }
            }
            leaf tunnel-id {
              tailf:info "The tunnel-id of the LSP from which a diverse path is required";
              tailf:cli-expose-key-name;
              type uint16 {
                tailf:info "<0-65535>;;The LSP's tunnel-id";
              }
            }
            leaf extended-tunnel-id {
              tailf:info "The extended tunnel-id of the LSP from which a diverse path is required";
              tailf:cli-expose-key-name;
              type inet:ipv4-address {
                tailf:info "A.B.C.D;;The LSP's extended tunnel-id";
              }
            }
            leaf lsp-id {
              tailf:info "The lsp-id of the LSP from which a diverse path is required";
              type uint16 {
                tailf:info "<0-65535>;;The LSP's lsp-id (optional)";
              }
            }
          }
          container pce {
            tailf:info "Specify PCE Configuration";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-attrset-pce;
            presence true;
          }
          container path-selection {
            tailf:info "Specify path selection";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-attrset-path-select;
            presence true;
            leaf metric {
              tailf:info "Metric type for path calculation";
              type enumeration {
                enum igp {
                  tailf:info "Use IGP metric";
                }
                enum te {
                  tailf:info "Use TE metric";
                }
              }
            }
          }
        }
        container ds-te {
          tailf:info "Diff-Serv Traffic-Engineering Parameters";
          container mode {
            tailf:info "Diff-Serv Traffic-Engineering Mode";
            leaf ietf {
              tailf:info "IETF Standard Mode";
              type empty;
            }
          }
          container te-classes {
            tailf:info "enter the DS-TE te-class map configuration mode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-class;
            list te-class {
              tailf:cli-suppress-mode;
              tailf:cli-delete-when-empty;
              tailf:cli-compact-syntax;
              tailf:cli-sequence-commands;
              key id;
              leaf id {
                type uint8 {
                  tailf:info "<0-7>;;DS-TE class number";
                  range "0..7";
                }
              }
              choice te-class-choice {
                leaf unused {
                  tailf:info "Mark the TE-class as unused";
                  type empty;
                }
                case used {
                  leaf class-type {
                    tailf:info "Class type";
                    tailf:cli-incomplete-command;
                    type uint8 {
                      tailf:info "<0-1>;;Class type number";
                      range "0..1";
                    }
                  }
                  leaf priority {
                    tailf:info "Class priority";
                    type uint8 {
                      tailf:info "<0-7>;;Class-type priority";
                      range "0..7";
                    }
                  }
                }
              }
            }
          }
        }
        container soft-preemption {
          tailf:info "Enable soft-preemption";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-soft-preemption;
          leaf timeout {
            tailf:info "Specify a timeout for soft-preempted LSP";
            type uint32 {
              tailf:info "<1-300>;;Timeout for soft-preempted LSP in seconds:default 60";
              range "1..300";
            }
          }
        }
        container auto-bw {
          tailf:info "Auto-bandwidth configuration";
          container collect {
            tailf:info "Auto-bandwidth collection parameters";
            leaf frequency {
              tailf:info "Auto-bandwidth collection frequency parameter";
              type uint16 {
                tailf:info "<1-10080>;;Auto-bandwidth collection frequency in minutes";
                range "1..10080";
              }
            }
          }
        }
        container reoptimize {
          tailf:info "MPLS TE Reoptimize config";
          leaf value {
            tailf:cli-drop-node-name;
            tailf:cli-full-command;
            type uint32 {
              tailf:info "<0-604800>;;Reoptimize timers frequency (secs)";
              range "0..604800";
            }
          }
          container timers {
            tailf:info "Reoptimization timers";
            container delay {
              tailf:info "Delay reoptimization action";
              leaf cleanup {
                tailf:info "Delay cleanup of reoptimized LSP";
                type uint16 {
                  tailf:info "<0-300>;;Seconds to delay cleanup of reoptimized LSP";
                  range "0..300";
                }
              }
              leaf installation {
                tailf:info "Delay replacement of current LSP by reoptimized LSP";
                type uint16 {
                  tailf:info "<0-3600>;;Seconds to delay replacement of tunnel LSP";
                  range "0..3600";
                }
              }
              leaf after-frr {
                tailf:info "Delay LSP reoptimization in the event of FRR";
                tailf:cli-full-command;
                type uint8 {
                  tailf:info "<0-120>;;Seconds to delay re-opt initiation of tunnel after an FRR event";
                  range "0..120";
                }
              }
              leaf path-protection {
                tailf:info "Time between path protection switchover event and tunnel re-optimization";
                type uint32 {
                  tailf:info "<0-604800>;;Seconds between path protection switchover event and tunnel re-optimization. Set to 0 to disable";
                  range "0..604800";
                }
              }
            }
          }
        }
        container bfd {
          tailf:info "Configure BFD parameters";
          container lsp {
            tailf:info "Configure parameters for BFD over LSP";
            container head {
              tailf:info "Head end configuration";
              container down-action {
                tailf:info "Action to take for FRR enabled tunnel when BFD session down";
                leaf resetup {
                  tailf:info "Teardown and resetup when received BFD session down event";
                  type empty;
                }
                container reoptimize {
                  tailf:info "Reoptimize when received BFD session down event (default)";
                  leaf timeout {
                    tailf:info "Timeout and teardown if failed to reoptimize";
                    type uint32 {
                      tailf:info "<120-4294967295>;;Reoptmization timeout in seconds (default 300)";
                      range "120..4294967295";
                    }
                  }
                }
              }
            }
          }
          leaf multiplier {
            tailf:info "Detect multiplier";
            tailf:cli-full-command;
            type uint8 {
              tailf:info "<2-10>;;Detect multiplier";
              range "2..10";
            }
          }
          leaf minimum-interval {
            tailf:info "Hello interval";
            tailf:cli-full-command;
            type uint16 {
              tailf:info "<3-200>;;hello interval in milli-seconds";
              range "3..200";
            }
          }
        }
        container fast-reroute {
          tailf:info "Fast-reroute config parameters";
          container timers {
            tailf:info "Configure fast-reroute timer";
            leaf promotion {
              tailf:info "Configure how often we scan for LSP backup promotion";
              tailf:cli-full-command;
              type uint32 {
                tailf:info "<0-604800>;;Seconds between promotions (0 disables promotion)";
                range "0..604800";
              }
            }
          }
        }
        container link-management {
          tailf:info "MPLS Link Manager subcommands";
          container timers {
            tailf:info "MPLS Link Manager Timer subcommands";
            container preemption-delay {
              tailf:info "Delay LSP preemption";
              leaf bundle-capacity {
                tailf:info "Bundle capacity change preemption delay timer";
                type uint16 {
                  tailf:info "<0-300>;;Bundle capacity change preemption timer value (seconds)";
                  range "0..300";
                }
              }
            }
          }
        }
        container signalling {
          tailf:info "Signalling options";
          container advertise {
            tailf:info "Label advertising options";
            leaf explicit-null {
              tailf:info "Enable explicit-null advertising to PHOP";
              type empty;
            }
          }
        }
        container gmpls {
          tailf:info "GMPLS submode";
          container optical-uni {
            tailf:info "GMPLS-UNI submode";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-te-gmpls;
            list controller {
              tailf:cli-mode-name config-te-gmpls-cntl;
              key name;
              leaf name {
                type string {
                  tailf:info "WORD;;Interface/controller name";
                }
              }
              container tunnel-properties {
                tailf:info "Configure GMPLS-UNI tunnel head properties";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-te-gmpls-tun;
                leaf signalled-name {
                  tailf:info "The signaling name to assign to the tunnel";
                  tailf:cli-full-command;
                  type string {
                    tailf:info "WORD;;The name to be included in signaling (max 64 characters)";
                  }
                }
                leaf tunnel-id {
                  tailf:info "GMPLS-UNI tunnel id";
                  tailf:cli-full-command;
                  type uint16 {
                    tailf:info "<0-65535>;;Tunnel ID";
                  }
                }
                container destination {
                  tailf:info "Specify tunnel destination";
                  container ipv4 {
                    tailf:info "Specify an IPv4 destination";
                    leaf unicast {
                      tailf:info "Specify an IPv4 unicast destination";
                      type inet:ipv4-address {
                        tailf:info "A.B.C.D;;Tunnel destination address";
                      }
                    }
                  }
                }
                list path-option {
                  tailf:info "Configure a GMPLS-UNI path-option";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-1000>;;Preference for this path option";
                      range "1..1000";
                    }
                  }
                  choice path-choice {
                    case explicit {
                      leaf explicit {
                        tailf:info "Setup based on preconfigured path";
                        tailf:cli-incomplete-command;
                        type empty;
                      }
                      leaf identifier {
                        tailf:info "Specify an explicit path by number";
                        tailf:cli-optional-in-sequence;
                        tailf:cli-incomplete-command;
                        type uint16 {
                          tailf:info "<1-65535>;;Explicit path number";
                          range "1..65535";
                        }
                      }
                      leaf name {
                        tailf:info "Specify an explicit path by name";
                        tailf:cli-incomplete-command;
                        when "not(../identifier)" {
                          tailf:xpath-root 3;
                        }
                        type string {
                          tailf:info "WORD;;Explicit path name";
                        }
                      }
                    }
                    case no-ero {
                      leaf no-ero {
                        tailf:info "No path configuration";
                        tailf:cli-incomplete-command;
                        type empty;
                      }
                    }
                  }
                  leaf signaled-label {
                    tailf:cli-break-sequence-commands;
                    tailf:info "Specify a fixed upstream label to be used";
                    type enumeration {
                      enum dwdm {
                        tailf:info "DWDM label (RFC 6205), 50GHz channel-spacing";
                      }
                    }
                  }
                  leaf wavelength {
                    when "../signaled-label" {
                      tailf:xpath-root 3;
                    }
                    tailf:info "DWDM wavelength";
                    type uint8 {
                      tailf:info "<1-89>;;DWDM channel number (ITU), 50GHz channel-spacing";
                      range "1..89";
                    }
                  }
                  leaf xro-attribute-set {
                    tailf:info "Attribute-set containing path exclusions";
                    type string {
                      tailf:info "WORD;;Specify attribute-set name (max 64 char)";
                    }
                  }
                  leaf lockdown {
                    tailf:info "Not a candidate for reoptimization";
                    type empty;
                  }
                  leaf verbatim {
                    tailf:info "Use explicit path to construct ERO directly";
                    type empty;
                  }
                }
              }
            }
          }
        }
        container load-share {
          tailf:info "Load-share configuration";
          leaf unequal {
            tailf:info "Enable unequal load-sharing across TE tunnels to the same destination";
            type empty;
          }
        }
      }
      container ldp {
        tailf:info "Label Distribution Protocol";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-ldp;
        tailf:meta-data secret-add-mode;
        container log {
          tailf:info "Configure logging of LDP events";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-ldp-log;
          leaf adjacency {
            tailf:info "Adjacency events";
            tailf:cli-full-command;
            type empty;
          }
          leaf neighbor {
            tailf:info "Neighbor events";
            tailf:cli-full-command;
            type empty;
          }
          leaf graceful-restart {
            tailf:info "Graceful Restart events";
            tailf:cli-full-command;
            type empty;
          }
          leaf session-protection {
            tailf:info "Session Protection events";
            tailf:cli-full-command;
            type empty;
          }
          leaf nsr {
            tailf:info "NSR synchronization events";
            tailf:cli-full-command;
            type empty;
          }
        }
        leaf nsr {
          tailf:info "Configure Non-Stop Routing";
          tailf:cli-full-command;
          type empty;
        }
        container graceful-restart {
          tailf:info "Configure graceful restart feature";
          tailf:cli-delete-when-empty;
          presence true;
        }
        leaf holdtime {
          tailf:info "Configure session holdtime";
          type uint16 {
            tailf:info "<15-65535>;;Time (seconds)";
          }
        }
        container session {
          tailf:info "Configure session parameters";
          container protection {
            tailf:info "Configure session protection parameters";
            tailf:cli-delete-when-empty;
            presence true;
            leaf duration {
              tailf:info "Session protection duration after loss of link discovery";
              type union {
                type uint32 {
                  tailf:info "<30-2147483>;;Holdup time in seconds";
                  range "30..2147483";
                }
                type enumeration {
                  enum infinite {
                    tailf:info "Protect session forever after loss of link discovery";
                  }
                }
              }
            }
          }
        }
        container signalling {
          tailf:info "Configure signalling parameters";
          leaf dscp {
            tailf:info "Set DSCP for LDP control packets";
            type uint8 {
              tailf:info "<0-63>;;Differentiated Services Code Point (DSCP)";
              range "0..63";
            }
          }
        }
        container igp {
          tailf:info "Configure IGP related parameters";
          container sync {
            tailf:info "Configure LDP-IGP synchronization parameters";
            container delay-on-proc-restart {
              tailf:cli-drop-node-name;
              container delay {
                tailf:info "Configure sync up delay after session up";
                leaf on-proc-restart {
                  tailf:info "Global sync up delay to be used after process restart";
                  type uint16 {
                    tailf:info "<60-600>;;Global sync-up delay (seconds)";
                    range "60..600";
                  }
                }
              }
            }
            container delay {
              tailf:info "Configure sync up delay after session up";
              tailf:cli-compact-syntax;
              leaf on-session-up {
                tailf:info "Interface sync-up delay after session up";
                type empty;
              }
              leaf delay-value {
                tailf:cli-drop-node-name;
                type uint16 {
                  tailf:info "<5-300>;;Interface sync-up delay (seconds)";
                  range "5..300";
                }
              }
            }
          }
        }
        container mldp {
          tailf:cli-add-mode;
          tailf:cli-mode-name config-ldp-mldp;
          container logging {
            tailf:info "MLDP logging commands";
            leaf notifications {
              tailf:info "MLDP logging notifications";
              type empty;
            }
            leaf internal {
              tailf:info "MLDP logging internal(cisco-support)";
              type empty;
            }
          }
          container address-family {
            tailf:info "Configure Address Family and its parameters";
            container ipv4 {
              tailf:info IPv4;
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ldp-mldp-af;
              container make-before-break {
                tailf:info "Make Before Break";
                leaf delay {
                  tailf:info "MBB delay";
                  type uint8 {
                    tailf:info "<0-60>;;Delete delay in seconds";
                    range "0..60";
                  }
                }
              }
              container recursive-fec {
                tailf:info "MLDP Recursive FEC support";
                presence true;
              }
            }
          }
        }
        container discovery {
          tailf:info "Configure discovery parameters";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-ldp-disc;
          container instance-tlv {
            tailf:info "Control support for Neighbor instance TLV in Hello messages";
            leaf disable {
              tailf:info "Disable transmit and receive processing for TLV";
              tailf:cli-full-command;
              type empty;
            }
          }
          container hello {
            tailf:info "LDP Link Hellos";
            leaf holdtime {
              tailf:info "Hello holdtime";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds) - 65535 implies infinite";
                range "1..65535";
              }
            }
            leaf interval {
              tailf:info "Hello interval";
              tailf:cli-full-command;
              type uint16 {
                tailf:info "<1-65535>;;Time (seconds)";
                range "1..65535";
              }
            }
          }
          container targeted-hello {
            tailf:info "LDP Targeted Hellos";
            container accept {
              tailf:info "Accept and respond to targeted hellos";
              tailf:cli-delete-when-empty;
              tailf:cli-reset-container;
              presence true;
              leaf from {
                tailf:info "IP Access list to specify acceptable targeted hello sources";
                type string {
                  tailf:info "WORD;;access-list";
                }
              }
            }
          }
        }
        leaf router-id {
          tailf:info "Configure router Id";
          tailf:cli-full-command;
          type inet:ipv4-address {
            tailf:info "A.B.C.D;;IP address to be used";
          }
        }
        container neighbor {
          tailf:info "Configure neighbor parameters";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-ldp-nbr;
          tailf:meta-data secret-add-mode;
          container password {
            tailf:info "Configure password for MD5 authentication for all neighbors";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum clear {
                  tailf:info "Specifies an UNENCRYPTED password will follow";
                }
                enum encrypted {
                  tailf:info "Specifies an ENCRYPTED password will follow";
                }
              }
            }
            leaf password {
              tailf:cli-drop-node-name;
              tailf:cli-reset-container;
              tailf:meta-data secret-password;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
              }
            }
          }
          list neighbor-list {
            tailf:cli-drop-node-name;
            tailf:cli-suppress-mode;
            tailf:cli-delete-when-empty;
            tailf:cli-compact-syntax;
            tailf:meta-data secret-drop-node-name;
            key id;
            leaf id {
              type union {
                type inet:ipv4-address {
                  tailf:info "A.B.C.D;;DEPRECATED - LSR Id of neighbor";
                }
                type string {
                  tailf:info "A.B.C.D:;;LDP Id of neighbor";
                }
              }
            }
            container password {
              tailf:info "Configure password for MD5 authentication";
              choice password-choice {
                leaf disable {
                  tailf:info "Disables the global password from this neighbor";
                  type empty;
                }
                leaf clear {
                  tailf:info "Specifies an UNENCRYPTED password will follow";
                  tailf:meta-data secret-password;
                  type string {
                    tailf:info "LINE;;The UNENCRYPTED (cleartext) neighbor password";
                  }
                }
                leaf encrypted {
                  tailf:info "Specifies an encrypted password will follow";
                  type string {
                    tailf:info "WORD;;The ENCRYPTED neighbor password string";
                  }
                }
              }
            }
          }
        }
        container redistribute {
          tailf:cli-add-mode;
          container bgp {
            tailf:cli-add-mode;
            leaf as {
              type uint32;
            }
          }
        }
        container password {
          tailf:info "Configure LDP MD5 password";
          container option {
            tailf:info "LDP password options";
            tailf:cli-compact-syntax;
            tailf:cli-sequence-commands;
            leaf sequence-nr {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type uint16 {
                tailf:info "<1-32767>;;Sequence number of the LDP password option";
                range "1..32767";
              }
            }
            leaf for {
              tailf:info "IP access-list specifying control on LDP peers";
              tailf:cli-incomplete-command;
              type string {
                tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
              }
            }
            leaf enc-type {
              tailf:cli-drop-node-name;
              tailf:cli-incomplete-command;
              type enumeration {
                enum 0 {
                  tailf:info "Specifies an UNENCRYPTED password will follow";
                }
                enum 7 {
                  tailf:info "Specifies a HIDDEN password will follow";
                }
              }
            }
            leaf password {
              tailf:cli-drop-node-name;
              type string {
                tailf:info "LINE;;The UNENCRYPTED (cleartext) password";
              }
            }
          }
          container required {
            tailf:info "MD5 password is required for the peer";
            tailf:cli-reset-container;
            presence true;
            leaf for {
              tailf:info "IP access-list specifying control on LDP peers";
              type string {
                tailf:info "WORD;;IP standard access-list for LDP peers; name or number (1-99)";
              }
            }
          }
        }
        container label {
          tailf:info "Configure label allocation, advertisement, and acceptance";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-ldp-lbl;
          container allocate {
            tailf:info "Configure label allocation control";
            leaf for {
              tailf:info "Limit label allocation to a set of prefixes";
              type string {
                tailf:info "WORD;;IP access-list";
              }
            }
          }
          container advertise {
            tailf:info "Configure outbound label advertisement control";
            tailf:cli-add-mode;
            tailf:cli-mode-name config-ldp-lbl-advt;
            leaf disable {
              tailf:info "Disable label advertisement to all peers for all prefixes";
              tailf:cli-full-command;
              type empty;
            }
            leaf for {
              tailf:info "Prefix centric outbound label filtering";
              tailf:cli-full-command;
              type string {
                tailf:info "WORD;;IP access-list name or number (1-99)";
              }
            }
          }
        }
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          container ipv4 {
            tailf:info IPv4;
            tailf:cli-add-mode;
            tailf:cli-mode-name config-ldp-af;
            container discovery {
              tailf:info "Configure discovery parameters";
              container targeted-hello {
                tailf:info "LDP Targeted Hellos";
                container accept {
                  tailf:info "Accept and respond to targeted hellos";
                  tailf:cli-delete-when-empty;
                  tailf:cli-reset-container;
                  presence true;
                  leaf from {
                    tailf:info "IP Access list to specify acceptable targeted hello sources";
                    type string {
                      tailf:info "WORD;;access-list";
                    }
                  }
                }
              }
            }
            container label {
              tailf:info "Configure label control and policies";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ldp-af-lbl;
              container local {
                tailf:info "Configure local label control and policies";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-ldp-af-lbl-lcl;
                container allocate {
                  tailf:info "Configure label allocation control";
                  leaf for {
                    tailf:info "Limit label allocation to a set of prefixes";
                    type union {
                      type string {
                        tailf:info "WORD;;IP access-list";
                      }
                      type enumeration {
                        enum host-routes {
                          tailf:info "Allocate label for host routes only";
                        }
                      }
                    }
                  }
                }
                container advertise {
                  tailf:info "Configure outbound label advertisement control";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-ldp-af-lbl-lcl-advt;
                  container explicit-null {
                    tailf:info "Configure explicit-null advertisement";
                    tailf:cli-compact-syntax;
                    tailf:cli-delete-when-empty;
                    presence true;
                    leaf for {
                      tailf:info "IP Access-list specifying controls on destination prefixes";
                      type string {
                        tailf:info "WORD;;IP access-list";
                      }
                    }
                    leaf to {
                      tailf:info "IP Access-list specifying controls on LDP Peers";
                      type string {
                        tailf:info "WORD;;IPv4 access-list (specify peer LSR Ids)";
                      }
                    }
                  }
                  leaf disable {
                    tailf:info "Disable label advertisement to all peers for all prefixes";
                    type empty;
                  }
                  list for {
                    tailf:info "Prefix centric outbound label filtering";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key acl;
                    leaf acl {
                      tailf:info "WORD;;IP access-list";
                      type string {
                        tailf:info "WORD;;IP access-list";
                      }
                    }
                  }
                }
              }
            }
            container traffic-eng {
              tailf:info "Configure LDP parameters for MPLS Traffic-Engineering (TE)";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ldp-af-te;
              container auto-tunnel {
                tailf:info "Configure LDP TE auto-tunnel related parameters";
                container mesh {
                  tailf:info "Configure TE auto-tunnel mesh groups";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-ldp-af-te-mesh;
                  list group {
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    key id;
                    leaf id {
                      type union {
                        type enumeration {
                          enum all {
                            tailf:info "Enable LDP on all TE meshgroup interfaces";
                          }
                        }
                        type uint32 {
                          tailf:info "<0-4294967295>;;The TE mesh group ID on which to enable LDP";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        list interface {
          tailf:info "Enable LDP on an interface and enter interface submode";
          tailf:cli-mode-name config-ldp-if;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          container address-family {
            tailf:info "Configure Address Family and its parameters";
            container ipv4 {
              tailf:info IPv4;
              tailf:cli-add-mode;
              tailf:cli-mode-name config-ldp-if-af;
              container mldp {
                tailf:info "Configure mLDP parameters";
                leaf disable {
                  tailf:info "Disable mLDP on LDP enabled interface";
                  type empty;
                }
              }
            }
          }
        }
      }
      container oam {
        tailf:info "OAM configuration";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-oam;
        container echo {
          tailf:info "Echo request attributes";
          leaf revision {
            tailf:info "Echo packet default revision";
            type enumeration {
              enum 1 {
                tailf:info "draft-ietf-mpls-lsp-ping-03 (initial)";
              }
              enum 2 {
                tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 1)";
              }
              enum 3 {
                tailf:info "draft-ietf-mpls-lsp-ping-03 (rev 2)";
              }
              enum 4 {
                tailf:info "draft-ietf-mpls-lsp-ping-09 (initial)";
              }
            }
          }
          leaf disable-vendor-extension {
            tailf:info "Disable sending vendor extension TLV with echo req";
            tailf:cli-full-command;
            type empty;
          }
        }
      }
      container static {
        tailf:info "Configure static MPLS forwarding";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-mpls-static;
        list ipv4 {
          tailf:info "Configure MPLS static IPv4 imposition";
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          tailf:cli-compact-syntax;
          tailf:cli-sequence-commands {
            tailf:cli-reset-all-siblings;
          }
          tailf:cli-incomplete-command;
          key "address mask interface";
          leaf address {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address";
            }
          }
          leaf mask {
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 mask";
            }
          }
          leaf interface {
            type string {
              tailf:info "WORD;;Interface Name";
            }
          }
          leaf nexthop {
            tailf:cli-drop-node-name;
            tailf:cli-optional-in-sequence;
            tailf:cli-incomplete-command;
            type inet:ipv4-address {
              tailf:info "A.B.C.D;;IPv4 address of next hop router";
            }
          }
          choice label-choice {
            leaf label {
              tailf:cli-drop-node-name;
              type uint32 {
                tailf:info "<16-1048575>;;Outgoing label";
              }
            }
            leaf ipv4-explicit-null {
              tailf:info "IPv4 explicit null";
              type empty;
            }
            leaf ipv6-explicit-null {
              tailf:info "IPv6 explicit null";
              type empty;
            }
            container pop {
              tailf:cli-compact-syntax;
              tailf:info "Pop label";
              presence true;
              choice pop-choice {
                leaf labelled {
                  tailf:info "Pop label to MPLS only";
                  type empty;
                }
                leaf unlabelled {
                  tailf:info "Pop label to non-MPLS only";
                  type empty;
                }
              }
            }
          }
        }
        list interface {
          tailf:info "Enable MPLS Static on an interface";
          key name;
          tailf:cli-suppress-mode;
          tailf:cli-delete-when-empty;
          leaf name {
            type ifname;
          }
        }
        container address-family {
          tailf:info "Configure Address Family and its parameters";
          list ipv4 {
            tailf:info "Configure IPv4 Address Family parameters";
            tailf:cli-mode-name config-mpls-static-af;
            tailf:cli-full-command;
            key af-modifier;
            leaf af-modifier {
              type enumeration {
                enum unicast {
                  tailf:code-name ipv4_unicast;
                  tailf:info Unicast;
                }
              }
            }
            list local-label {
              tailf:info "Configure local label assignment and forwarding";
              tailf:cli-mode-name config-mpls-static-af-lbl;
              tailf:cli-incomplete-command;
              tailf:cli-sequence-commands {
                tailf:cli-reset-siblings;
              }
              key id;
              leaf id {
                tailf:cli-suppress-range;
                type uint32 {
                  tailf:info "<16-1048575>;;Label value";
                  range "16..1048575";
                }
              }
              leaf allocate {
                tailf:info "Label Allocation Option";
                tailf:cli-hide-in-submode;
                type empty;
              }
              leaf per-prefix {
                tailf:info "For a given prefix";
                tailf:cli-hide-in-submode;
                tailf:cli-optional-in-sequence;
                type ipv4-prefix {
                  tailf:info "A.B.C.D/length;;IPv4 Prefix";
                }
              }
              container forward {
                tailf:cli-break-sequence-commands;
                tailf:info "Configure forwarding rewrites";
                tailf:cli-add-mode;
                tailf:cli-mode-name config-mpls-static-af-lbl-fwd;
                list path {
                  tailf:info "Configure cross-connect path parameters";
                  tailf:cli-suppress-mode;
                  tailf:cli-delete-when-empty;
                  tailf:cli-compact-syntax;
                  tailf:cli-sequence-commands {
                    tailf:cli-reset-siblings;
                  }
                  tailf:cli-incomplete-command;
                  key id;
                  leaf id {
                    type uint16 {
                      tailf:info "<1-1>;;Path count";
                    }
                  }
                  leaf nexthop {
                    tailf:info nexthop;
                    tailf:cli-incomplete-command;
                    type ifname;
                  }
                  leaf nexthop-address {
                    tailf:cli-optional-in-sequence;
                    tailf:cli-incomplete-command;
                    tailf:cli-drop-node-name;
                    type inet:ipv4-address {
                      tailf:info "A.B.C.D;;Next-hop IPv4 address";
                    }
                  }
                  leaf out-label {
                    tailf:info "output label";
                    type union {
                      type uint32 {
                        tailf:info "<16-1048575>;;Output MPLS label value";
                        range "16..1048575";
                      }
                      type enumeration {
                        enum exp-null {
                          tailf:info "Set the output label to explicit null";
                        }
                        enum pop {
                          tailf:info "Pop off the top of the label stack";
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        list vrf {
          tailf:info "Configure VRF parameters";
          tailf:cli-mode-name config-mpls-static-vrf;
          key name;
          leaf name {
            type string {
              tailf:info "WORD;;Specify the VRF Name";
            }
          }
          container address-family {
            tailf:info "Configure Address Family and its parameters";
            list ipv4 {
              tailf:info "Configure IPv4 Address Family parameters";
              tailf:cli-mode-name config-mpls-static-vrf-af;
              tailf:cli-full-command;
              key af-modifier;
              leaf af-modifier {
                type enumeration {
                  enum unicast {
                    tailf:code-name mpls_static_vrf_ipv4_unicast;
                    tailf:info Unicast;
                  }
                }
              }
              list local-label {
                tailf:info "Configure local label assignment and forwarding";
                tailf:cli-mode-name config-mpls-static-vrf-af-lbl;
                tailf:cli-incomplete-command;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                key id;
                leaf id {
                  tailf:cli-suppress-range;
                  type uint32 {
                    tailf:info "<16-1048575>;;Label value";
                    range "16..1048575";
                  }
                }
                leaf allocate {
                  tailf:info "Label Allocation Option";
                  tailf:cli-incomplete-command;
                  tailf:cli-hide-in-submode;
                  type empty;
                }
                choice allocate-choice {
                  leaf per-prefix {
                    tailf:info "For a given prefix";
                    tailf:cli-hide-in-submode;
                    tailf:cli-optional-in-sequence;
                    type ipv4-prefix {
                      tailf:info "A.B.C.D/length;;IPv4 Prefix";
                    }
                  }
                  leaf per-vrf {
                    tailf:info "For a VRF";
                    tailf:cli-hide-in-submode;
                    type empty;
                  }
                }
                container forward {
                  when "../per-vrf" {
                    tailf:xpath-root 3;
                  }
                  tailf:cli-break-sequence-commands;
                  tailf:info "Configure forwarding rewrites";
                  tailf:cli-add-mode;
                  tailf:cli-mode-name config-mpls-static-vrf-af-lbl-fwd;
                  list path {
                    tailf:info "Configure cross-connect path parameters";
                    tailf:cli-suppress-mode;
                    tailf:cli-delete-when-empty;
                    tailf:cli-incomplete-command;
                    key id;
                    leaf id {
                      tailf:cli-suppress-range;
                      type uint8 {
                        tailf:info "<1-1>;;Path count";
                      }
                    }
                    leaf pop-and-lookup {
                      tailf:info "Pop and lookup";
                      type empty;
                    }
                  }
                }
              }
            }
          }
        }
      }
      container ip-ttl-propagate {
        tailf:info "Propagate IP TTL into the label stack";
        container disable {
          tailf:info "Disable IP TTL propagation";
          tailf:cli-delete-when-empty;
          tailf:cli-reset-container;
          presence true;
          leaf disable-type {
            tailf:cli-drop-node-name;
            type enumeration {
              enum forwarded {
                tailf:info "Disable IP TTL propagation for only forwarded MPLS packets";
              }
              enum local {
                tailf:info "Disable IP TTL propagation for only locally generated MPLS packets";
              }
            }
          }
        }
      }
    }
    container segment-routing {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Segment Routing";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-sr;
      container global-block {
        tailf:info "Prefix-SID Global label Block (SRGB)";
        tailf:cli-compact-syntax;
        tailf:cli-sequence-commands {
          tailf:cli-reset-siblings;
        }
        leaf lower-bound {
          tailf:cli-drop-node-name;
          tailf:cli-incomplete-command;
          type uint32 {
            tailf:info "<16000-1048574>;;The lower bound of the SRGB";
            range "16000..1048574";
          }
        }
        leaf upper-bound {
          tailf:cli-drop-node-name;
          type uint32 {
            tailf:info "<16001-1048575>;;The upper bound of the SRGB";
            range "16001..1048575";
          }
        }
      }
      container mapping-server {
        tailf:info "Segment Routing Mapping Server (SRMS)";
        tailf:cli-add-mode;
        tailf:cli-mode-name config-sr-sm;
        container prefix-sid-map {
          tailf:info "Prefix SID Map";
          tailf:cli-add-mode;
          tailf:cli-mode-name config-sr-sm-map;
          container address-family {
            tailf:info "Address Family";
            container ipv4 {
              tailf:info "IP version 4";
              tailf:cli-add-mode;
              tailf:cli-mode-name config-sr-sm-map-af;
              list prefix {
                tailf:cli-drop-node-name;
                tailf:cli-suppress-mode;
                tailf:cli-delete-when-empty;
                tailf:cli-compact-syntax;
                tailf:cli-sequence-commands {
                  tailf:cli-reset-siblings;
                }
                tailf:cli-incomplete-command;
                key prefix;
                leaf prefix {
                  type inet:ipv4-prefix {
                    tailf:info "A.B.C.D/length;;IPv4 address with prefix";
                  }
                }
                leaf SID-interval {
                  tailf:cli-drop-node-name;
                  type uint32 {
                    tailf:info "<0-1048575>;;Start of SID index range";
                    range "0..1048575";
                  }
                }
                leaf range {
                  tailf:info "Number of allocated SIDs";
                  type uint32 {
                    tailf:info "<0-1048575>;;Number of allocated SIDs";
                    range "0..1048575";
                  }
                }
              }
            }
          }
        }
      }
    }
    container multicast-routing {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Enable IP multicast forwarding";
      tailf:cli-add-mode;
      tailf:cli-mode-name config-mcast;
      tailf:cli-explicit-exit;
      uses multicast-routing-grouping;
      list vrf {
        tailf:info "VRF configs";
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Enter VRF name";
          }
        }
        uses multicast-routing-grouping;
      }
    }
    container alias {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Create an alias for entity";
      list alias-list {
        tailf:cli-drop-node-name;
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          tailf:cli-disallow-value exec|config;
          type string {
            tailf:info "WORD;;Alias name";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Alias body with optional parameters e.g,(name) show $name";
          }
        }
      }
      list exec {
        tailf:info "Exec command alias";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Exec Alias name";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Aliased exec command";
          }
        }
      }
      list config {
        tailf:info "Config command alias";
        tailf:cli-suppress-mode;
        tailf:cli-delete-when-empty;
        tailf:cli-incomplete-command;
        key name;
        leaf name {
          type string {
            tailf:info "WORD;;Config Alias name";
          }
        }
        leaf line {
          tailf:cli-drop-node-name;
          tailf:cli-multi-value;
          tailf:cli-preformatted;
          tailf:cli-no-value-on-delete;
          tailf:cli-full-command;
          type string {
            tailf:info "LINE;;Aliased config command";
          }
        }
      }
    }
    container cached-show {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      container version {
        leaf version {
          type string;
        }
        leaf model {
          type string;
        }
      }
    }
    leaf xyzroot {
      tailf:ncs-device-type cli-ned;
      tailf:display-when "not(../../ncs:module) or ../../ncs:module[ncs:name='tailf-ned-cisco-ios-xr']";
      tailf:info "Internal state variable, do not modify.";
      tailf:cli-run-template "";
      tailf:cli-show-with-default;
      type uint16;
      default 0;
    }
  }
  augment "/ncs:devices/ncs:template/ncs:config" {
    container admin {
      uses ncs_template_username-grouping;
      container fpd {
        leaf auto-upgrade {
          type empty;
        }
      }
      container hw-module {
        container profile {
          leaf scale {
            type string;
          }
        }
        container bfd-hw-offload {
          container enable {
            leaf location {
              type string;
            }
          }
        }
      }
      uses ncs_template_clock-grouping;
      uses ncs_template_exception-grouping;
      container diagnostic {
        container bootup {
          leaf level {
            type string;
          }
          leaf location {
            type string;
          }
        }
        container monitor {
          leaf syslog {
            type empty;
          }
        }
      }
      leaf xyzroot {
        type string;
        // NCS drop default statement
      }
    }
    leaf version {
      type string;
    }
    container configuration {
      container display {
        container interface {
          leaf slot-order {
            type empty;
          }
        }
      }
    }
    leaf hostname {
      type string;
    }
    list group {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf mtu {
          type string;
        }
      }
    }
    leaf apply-group {
      type string;
    }
    uses ncs_template_clock-grouping;
    container banner {
      container exec {
        uses ncs_template_banner-grouping;
      }
      container incoming {
        uses ncs_template_banner-grouping;
      }
      container motd {
        uses ncs_template_banner-grouping;
      }
      container login {
        uses ncs_template_banner-grouping;
      }
      container slip-ppp {
        uses ncs_template_banner-grouping;
      }
      container prompt-timeout {
        uses ncs_template_banner-grouping;
      }
    }
    uses ncs_template_exception-grouping;
    container cef {
      container load-balancing {
        leaf fields {
          type string;
        }
      }
    }
    container explicit-path {
      list name {
        // NCS patched for predictable order
        ordered-by user;
        key pathname;
        leaf pathname {
          type string;
        }
        uses ncs_template_explicit-path-index-list-grouping;
      }
      list identifier {
        // NCS patched for predictable order
        ordered-by user;
        key identifier;
        leaf identifier {
          type string;
        }
        uses ncs_template_explicit-path-index-list-grouping;
      }
    }
    container selective-vrf-download {
      leaf disable {
        type empty;
      }
    }
    container vrf {
      list vrf-list {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf description {
          type string;
        }
        leaf rd {
          type string;
        }
        container vpn {
          leaf id {
            type string;
          }
        }
        container address-family {
          container ipv4 {
            container unicast {
              presence true;
              uses ncs_template_vrf-af-ipv4-grouping;
            }
            container flowspec {
              presence true;
              uses ncs_template_vrf-af-ipv4-grouping;
            }
          }
          container ipv6 {
            container unicast {
              presence true;
              container import {
                leaf route-policy {
                  type string;
                }
                container route-target {
                  uses ncs_template_vrf-route-target-grouping;
                }
              }
              container export {
                leaf route-policy {
                  type string;
                }
                container route-target {
                  uses ncs_template_vrf-route-target-grouping;
                }
              }
              container maximum {
                container prefix {
                  leaf limit {
                    type string;
                  }
                  leaf mid-thresh {
                    type string;
                  }
                }
              }
            }
          }
        }
      }
    }
    container ethernet {
      container sla {
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf type {
            type string;
          }
          container probe {
            container send {
              leaf type {
                type string;
              }
              leaf every {
                type string;
              }
              leaf every-time {
                type string;
              }
            }
            leaf priority {
              type string;
            }
          }
          container schedule {
            container every {
              leaf number {
                type string;
              }
              leaf every-time {
                type string;
              }
              leaf for {
                type string;
              }
              leaf for-time {
                type string;
              }
            }
          }
          container statistics {
            list measure {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              container aggregate {
                choice aggregate-choice {
                  case none {
                    leaf none {
                      type empty;
                    }
                  }
                  case bins-width {
                    leaf bins {
                      type string;
                    }
                    leaf width {
                      type string;
                    }
                  }
                }
              }
              container buckets {
                container size {
                  leaf number {
                    type string;
                  }
                  leaf probes {
                    type empty;
                  }
                }
                leaf archive {
                  type string;
                }
              }
            }
          }
        }
      }
      container cfm {
        container traceroute {
          container cache {
            leaf hold-time {
              type string;
            }
            leaf size {
              type string;
            }
          }
        }
        list domain {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf level {
            type string;
          }
          container id {
            choice id-choice {
              leaf null {
                type empty;
              }
              leaf string {
                type string;
              }
            }
          }
          list service {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            choice service-type {
              container bridge {
                leaf group {
                  type string;
                }
                leaf bridge-domain {
                  type string;
                }
              }
              container xconnect {
                leaf group {
                  type string;
                }
                leaf p2p {
                  type string;
                }
              }
              container down-meps {
                presence true;
              }
            }
            container continuity-check {
              container interval {
                leaf value {
                  type string;
                }
                leaf loss-threshold {
                  type string;
                }
              }
              container archive {
                leaf hold-time {
                  type string;
                }
              }
              container loss {
                leaf auto-traceroute {
                  type empty;
                }
              }
            }
            container log {
              container continuity-check {
                leaf errors {
                  type empty;
                }
                container mep {
                  leaf changes {
                    type empty;
                  }
                }
              }
              leaf ais {
                type empty;
              }
              container crosscheck {
                leaf errors {
                  type empty;
                }
              }
            }
            container mip {
              container auto-create {
                leaf all {
                  type empty;
                }
              }
            }
            container mep {
              container crosscheck {
                list mep-id {
                  // NCS patched for predictable order
                  ordered-by user;
                  key id;
                  leaf id {
                    type string;
                  }
                  leaf mac-address {
                    type string;
                  }
                }
              }
            }
            container efd {
              presence true;
            }
          }
        }
      }
      container oam {
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf hello-interval {
            type string;
          }
          container link-monitor {
            container frame {
              leaf window {
                type string;
              }
              container threshold {
                leaf low {
                  type string;
                }
                leaf high {
                  type string;
                }
              }
            }
          }
          container require-remote {
            leaf link-monitoring {
              type empty;
            }
          }
          container action {
            leaf high-threshold {
              type string;
            }
          }
        }
      }
    }
    container logging {
      leaf disable {
        type empty;
      }
      leaf trap {
        type string;
      }
      container events {
        leaf level {
          type string;
        }
        leaf link-status {
          type string;
        }
        leaf threshold {
          type string;
        }
      }
      container archive {
        leaf device {
          type string;
        }
        leaf severity {
          type string;
        }
        leaf file-size {
          type string;
        }
        leaf frequency {
          type string;
        }
        leaf archive-size {
          type string;
        }
        leaf archive-length {
          type string;
        }
      }
      leaf monitor {
        type string;
      }
      container buffered {
        leaf type {
          type string;
        }
      }
      leaf facility {
        type string;
      }
      list host {
        // NCS patched for predictable order
        ordered-by user;
        key address;
        leaf address {
          type string;
        }
        leaf vrf {
          type string;
        }
        leaf severity {
          type string;
        }
        leaf port {
          type string;
        }
      }
      leaf localfilesize {
        type string;
      }
      container source-interface {
        uses ncs_template_interface-name-grouping;
      }
      container cns-events {
        presence true;
        leaf severity {
          type string;
        }
      }
      leaf console {
        type string;
      }
      leaf count {
        type empty;
      }
      leaf history {
        type string;
      }
      container suppress {
        leaf duplicates {
          type empty;
        }
        list rule {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          list alarm {
            // NCS patched for predictable order
            ordered-by user;
            key "msg-category group-name msg-code";
            leaf msg-category {
              type string;
            }
            leaf group-name {
              type string;
            }
            leaf msg-code {
              type string;
            }
          }
        }
        container apply {
          list rule {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf all-of-router {
              type empty;
            }
            container source {
              leaf location {
                type string;
              }
            }
          }
        }
      }
      leaf hostnameprefix {
        type string;
      }
    }
    container service {
      container alignment {
        leaf detection {
          type empty;
        }
        leaf logging {
          type empty;
        }
      }
      leaf call-home {
        type empty;
      }
      leaf compress-config {
        type empty;
      }
      container counters {
        container max {
          leaf age {
            type string;
          }
        }
      }
      leaf dhcp {
        type empty;
      }
      leaf disable-ip-fast-frag {
        type empty;
      }
      leaf exec-callback {
        type empty;
      }
      leaf exec-wait {
        type empty;
      }
      leaf finger {
        type empty;
      }
      container heartbeat {
        leaf fatal-count {
          type string;
        }
        leaf interrupt-interval {
          type string;
        }
        leaf interrupt-max {
          type string;
        }
        leaf transmit-interval {
          type string;
        }
        leaf warning-timeout {
          type string;
        }
      }
      leaf hide-telnet-addresses {
        type empty;
      }
      leaf linenumber {
        type empty;
      }
      leaf nagle {
        type empty;
      }
      leaf old-slip-prompts {
        type empty;
      }
      container pad {
        presence true;
        leaf cmns {
          type empty;
        }
        leaf from-xot {
          type empty;
        }
        leaf to-xot {
          type empty;
        }
      }
      leaf password-encryption {
        type empty;
      }
      container prompt {
        leaf config {
          type empty;
        }
      }
      leaf pt-vty-logging {
        type empty;
      }
      leaf sequence-numbers {
        type empty;
      }
      leaf slave-log {
        type empty;
      }
      leaf tcp-keepalives-in {
        type empty;
      }
      leaf tcp-keepalives-out {
        type empty;
      }
      container tcp-small-servers {
        presence true;
        leaf max-servers {
          type string;
        }
      }
      leaf telnet-zeroidle {
        type empty;
      }
      container timestamps {
        presence true;
        container debug {
          choice log-time-choice {
            container datetime {
              presence true;
              leaf localtime {
                type empty;
              }
              leaf msec {
                type empty;
              }
              leaf show-timezone {
                type empty;
              }
              leaf year {
                type empty;
              }
            }
            leaf uptime {
              type empty;
            }
          }
        }
        container log {
          choice log-time-choice {
            container datetime {
              presence true;
              leaf localtime {
                type empty;
              }
              leaf msec {
                type empty;
              }
              leaf show-timezone {
                type empty;
              }
              leaf year {
                type empty;
              }
            }
            leaf uptime {
              type empty;
            }
          }
        }
      }
      container udp-small-servers {
        presence true;
        leaf max-servers {
          type string;
        }
      }
      leaf unsupported-transceiver {
        type empty;
      }
    }
    container event {
      container manager {
        container directory {
          container user {
            leaf policy {
              type string;
            }
            leaf library {
              type string;
            }
          }
        }
        list policy {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf username {
            type string;
          }
          leaf persist-time {
            type string;
          }
          leaf type {
            type string;
          }
        }
        list environment {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf var-value {
            type string;
          }
        }
      }
    }
    container domain {
      container ipv4 {
        list host {
          // NCS patched for predictable order
          ordered-by user;
          key host-name;
          leaf host-name {
            type string;
          }
          leaf-list address {
            // NCS patched for predictable order
            ordered-by user;
            // NCS drop max-elements statement
            type string;
          }
        }
      }
      container ipv6 {
        list host {
          // NCS patched for predictable order
          ordered-by user;
          key host-name;
          leaf host-name {
            type string;
          }
          leaf-list address {
            // NCS patched for predictable order
            ordered-by user;
            // NCS drop max-elements statement
            type string;
          }
        }
      }
      container lookup {
        leaf disable {
          type empty;
        }
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
      }
      leaf name {
        type string;
      }
      leaf list {
        type string;
      }
      list name-server {
        // NCS patched for predictable order
        ordered-by user;
        key address;
        leaf address {
          type string;
        }
      }
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf name {
          type string;
        }
        container lookup {
          leaf disable {
            type empty;
          }
        }
      }
    }
    container forward-protocol {
      container udp {
        list port-list {
          // NCS patched for predictable order
          ordered-by user;
          key port;
          leaf port {
            type string;
          }
          leaf disable {
            type empty;
          }
        }
      }
    }
    list taskgroup {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      container task {
        list execute {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        list read {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        list write {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        list debug {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      container inherit {
        list taskgroup {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      leaf description {
        type string;
      }
    }
    container radius {
      container source-interface {
        uses ncs_template_interface-name-grouping;
        leaf vrf {
          type string;
        }
      }
    }
    container radius-server {
      list host {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf auth-port {
          type string;
        }
        leaf acct-port {
          type string;
        }
        container key {
          uses ncs_template_key-grouping;
        }
        leaf timeout {
          type string;
        }
        leaf retransmit {
          type string;
        }
      }
      container key {
        uses ncs_template_key-grouping;
      }
      leaf timeout {
        type string;
      }
      leaf retransmit {
        type string;
      }
    }
    list usergroup {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf-list taskgroup {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
      leaf description {
        type string;
      }
    }
    container xnetconf {
      tailf:alt-name netconf;
      container agent {
        container tty {
          container session {
            leaf timeout {
              type string;
            }
          }
          container throttle {
            leaf memory {
              type string;
            }
            leaf process-rate {
              type string;
            }
          }
        }
        leaf ssh {
          type empty;
        }
      }
    }
    container network-controller {
      presence true;
      container anycast-gateway {
        leaf mac {
          type string;
        }
      }
      leaf standby {
        type empty;
      }
      leaf dhcp-server {
        type string;
      }
      list switch {
        // NCS patched for predictable order
        ordered-by user;
        key "mac ip-address";
        leaf mac {
          type string;
        }
        leaf ip-address {
          type string;
        }
      }
    }
    container netconf-yang {
      container agent {
        presence true;
        leaf ssh {
          type empty;
        }
      }
    }
    container nsr {
      leaf process-failures {
        type string;
      }
    }
    container ftp {
      container client {
        leaf passive {
          type empty;
        }
        container password {
          leaf password {
            type string;
          }
          leaf clear {
            type string;
          }
          leaf encrypted {
            type string;
          }
        }
        leaf username {
          type string;
        }
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container source-interface {
            uses ncs_template_interface-name-grouping;
          }
        }
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
      }
    }
    container icmp {
      container ipv4 {
        container source {
          leaf rfc {
            type empty;
          }
          leaf vrf {
            type empty;
          }
        }
        container rate-limit {
          container unreachable {
            leaf DF {
              type string;
            }
            leaf milliseconds {
              type string;
            }
          }
        }
      }
    }
    container ntp {
      leaf max-associations {
        type string;
      }
      container server {
        uses ncs_template_ntp-server-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_ntp-server-grouping;
        }
      }
      list access-group {
        // NCS patched for predictable order
        ordered-by user;
        key "type name";
        leaf type {
          type string;
        }
        leaf name {
          type string;
        }
        leaf vrf {
          type string;
        }
        leaf version {
          type string;
        }
      }
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container broadcast {
          presence true;
          leaf version {
            type string;
          }
        }
      }
      leaf master {
        type string;
      }
      container source {
        uses ncs_template_interface-name-grouping;
      }
      leaf update-calendar {
        type empty;
      }
      list authentication-key {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        container md5 {
          choice md5-choice {
            leaf key {
              type string;
            }
            leaf clear {
              type string;
            }
            leaf encrypted {
              type string;
            }
          }
        }
      }
      leaf authenticate {
        type empty;
      }
      leaf-list trusted-key {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container rcp {
      container client {
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
      }
    }
    container telnet {
      container ipv4 {
        container client {
          container source-interface {
            uses ncs_template_interface-name-grouping;
          }
        }
      }
      container ipv6 {
        container client {
          container source-interface {
            uses ncs_template_interface-name-grouping;
          }
        }
      }
      uses ncs_template_telnet-server-grouping;
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_telnet-server-grouping;
      }
    }
    container bfd {
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf echo {
          type empty;
        }
        container echo-conf {
          container echo {
            leaf disable {
              type empty;
            }
            container ipv4 {
              leaf source {
                type string;
              }
            }
          }
        }
      }
      container multihop {
        leaf ttl-drop-threshold {
          type string;
        }
      }
      container multipath {
        container include {
          list location {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
          }
        }
      }
      container echo {
        leaf disable {
          type empty;
        }
      }
      container trap {
        container singlehop {
          leaf pre-mapped {
            type empty;
          }
        }
      }
      container dampening {
        container bundle-member {
          leaf l3-only-mode {
            type empty;
          }
        }
      }
    }
    container sbfd {
      container remote-target {
        list ipv4 {
          // NCS patched for predictable order
          ordered-by user;
          key address;
          leaf address {
            type string;
          }
          leaf remote-discriminator {
            type string;
          }
        }
      }
      container local-discriminator {
        list address-list {
          // NCS patched for predictable order
          ordered-by user;
          key ipv4;
          leaf ipv4 {
            type string;
          }
        }
        list id-list {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
        }
        leaf dynamic {
          type empty;
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
    }
    container tftp {
      container client {
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container source-interface {
            uses ncs_template_interface-name-grouping;
          }
        }
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
      }
      uses ncs_template_tftp-server-grouping;
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_tftp-server-grouping;
      }
    }
    container nv {
      container optical {
        list satellite {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container ipv6 {
            leaf address {
              type string;
            }
          }
          container username {
            leaf name {
              type string;
            }
            leaf password {
              type string;
            }
          }
          container trunk {
            list slot {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf port {
                type string;
              }
              leaf local-port {
                type string;
              }
            }
          }
        }
      }
      container controller {
        uses ncs_template_controller-dwdm-grouping;
        list HundredGigE {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf admin-state {
            type string;
          }
        }
      }
      list satellite {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf type {
          type string;
        }
        container ipv4 {
          leaf address {
            type string;
          }
        }
        container redundancy {
          leaf host-priority {
            type string;
          }
        }
        leaf serial-number {
          type string;
        }
        leaf description {
          type string;
        }
        container secret {
          leaf type {
            type string;
          }
          leaf secret {
            type string;
          }
        }
      }
    }
    container enable {
      container password;
      container secret {
        leaf type {
          type string;
        }
        leaf secret {
          type string;
        }
      }
    }
    uses ncs_template_username-grouping;
    container tacacs-server {
      list host {
        // NCS patched for predictable order
        ordered-by user;
        key "name port";
        leaf name {
          type string;
        }
        leaf port {
          type string;
        }
        container key {
          leaf encryption {
            type string;
          }
          leaf key {
            type string;
          }
        }
        leaf timeout {
          type string;
        }
      }
      container key {
        leaf encryption {
          type string;
        }
        leaf key {
          type string;
        }
      }
      leaf timeout {
        type string;
      }
    }
    container tacacs {
      container source-interface {
        uses ncs_template_interface-name-grouping;
        leaf vrf {
          type string;
        }
      }
    }
    container aaa {
      leaf new-model {
        type empty;
      }
      container group {
        container server {
          list radius {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            container server {
              list name {
                // NCS patched for predictable order
                ordered-by user;
                key name;
                leaf name {
                  type string;
                }
              }
              list direct {
                // NCS patched for predictable order
                ordered-by user;
                key name;
                leaf name {
                  type string;
                }
                leaf auth-port {
                  type string;
                }
                leaf acct-port {
                  type string;
                }
              }
            }
            container ip {
              container vrf {
                leaf forwarding {
                  type string;
                }
              }
            }
          }
          list tacacs {
            // NCS patched for predictable order
            ordered-by user;
            tailf:alt-name tacacs+;
            key name;
            leaf name {
              type string;
            }
            leaf-list server {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
            leaf vrf {
              type string;
            }
          }
        }
      }
      container authentication {
        list login {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf local {
            type empty;
          }
          leaf group {
            type string;
          }
          leaf none {
            type empty;
          }
        }
      }
      container authorization {
        list commands {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf group {
            type string;
          }
          container group2 {
            // NCS drop when statement
            leaf group {
              type string;
            }
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
        list exec {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf group {
            type string;
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
        list eventmanager {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf group {
            type string;
          }
          leaf local {
            type empty;
          }
          leaf none {
            type empty;
          }
        }
      }
      container accounting {
        list exec {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf notice {
            type string;
          }
          leaf group {
            type string;
          }
          leaf none {
            type empty;
          }
        }
        list system {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf start-stop {
            type empty;
          }
          leaf group {
            type string;
          }
          leaf none {
            type empty;
          }
        }
        list network {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf notice {
            type string;
          }
          leaf group {
            type string;
          }
          leaf none {
            type empty;
          }
        }
        list commands {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf notice {
            type string;
          }
          leaf group {
            type string;
          }
          leaf none {
            type empty;
          }
        }
      }
      leaf session-id {
        type string;
      }
      leaf default-taskgroup {
        type string;
      }
    }
    container cdp {
      presence true;
      container advertise {
        leaf v1 {
          type empty;
        }
      }
      leaf timer {
        type string;
      }
      leaf holdtime {
        type string;
      }
    }
    container tcp {
      leaf mss {
        type string;
      }
      leaf selective-ack {
        type empty;
      }
      container path-mtu-discovery {
        presence true;
        leaf age-timer {
          type string;
        }
      }
      leaf timestamp {
        type empty;
      }
      container directory {
        leaf directory {
          type string;
        }
        leaf files {
          type string;
        }
        leaf size {
          type string;
        }
      }
      leaf window-size {
        type string;
      }
    }
    container line {
      container console {
        uses ncs_template_line-grouping;
      }
      container default {
        uses ncs_template_line-grouping;
      }
      list template {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_line-grouping;
      }
    }
    container pool {
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key "vrf ipv4";
        leaf vrf {
          type string;
        }
        leaf ipv4 {
          type string;
        }
        list network {
          // NCS patched for predictable order
          ordered-by user;
          key prefix;
          leaf prefix {
            type string;
          }
        }
        list address-range {
          // NCS patched for predictable order
          ordered-by user;
          key first_range;
          leaf first_range {
            type string;
          }
          leaf last_range {
            type string;
          }
        }
        container utilization-mark {
          leaf high {
            type string;
          }
          leaf low {
            type string;
          }
        }
      }
    }
    container vty-pool {
      container default {
        uses ncs_template_vty-pool-grouping;
      }
      container eem {
        uses ncs_template_vty-pool-grouping;
      }
      list pool-name-list {
        // NCS patched for predictable order
        ordered-by user;
        key pool-name;
        leaf pool-name {
          type string;
        }
        uses ncs_template_vty-pool-grouping;
      }
    }
    container aps {
      list group {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf revert {
          type string;
        }
        container timers {
          leaf hello {
            type string;
          }
          leaf hold {
            type string;
          }
        }
        list channel {
          // NCS patched for predictable order
          ordered-by user;
          key "id location";
          leaf id {
            type string;
          }
          leaf location {
            type string;
          }
          leaf preconfigure {
            type empty;
          }
          leaf data {
            type string;
          }
        }
      }
    }
    container platform {
      container ip {
        container cef {
          leaf load-sharing {
            type string;
          }
        }
      }
      container qos {
        leaf qos-10g-only {
          tailf:alt-name 10g-only;
          type empty;
        }
        list protocol {
          // NCS patched for predictable order
          ordered-by user;
          key proto;
          leaf proto {
            type string;
          }
          choice proto-choice {
            leaf pass-through {
              type empty;
            }
            container police {
              leaf bit-rate {
                type string;
              }
              leaf burst {
                type string;
              }
            }
            container precedence {
              leaf cos {
                type string;
              }
              leaf bit-rate {
                type string;
              }
              leaf burst {
                type string;
              }
            }
          }
        }
      }
    }
    container control-plane {
      container management-plane {
        container inband {
          list interface {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            list allow {
              // NCS patched for predictable order
              ordered-by user;
              key proto;
              leaf proto {
                type string;
              }
            }
            container allow-peer {
              list allow {
                // NCS patched for predictable order
                ordered-by user;
                key "proto peer";
                leaf proto {
                  type string;
                }
                leaf peer {
                  type string;
                }
                container address {
                  list ipv4 {
                    // NCS patched for predictable order
                    ordered-by user;
                    key prefix;
                    leaf prefix {
                      type string;
                    }
                  }
                  list ipv6 {
                    // NCS patched for predictable order
                    ordered-by user;
                    key prefix;
                    leaf prefix {
                      type string;
                    }
                  }
                }
              }
            }
          }
        }
        container out-of-band {
          list interface {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            list allow {
              // NCS patched for predictable order
              ordered-by user;
              key proto;
              leaf proto {
                type string;
              }
            }
            container allow-peer {
              list allow {
                // NCS patched for predictable order
                ordered-by user;
                key "proto peer";
                leaf proto {
                  type string;
                }
                leaf peer {
                  type string;
                }
                container address {
                  list ipv4 {
                    // NCS patched for predictable order
                    ordered-by user;
                    key address;
                    leaf address {
                      type string;
                    }
                  }
                  list ipv6 {
                    // NCS patched for predictable order
                    ordered-by user;
                    key prefix;
                    leaf prefix {
                      type string;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container ip {
      container domain-lookup {
        leaf do-lookup {
          type string;
          // NCS drop default statement
        }
        leaf nsap {
          type empty;
        }
      }
      leaf domain-name {
        type string;
      }
      container forward-protocol {
        leaf nd {
          type empty;
        }
        leaf sdns {
          type empty;
        }
        leaf spanning-tree {
          type empty;
        }
        leaf turbo-flood {
          type empty;
        }
        leaf udp {
          type empty;
        }
      }
      container http {
        leaf server {
          type string;
          // NCS drop default statement
        }
        leaf secure-server {
          type string;
          // NCS drop default statement
        }
      }
      container pim {
        container ssm {
          choice ssm-choice {
            leaf default {
              type empty;
            }
            leaf range {
              type string;
            }
          }
        }
      }
      container route {
        container vrf {
          leaf name {
            type string;
          }
          leaf dest {
            type string;
          }
          leaf dest-mask {
            type string;
          }
          choice vrf-choice {
            leaf forwarding-address {
              type string;
            }
            leaf GigabitEthernet {
              type string;
            }
          }
        }
      }
      container multicast-routing {
        presence true;
        leaf-list vrf {
          // NCS patched for predictable order
          ordered-by user;
          type string;
        }
      }
      container multicast {
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container route-limit {
            leaf nr-routes {
              type string;
            }
            leaf threshold {
              type string;
            }
          }
        }
      }
      container tftp {
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
      }
      container ssh {
        leaf logging {
          type string;
        }
        leaf version {
          type string;
        }
      }
    }
    container mirror {
      list location {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container ipv4 {
      container netmask-format {
        leaf bit-count {
          type empty;
        }
      }
      container assembler {
        leaf max-packets {
          type string;
        }
        leaf timeout {
          type string;
        }
      }
      container access-list {
        list named-acl {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          list rule {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            leaf line {
              type string;
            }
          }
        }
      }
      container unnumbered {
        container mpls {
          container traffic-eng {
            uses ncs_template_interface-name-grouping;
          }
        }
      }
      container virtual {
        container address-src {
          container address {
            leaf use-as-src-addr {
              type empty;
            }
          }
        }
        container address {
          list address-list {
            // NCS patched for predictable order
            ordered-by user;
            key "address mask";
            leaf address {
              type string;
            }
            leaf mask {
              type string;
            }
          }
          list vrf {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            list address-list {
              // NCS patched for predictable order
              ordered-by user;
              key "address mask";
              leaf address {
                type string;
              }
              leaf mask {
                type string;
              }
            }
          }
        }
      }
      uses ncs_template_ipv4-ipv6-common-grouping;
      leaf source-route {
        type empty;
      }
    }
    container ipv6 {
      leaf unicast-routing {
        type empty;
      }
      container access-list {
        list named-acl {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          list rule {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            leaf line {
              type string;
            }
          }
        }
      }
      container multicast {
        container rpf {
          container backoff {
            leaf initial {
              type string;
            }
            leaf max-backoff-delay {
              type string;
            }
          }
          leaf use-bgp {
            type empty;
          }
        }
      }
      uses ncs_template_ipv4-ipv6-common-grouping;
      container mobile {
        list pmipv6-domain {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          list nai {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf network {
              type string;
            }
            leaf service {
              type string;
            }
            leaf customer {
              type string;
            }
          }
        }
        list pmipv6-lma {
          // NCS patched for predictable order
          ordered-by user;
          key "name domain";
          leaf name {
            type string;
          }
          leaf domain {
            type string;
          }
          container aaa {
            container accounting {
              presence true;
              leaf interim {
                type string;
              }
            }
          }
          container dynamic {
            container mag {
              leaf learning {
                type empty;
              }
            }
          }
          container enforce {
            leaf heartbeat-to-mag {
              type empty;
            }
          }
          container mobility-service {
            container mobile-local-loop {
              presence true;
              list customer {
                // NCS patched for predictable order
                ordered-by user;
                key "name vrf";
                leaf name {
                  type string;
                }
                leaf vrf {
                  type string;
                }
                container gre-key {
                  leaf symmetric {
                    type string;
                  }
                }
                container network {
                  choice network-choice {
                    leaf authorized {
                      type string;
                    }
                    leaf unauthorized {
                      type empty;
                    }
                  }
                }
                container auth-option {
                  leaf spi {
                    type string;
                  }
                  container key {
                    leaf ascii {
                      type string;
                    }
                  }
                }
                container transport {
                  list vrf {
                    // NCS patched for predictable order
                    ordered-by user;
                    key name;
                    leaf name {
                      type string;
                    }
                    container address {
                      leaf ipv4 {
                        type string;
                      }
                      leaf ipv6 {
                        type string;
                      }
                    }
                  }
                }
                container heartbeat {
                  leaf interval {
                    type string;
                  }
                  leaf retries {
                    type string;
                  }
                  leaf timeout {
                    type string;
                  }
                }
              }
            }
          }
        }
      }
    }
    container frequency {
      container synchronization {
        container quality {
          container itu-t {
            leaf option {
              type string;
            }
            leaf generation {
              // NCS drop when statement
              type string;
            }
          }
        }
        container clock-interface {
          leaf timing-mode {
            type string;
          }
        }
        container system {
          leaf timing-mode {
            type string;
          }
        }
        container log {
          leaf selection {
            type string;
          }
        }
      }
    }
    container cem {
      list class {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf payload {
          type string;
        }
        leaf dejitter {
          type string;
        }
      }
    }
    container error-disable {
      container recovery {
        container cause {
          container udld-timeout {
            presence true;
            leaf interval {
              type string;
            }
          }
        }
      }
    }
    container vtp {
      leaf mode {
        type string;
      }
    }
    container arp {
      uses ncs_template_arp-grouping;
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_arp-grouping;
      }
    }
    container cinetd {
      leaf rate-limit {
        type string;
      }
    }
    container xxml {
      tailf:alt-name xml;
      container tty-agent {
        container agent {
          container tty {
            presence true;
            container iteration {
              leaf off {
                type empty;
              }
            }
            leaf ipv4 {
              type string;
            }
            leaf ipv6 {
              type string;
            }
          }
        }
      }
      container ssl-agent {
        container agent {
          container ssl {
            presence true;
            container session {
              leaf timeout {
                type string;
              }
            }
          }
        }
      }
      container other-agent {
        container agent {
          presence true;
          leaf ipv4 {
            type string;
          }
          leaf ipv6 {
            type string;
          }
          container iteration {
            choice iteration-choice {
              container on {
                leaf size {
                  type string;
                }
              }
              leaf off {
                type empty;
              }
            }
          }
        }
      }
    }
    container switch {
      container virtual {
        list domain {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf mac-address {
            type string;
          }
          container switch {
            leaf mode {
              type string;
            }
            list nr {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf location {
                type string;
              }
              leaf priority {
                type string;
              }
            }
          }
        }
      }
    }
    container key {
      list chain {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list key {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container accept-lifetime {
            leaf local {
              type empty;
            }
            leaf start-time {
              type string;
            }
            leaf start-month {
              type string;
            }
            leaf start-day {
              type string;
            }
            leaf start-year {
              type string;
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  type string;
                }
              }
              case stop-time {
                leaf stop-time {
                  type string;
                }
                leaf stop-month {
                  type string;
                }
                leaf stop-day {
                  type string;
                }
                leaf stop-year {
                  type string;
                }
              }
              case infinite {
                leaf infinite {
                  type empty;
                }
              }
            }
          }
          container key-string {
            leaf type {
              type string;
            }
            leaf password {
              type string;
            }
          }
          container send-lifetime {
            leaf local {
              type empty;
            }
            leaf start-time {
              type string;
            }
            leaf start-month {
              type string;
            }
            leaf start-day {
              type string;
            }
            leaf start-year {
              type string;
            }
            choice stop-choice {
              case duration {
                leaf duration {
                  type string;
                }
              }
              case stop-time {
                leaf stop-time {
                  type string;
                }
                leaf stop-month {
                  type string;
                }
                leaf stop-day {
                  type string;
                }
                leaf stop-year {
                  type string;
                }
              }
              case infinite {
                leaf infinite {
                  type empty;
                }
              }
            }
          }
          leaf cryptographic-algorithm {
            type string;
          }
        }
      }
    }
    container dhcp {
      container ipv4 {
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf relay {
            type empty;
          }
          leaf profile {
            type string;
          }
        }
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key "name type";
          leaf name {
            type string;
          }
          leaf type {
            type string;
          }
          leaf pool {
            type string;
          }
          leaf-list default-router {
            // NCS patched for predictable order
            ordered-by user;
            type string;
          }
          container giaddr {
            leaf policy {
              type string;
            }
          }
          list helper-address {
            // NCS patched for predictable order
            ordered-by user;
            key "vrf address";
            leaf vrf {
              type string;
            }
            leaf address {
              type string;
            }
          }
          container relay {
            container information {
              leaf check {
                type empty;
              }
              container option {
                presence true;
                leaf vpn {
                  type empty;
                }
                leaf vpn-mode {
                  type string;
                }
                leaf allow-untrusted {
                  type empty;
                }
              }
              leaf policy {
                type string;
              }
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key "name type";
          leaf name {
            type string;
          }
          leaf type {
            type string;
          }
          leaf profile {
            type string;
          }
        }
      }
      container ipv6 {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key "name type";
          leaf name {
            type string;
          }
          leaf type {
            type string;
          }
          leaf profile {
            type string;
          }
          leaf destination {
            // NCS drop when statement
            type string;
          }
        }
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key "name type";
          leaf name {
            type string;
          }
          leaf type {
            type string;
          }
          list helper-address {
            // NCS patched for predictable order
            ordered-by user;
            key "vrf address";
            leaf vrf {
              type string;
            }
            leaf address {
              type string;
            }
          }
        }
      }
    }
    container snmp-server {
      container ifmib {
        container ifalias {
          leaf long {
            type empty;
          }
        }
        container stats {
          leaf cache {
            type empty;
          }
        }
      }
      leaf packetsize {
        type string;
      }
      leaf ifindex {
        type string;
      }
      container engineID {
        leaf local {
          type string;
        }
        list remote {
          // NCS patched for predictable order
          ordered-by user;
          key ip-address;
          leaf ip-address {
            type string;
          }
          leaf engine-id {
            type string;
          }
          leaf udp-port {
            type string;
          }
        }
      }
      uses ncs_template_snmp-server-host-grouping;
      container entityindex {
        leaf persist {
          type empty;
        }
      }
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_snmp-server-host-grouping;
        list context {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      container ipv4 {
        choice ipv4-choice {
          leaf dscp {
            type string;
          }
          leaf precedence {
            type string;
          }
        }
      }
      container context {
        list context-list {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      list community {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf view {
          type string;
        }
        choice access-choice {
          leaf RO {
            type empty;
          }
          leaf RW {
            type empty;
          }
        }
        choice owner-choice {
          leaf SDROwner {
            type empty;
          }
          leaf SystemOwner {
            type empty;
          }
        }
        leaf access-list-type {
          type string;
        }
        leaf access-list {
          type string;
        }
      }
      container community-map {
        list community-map-list {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf context {
            type string;
          }
        }
      }
      leaf queue-length {
        type string;
      }
      leaf trap-timeout {
        type string;
        // NCS drop default statement
      }
      leaf contact {
        type string;
      }
      leaf location {
        type string;
      }
      container trap-source {
        uses ncs_template_interface-name-grouping;
        leaf port {
          type string;
        }
      }
      container overload-control {
        leaf drop-time {
          type string;
        }
        leaf throttle-rate {
          type string;
        }
      }
      container mroutemib {
        leaf send-all-vrf {
          type empty;
        }
      }
      container mibs {
        container cbqosmib {
          leaf persist {
            type empty;
          }
          container cache {
            container refresh {
              leaf time {
                type string;
              }
            }
            container service-policy {
              leaf count {
                type string;
              }
            }
          }
        }
      }
      container trap {
        leaf link {
          type string;
        }
      }
      list user {
        // NCS patched for predictable order
        ordered-by user;
        key username;
        leaf username {
          type string;
        }
        leaf groupname {
          type string;
        }
        leaf version {
          type string;
        }
        container auth {
          // NCS drop when statement
          leaf level {
            type string;
          }
          choice password-choice {
            leaf auth-password {
              type string;
            }
            leaf clear {
              type string;
            }
            leaf encrypted {
              type string;
            }
          }
        }
        container priv {
          // NCS drop when statement
          choice priv-level {
            leaf threedes {
              tailf:alt-name 3des;
              type empty;
            }
            leaf aes {
              type string;
            }
            leaf des56 {
              type empty;
            }
          }
          choice password-choice {
            leaf priv-password {
              type string;
            }
            leaf clear {
              type string;
            }
            leaf encrypted {
              type string;
            }
          }
        }
        leaf access-list {
          type string;
        }
        choice owner-choice {
          leaf SDROwner {
            type empty;
          }
          leaf SystemOwner {
            type empty;
          }
        }
      }
      list view {
        // NCS patched for predictable order
        ordered-by user;
        key view-name;
        leaf view-name {
          type string;
        }
        list oid-list {
          // NCS patched for predictable order
          ordered-by user;
          key oid-tree;
          leaf oid-tree {
            type string;
          }
          leaf viewmode {
            type string;
          }
        }
      }
      list group {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        choice version-choice {
          leaf v1 {
            type empty;
          }
          leaf v2c {
            type empty;
          }
          leaf v3 {
            type string;
          }
        }
        leaf read {
          type string;
        }
        leaf write {
          type string;
        }
        leaf notify {
          type string;
        }
        leaf context {
          type string;
        }
        leaf access-list-type {
          type string;
        }
        leaf access-list {
          type string;
        }
      }
      container interface {
        list subset {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf regular-expression {
            type string;
          }
          container notification {
            container linkupdown {
              presence true;
              leaf disable {
                type empty;
              }
            }
          }
        }
        list interface-name {
          // NCS patched for predictable order
          ordered-by user;
          key ifname;
          leaf ifname {
            type string;
          }
          container index {
            leaf persistence {
              type empty;
            }
          }
          container notification {
            container linkupdown {
              presence true;
              leaf disable {
                type empty;
              }
            }
          }
        }
      }
      leaf chassis-id {
        type string;
      }
      container traps {
        list traps-list {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
      }
      container timeouts {
        leaf subagent {
          type string;
        }
      }
    }
    container srlg {
      presence true;
    }
    list monitor-session {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      choice type-choice {
        leaf ethernet {
          type empty;
        }
        leaf ipv4 {
          type empty;
        }
        leaf ipv6 {
          type empty;
        }
      }
      container destination {
        choice destination-choice {
          leaf pseudowire {
            type empty;
          }
          container interface {
            uses ncs_template_interface-name-grouping;
          }
        }
      }
    }
    container spanning-tree {
      container extend {
        leaf system-id {
          type empty;
        }
      }
      leaf mode {
        type string;
      }
      container mst {
        list range {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf priority {
            type string;
          }
        }
        list protocol-instance {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf name {
            type string;
          }
          container maximum {
            leaf age {
              type string;
            }
            leaf hops {
              type string;
            }
          }
          leaf revision {
            type string;
          }
          container bringup {
            container delay {
              leaf for {
                type string;
              }
              leaf unit {
                type string;
              }
            }
          }
          leaf forward-delay {
            type string;
          }
          container transmit {
            leaf hold-count {
              type string;
            }
          }
          leaf provider-bridge {
            type empty;
          }
          list instance {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            leaf priority {
              type string;
            }
            leaf-list vlan-ids {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
          }
          list interface {
            // NCS patched for predictable order
            ordered-by user;
            key ifname;
            leaf ifname {
              type string;
            }
            container portfast {
              presence true;
            }
            list instance {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf cost {
                type string;
              }
            }
            leaf link-type {
              type string;
            }
            leaf external-cost {
              type string;
            }
          }
        }
      }
      leaf portfast {
        type string;
      }
      list mstag {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key ifname;
          leaf ifname {
            type string;
          }
          leaf name {
            type string;
          }
          leaf port-id {
            type string;
          }
          leaf bridge-id {
            type string;
          }
          list instance {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            container cost {
              leaf cost-value {
                type string;
              }
              leaf startup-value {
                type string;
              }
            }
            leaf-list vlan-ids {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
            container root-id {
              leaf root-id-value {
                type string;
              }
              leaf startup-value {
                type string;
              }
            }
            container priority {
              leaf priority-value {
                type string;
              }
              leaf startup-value {
                type string;
              }
            }
            container root-priority {
              leaf priority-value {
                type string;
              }
              leaf startup-value {
                type string;
              }
            }
          }
        }
      }
      list repag {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key ifname;
          leaf ifname {
            type string;
          }
        }
      }
    }
    container redundancy {
      container iccp {
        list group {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container mlacp {
            leaf node {
              type string;
            }
            container system {
              leaf mac {
                type string;
              }
              leaf priority {
                type string;
              }
            }
            container connect {
              leaf timeout {
                type string;
              }
            }
          }
          container member {
            leaf neighbor {
              type string;
            }
          }
          container mode {
            leaf singleton {
              type empty;
            }
          }
          container backbone {
            list interface {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
            }
          }
          container isolation {
            leaf recovery-delay {
              type string;
            }
          }
          container nv {
            container satellite {
              leaf system-mac {
                type string;
              }
            }
          }
        }
      }
    }
    container ssh {
      container client {
        container source-interface {
          uses ncs_template_interface-name-grouping;
        }
        leaf dscp {
          type string;
        }
      }
      container server {
        leaf dscp {
          type string;
        }
        leaf logging {
          type empty;
        }
        container netconf {
          presence true;
          leaf port {
            type string;
          }
        }
        leaf rate-limit {
          type string;
        }
        leaf session-limit {
          type string;
        }
        leaf v2 {
          type empty;
        }
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container ipv4 {
            leaf access-list {
              type string;
            }
          }
          container ipv6 {
            leaf access-list {
              type string;
            }
          }
        }
      }
      leaf timeout {
        type string;
      }
    }
    list track {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      container type {
        container rtr {
          leaf ipsla-no {
            type string;
          }
          leaf reachability {
            type empty;
          }
        }
        container line-protocol {
          container state {
            container interface {
              uses ncs_template_interface-name-grouping;
            }
          }
        }
      }
    }
    container ipsla {
      list operation {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        container type {
          list udp {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            uses ncs_template_ipsla-operation-type-grouping;
          }
          list icmp {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            uses ncs_template_ipsla-operation-type-grouping;
          }
          container mpls {
            list lsp {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              uses ncs_template_ipsla-operation-type-grouping;
            }
          }
        }
      }
      container reaction {
        list operation {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container react {
            container connection-loss {
              uses ncs_template_ipsla-reaction-operation-react-grouping;
            }
            container packet-loss {
              container dest-to-source {
                uses ncs_template_ipsla-reaction-operation-react-grouping;
              }
              container source-to-dest {
                uses ncs_template_ipsla-reaction-operation-react-grouping;
              }
            }
            container timeout {
              container action {
                leaf logging {
                  type empty;
                }
                leaf trigger {
                  type empty;
                }
              }
              container threshold {
                container type {
                  choice type-choice {
                    leaf consecutive {
                      type string;
                    }
                    leaf immediate {
                      type empty;
                    }
                    container xofy {
                      leaf x-value {
                        type string;
                      }
                      leaf y-value {
                        type string;
                      }
                    }
                  }
                }
              }
            }
            container rtt {
              uses ncs_template_ipsla-reaction-operation-react-grouping;
            }
          }
        }
      }
      container schedule {
        list operation {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container start-time {
            choice start-time-choice {
              leaf after {
                type string;
              }
              leaf now {
                type empty;
              }
              leaf pending {
                type empty;
              }
              leaf time {
                type string;
              }
            }
          }
          leaf life {
            type string;
          }
          leaf ageout {
            type string;
          }
        }
      }
      leaf key-chain {
        type string;
      }
      container responder {
        presence true;
        container twamp {
          presence true;
        }
      }
    }
    container performance-mgmt {
      container statistics {
        container interface {
          container basic-counters {
            list template {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              uses ncs_template_performance-mgmt-grouping;
            }
          }
          container data-rates {
            list template {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              uses ncs_template_performance-mgmt-grouping;
            }
          }
        }
      }
      container thresholds {
        container node {
          container cpu {
            list template {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              uses ncs_template_performance-mgmt-grouping;
            }
          }
          container process {
            list template {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              uses ncs_template_performance-mgmt-grouping;
            }
          }
        }
      }
      list apply {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container vlan {
      container internal {
        container allocation {
          leaf policy {
            type string;
          }
        }
      }
      container access-log {
        leaf maxflow {
          type string;
        }
        leaf ratelimit {
          type string;
        }
        leaf threshold {
          type string;
        }
      }
      list vlan-list {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        leaf name {
          type string;
        }
        leaf uni-vlan {
          type string;
        }
      }
    }
    container lldp {
      presence true;
      leaf holdtime {
        type string;
      }
      leaf reinit {
        type string;
      }
      leaf run {
        type empty;
      }
      leaf timer {
        type string;
      }
    }
    container igmp {
      container snooping {
        list profile {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf system-ip-address {
            type string;
          }
          container internal-querier {
            presence true;
          }
        }
      }
    }
    container switch-fabric {
      list service-policy {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container lpts {
      container pifib {
        container hardware {
          container police {
            uses ncs_template_lpts-grouping;
            list location {
              // NCS patched for predictable order
              ordered-by user;
              key node-id;
              leaf node-id {
                type string;
              }
              uses ncs_template_lpts-grouping;
            }
          }
        }
      }
      container punt {
        container police {
          list location {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
          }
        }
      }
    }
    container hw-module {
      container qos {
        container pol-gran {
          leaf granularity {
            type string;
          }
          leaf location {
            type string;
          }
        }
        container queue-auto-defrag {
          container disable {
            list location {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
            }
          }
        }
        container account {
          container layer2 {
            container encapsulation {
              choice encapsulation-choice {
                leaf arpa {
                  type empty;
                }
                leaf dot1q {
                  type empty;
                }
                leaf length {
                  type string;
                }
              }
              leaf location {
                type string;
              }
            }
          }
        }
        container multicast {
          leaf location {
            type string;
          }
          container priorityq {
            container disable {
              leaf location {
                type string;
              }
            }
          }
        }
      }
      container pse {
        container allocate {
          container tcam {
            list location {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              list region {
                // NCS patched for predictable order
                ordered-by user;
                key "name num";
                leaf name {
                  type string;
                }
                leaf num {
                  type string;
                }
              }
            }
          }
        }
      }
      container mac-move {
        leaf police-mode {
          type string;
        }
      }
      container location {
        list location-breakout-list {
          // NCS patched for predictable order
          ordered-by user;
          key "id port";
          leaf id {
            type string;
          }
          leaf port {
            type string;
          }
          leaf breakout {
            type string;
          }
        }
      }
      list subslot {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf cardtype {
          type string;
        }
        container shutdown {
          presence true;
          leaf option {
            type string;
          }
        }
      }
      list port {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        list srp {
          // NCS patched for predictable order
          ordered-by user;
          key location;
          leaf location {
            type string;
          }
          leaf spa-bay {
            type string;
          }
        }
      }
    }
    list class-map {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf type {
        type string;
      }
      leaf prematch {
        type string;
        // NCS drop default statement
      }
      leaf description {
        type string;
      }
      container match {
        uses ncs_template_class-map-match-grouping;
        container not {
          uses ncs_template_class-map-match-grouping;
        }
      }
    }
    list policy-map {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf type {
        type string;
      }
      leaf description {
        type string;
      }
      container class {
        list class-ref {
          // NCS patched for predictable order
          ordered-by user;
          key map;
          leaf map {
            type string;
          }
          uses ncs_template_policy-map-class-grouping;
        }
        list class-default {
          // NCS patched for predictable order
          ordered-by user;
          key map;
          leaf map {
            type string;
          }
          uses ncs_template_policy-map-class-grouping;
        }
      }
    }
    container crypto;
    container flow {
      list exporter-map {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container version {
          container v9 {
            container options {
              container interface-table {
                presence true;
                leaf timeout {
                  type string;
                }
              }
              container sampler-table {
                presence true;
                leaf timeout {
                  type string;
                }
              }
            }
            container template {
              leaf timeout {
                type string;
              }
              container data {
                leaf timeout {
                  type string;
                }
              }
              container options {
                leaf timeout {
                  type string;
                }
              }
            }
          }
        }
        leaf dscp {
          type string;
        }
        container transport {
          leaf udp {
            type string;
          }
        }
        container source {
          uses ncs_template_interface-name-grouping;
        }
        container destination {
          leaf address {
            type string;
          }
          leaf vrf {
            type string;
          }
        }
      }
      list monitor-map {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container record {
          choice record-choice {
            container ipv4 {
              presence true;
              choice record-ipv4-choice {
                leaf peer-as {
                  type empty;
                }
                leaf destination-tos {
                  type empty;
                }
              }
            }
            container ipv6 {
              presence true;
              leaf peer-as {
                type empty;
              }
            }
            container mpls {
              presence true;
              leaf fields-fmt {
                type string;
              }
              leaf labels {
                type string;
              }
            }
          }
        }
        leaf exporter {
          type string;
        }
        container cache {
          leaf entries {
            type string;
          }
          container timeout {
            leaf active {
              type string;
            }
            leaf inactive {
              type string;
            }
            leaf rate-limit {
              type string;
            }
            leaf update {
              type string;
            }
          }
        }
      }
    }
    list sampler-map {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      container random {
        leaf number-of-packets {
          type string;
        }
        leaf out-of {
          type empty;
        }
        leaf sampling-interval {
          type string;
        }
      }
    }
    container clock-interface {
      list sync {
        // NCS patched for predictable order
        ordered-by user;
        key "id location";
        leaf id {
          type string;
        }
        leaf shutdown {
          type empty;
        }
        leaf location {
          type string;
        }
        container port-parameters {
          container bits-input {
            leaf mode {
              type string;
            }
            leaf mode1 {
              type string;
            }
            leaf sa {
              // NCS drop when statement
              type string;
            }
            leaf mode2 {
              type string;
            }
          }
        }
        container frequency {
          container synchronization {
            container selection {
              leaf input {
                type empty;
              }
            }
            leaf priority {
              type string;
            }
            leaf wait-to-restore {
              type string;
            }
            container ssm {
              leaf disable {
                type empty;
              }
            }
            container quality {
              container receive {
                uses ncs_template_freqsync-quality-grouping;
              }
            }
          }
        }
      }
    }
    container l2 {
      list vfi {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf mode {
          type string;
        }
        container vpn {
          leaf id {
            type string;
          }
        }
      }
    }
    container auto {
      leaf qos {
        type string;
      }
    }
    container ethernet-services {
      list access-list {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list rule {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf line {
            type string;
          }
        }
      }
    }
    container interface {
      uses ncs_template_interface-grouping;
      container preconfigure {
        uses ncs_template_interface-grouping;
      }
    }
    container controller {
      uses ncs_template_controller-grouping;
      container preconfigure {
        uses ncs_template_controller-grouping;
      }
    }
    container evpn {
      list evi {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        container bgp {
          presence true;
          leaf rd {
            type string;
          }
          container route-target {
            list import {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              leaf stitching {
                type empty;
              }
            }
            list export {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              leaf stitching {
                type empty;
              }
            }
          }
        }
        container network-controller {
          leaf vni {
            type string;
          }
          list host {
            // NCS patched for predictable order
            ordered-by user;
            key mac;
            leaf mac {
              type string;
            }
            leaf ip-address {
              type string;
            }
            container ipv4 {
              leaf address {
                type string;
              }
            }
            leaf switch {
              type string;
            }
            container gateway {
              leaf ip-address {
                type string;
              }
              leaf netmask {
                type string;
              }
            }
            leaf vlan {
              type string;
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container ethernet-segment {
            container identifier {
              list type {
                // NCS patched for predictable order
                ordered-by user;
                key esi;
                leaf esi {
                  type string;
                }
                leaf value {
                  type string;
                }
              }
            }
            container bgp {
              leaf route-target {
                type string;
              }
            }
          }
        }
      }
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container ethernet-segment {
          container identifier {
            list type {
              // NCS patched for predictable order
              ordered-by user;
              key esi-type;
              leaf esi-type {
                type string;
              }
              leaf esi-identifier {
                type string;
              }
            }
          }
          container bgp {
            leaf route-target {
              type string;
            }
          }
        }
      }
    }
    container l2vpn {
      presence true;
      leaf router-id {
        type string;
      }
      leaf nsr {
        type empty;
      }
      leaf pw-grouping {
        type empty;
      }
      container pw-status {
        presence true;
        leaf disable {
          type empty;
        }
      }
      container autodiscovery {
        container bgp {
          container signaling-protocol {
            container bgp {
              container mtu {
                container mismatch {
                  leaf ignore {
                    type empty;
                  }
                }
              }
            }
          }
        }
      }
      container logging {
        presence true;
        leaf nsr {
          type empty;
        }
        container pseudowire {
          presence true;
          leaf status {
            type empty;
          }
        }
      }
      container load-balancing {
        leaf flow {
          type string;
        }
      }
      leaf capability {
        type string;
      }
      leaf ignore-mtu-mismatch {
        type empty;
      }
      container redundancy {
        container iccp {
          list group {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            container multi-homing {
              leaf node-id {
                type string;
              }
            }
            list interface {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              container primary {
                leaf-list vlan {
                  // NCS patched for predictable order
                  ordered-by user;
                  type string;
                }
              }
              container secondary {
                leaf-list vlan {
                  // NCS patched for predictable order
                  ordered-by user;
                  type string;
                }
              }
              container recovery {
                leaf delay {
                  type string;
                }
              }
            }
          }
        }
      }
      list pw-class {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container encapsulation {
          container l2tpv3 {
            leaf protocol {
              type string;
            }
            leaf ttl {
              type string;
            }
          }
          container mpls {
            leaf control-word {
              type empty;
            }
            container protocol {
              leaf ldp {
                type empty;
              }
            }
            container vccv {
              container verification-type {
                leaf none {
                  type empty;
                }
              }
            }
            container transport-mode {
              choice transport-mode-choice {
                leaf ethernet {
                  type empty;
                }
                container vlan {
                  presence true;
                  leaf passthrough {
                    type empty;
                  }
                }
              }
            }
            container preferred-path {
              leaf interface {
                type string;
              }
              leaf id {
                type string;
              }
              leaf fallback {
                type string;
              }
            }
            container ipv4 {
              leaf source {
                type string;
              }
            }
            container redundancy {
              leaf one-way {
                type empty;
              }
            }
          }
        }
      }
      container xconnect {
        list group {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          list mp2mp {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf vpn-id {
              type string;
            }
            leaf mtu {
              type string;
            }
            leaf l2-encapsulation {
              type string;
            }
            container control-word {
              leaf disable {
                type empty;
              }
            }
            container autodiscovery {
              container bgp {
                leaf rd {
                  type string;
                }
                uses ncs_template_route-target-import-export-grouping;
                container signaling-protocol {
                  container bgp {
                    list ce-id {
                      // NCS patched for predictable order
                      ordered-by user;
                      key id;
                      leaf id {
                        type string;
                      }
                      list interface {
                        // NCS patched for predictable order
                        ordered-by user;
                        key name;
                        leaf name {
                          type string;
                        }
                        leaf remote-ce-id {
                          type string;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          list p2p {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            list interface {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
            }
            leaf monitor-session {
              type string;
            }
            list neighbor {
              // NCS patched for predictable order
              ordered-by user;
              key "address pw-id";
              leaf address {
                type string;
              }
              leaf pw-id {
                type string;
              }
              leaf ip-version {
                type string;
              }
              container mpls {
                container static {
                  container label {
                    leaf local {
                      type string;
                    }
                    leaf remote {
                      type string;
                    }
                  }
                }
              }
              leaf pw-class {
                type string;
              }
              container tag-impose {
                leaf vlan {
                  type string;
                }
              }
              container l2tp {
                container static {
                  container local {
                    container cookie {
                      leaf size {
                        type string;
                      }
                      container value {
                        // NCS drop when statement
                        leaf value-1 {
                          type string;
                        }
                        leaf value-2 {
                          // NCS drop when statement
                          type string;
                        }
                      }
                    }
                  }
                  container remote {
                    container cookie {
                      leaf size {
                        type string;
                      }
                      container value {
                        // NCS drop when statement
                        leaf value-1 {
                          type string;
                        }
                        leaf value-2 {
                          // NCS drop when statement
                          type string;
                        }
                      }
                    }
                  }
                }
              }
              leaf source {
                type string;
              }
              container backup {
                list neighbor {
                  // NCS patched for predictable order
                  ordered-by user;
                  key "address pw-id";
                  leaf address {
                    type string;
                  }
                  leaf pw-id {
                    type string;
                  }
                  leaf pw-class {
                    type string;
                  }
                }
              }
            }
            leaf description {
              type string;
            }
          }
        }
      }
      container bridge {
        list group {
          // NCS patched for predictable order
          ordered-by user;
          key group-name;
          leaf group-name {
            type string;
          }
          list bridge-domain {
            // NCS patched for predictable order
            ordered-by user;
            key bridge-domain-name;
            leaf bridge-domain-name {
              type string;
            }
            list evi {
              // NCS patched for predictable order
              ordered-by user;
              // NCS drop max-elements statement
              key id;
              leaf id {
                type string;
              }
            }
            uses ncs_template_storm-control-grouping;
            list interface {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              container mac {
                uses ncs_template_l2vpn-bridge-domain-mac-grouping;
              }
              uses ncs_template_storm-control-grouping;
              container igmp {
                container snooping {
                  leaf profile {
                    type string;
                  }
                }
              }
              container split-horizon {
                leaf group {
                  type empty;
                }
              }
            }
            list neighbor {
              // NCS patched for predictable order
              ordered-by user;
              key "address pw-id";
              leaf address {
                type string;
              }
              leaf pw-id {
                type string;
              }
              container mpls {
                container static {
                  container label {
                    leaf local {
                      type string;
                    }
                    leaf remote {
                      type string;
                    }
                  }
                }
              }
              leaf pw-class {
                type string;
              }
              uses ncs_template_storm-control-grouping;
              container split-horizon {
                leaf group {
                  type empty;
                }
              }
            }
            container mac {
              container aging {
                leaf time {
                  type string;
                }
              }
              uses ncs_template_l2vpn-bridge-domain-mac-grouping;
              container withdraw {
                choice withdraw-choice {
                  leaf state-down {
                    type empty;
                  }
                  leaf optimize {
                    type empty;
                  }
                  leaf disable {
                    type empty;
                  }
                }
              }
            }
            leaf mtu {
              type string;
            }
            container flooding {
              leaf disable {
                type empty;
              }
              container unknown-unicast {
                leaf disable {
                  type empty;
                }
              }
            }
            container igmp {
              container snooping {
                leaf profile {
                  type string;
                }
              }
            }
            container routed {
              list interface {
                // NCS patched for predictable order
                ordered-by user;
                key name;
                leaf name {
                  type string;
                }
              }
            }
            container member {
              list vni {
                // NCS patched for predictable order
                ordered-by user;
                // NCS drop max-elements statement
                key id;
                leaf id {
                  type string;
                }
              }
            }
            list vfi {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              leaf vpn-id {
                type string;
              }
              container autodiscovery {
                container bgp {
                  leaf rd {
                    type string;
                  }
                  uses ncs_template_route-target-import-export-grouping;
                  container signaling-protocol {
                    container bgp {
                      presence true;
                      leaf ve-id {
                        type string;
                      }
                      leaf ve-range {
                        type string;
                      }
                    }
                    container ldp {
                      presence true;
                      leaf vpls-id {
                        type string;
                      }
                    }
                  }
                }
              }
              list neighbor {
                // NCS patched for predictable order
                ordered-by user;
                key "address pw-id";
                leaf address {
                  type string;
                }
                leaf pw-id {
                  type string;
                }
                leaf pw-class {
                  type string;
                }
              }
            }
            container evpn {
              leaf evi {
                type string;
              }
            }
            container pbb {
              list edge {
                // NCS patched for predictable order
                ordered-by user;
                key "i-sid core-bridge";
                leaf i-sid {
                  type string;
                }
                leaf core-bridge {
                  type string;
                }
                leaf unknown-unicast-bmac {
                  type string;
                }
              }
              container core {
                presence true;
                container evpn {
                  leaf evi {
                    type string;
                  }
                }
              }
            }
          }
        }
      }
    }
    container extcommunity-set {
      list rt {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_set-list-grouping;
      }
      list soo {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_set-list-grouping;
      }
    }
    list rd-set {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_set-list-grouping;
    }
    list prefix-set {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_set-list-grouping;
    }
    list as-path-set {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_set-list-grouping;
      leaf ios-regex {
        type string;
      }
    }
    list community-set {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      uses ncs_template_set-list-grouping;
    }
    container rpl {
      leaf editor {
        type string;
      }
    }
    list route-policy {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      leaf value {
        type string;
      }
    }
    list generic-interface-list {
      // NCS patched for predictable order
      ordered-by user;
      key name;
      leaf name {
        type string;
      }
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container ospf {
      leaf name-lookup {
        type empty;
      }
    }
    container router-convergence {
      list collect-diagnostics {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
      }
    }
    container router {
      container static {
        uses ncs_template_router-static-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-static-grouping;
        }
      }
      container igmp {
        presence true;
        uses ncs_template_router-igmp-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-igmp-grouping;
        }
      }
      container isis {
        list tag {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container set-overload-bit {
            presence true;
            leaf on-startup {
              type string;
            }
            list level-list {
              // NCS patched for predictable order
              ordered-by user;
              key level;
              leaf level {
                type string;
              }
              leaf on-startup {
                type string;
              }
              container advertise {
                leaf external {
                  type empty;
                }
                leaf interlevel {
                  type empty;
                }
              }
            }
            container suppress {
              leaf external {
                type empty;
              }
              leaf interlevel {
                type empty;
              }
            }
          }
          leaf is-type {
            type string;
          }
          list net {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
          }
          container nsf {
            choice nsf-choice {
              container advertise {
                leaf holdtime {
                  type string;
                }
              }
              leaf cisco {
                type empty;
              }
              leaf ietf {
                type empty;
              }
              container interface {
                leaf wait {
                  type string;
                }
              }
              leaf interval {
                type string;
              }
              container t3 {
                choice t3-choice {
                  leaf adjacency {
                    type empty;
                  }
                  leaf manual {
                    type string;
                  }
                }
              }
            }
            leaf lifetime {
              type string;
            }
            leaf interface-timer {
              type string;
            }
          }
          leaf nsr {
            type empty;
          }
          container distribute {
            container bgp-ls {
              leaf level {
                type string;
              }
              leaf throttle {
                type string;
              }
            }
          }
          container log {
            container adjacency {
              leaf changes {
                type empty;
              }
            }
            container pdu {
              leaf drops {
                type empty;
              }
            }
          }
          container lsp-gen-interval {
            leaf maximum-wait {
              type string;
            }
            leaf initial-wait {
              type string;
            }
            leaf secondary-wait {
              type string;
            }
          }
          leaf lsp-check-interval {
            type string;
          }
          leaf lsp-refresh-interval {
            type string;
          }
          leaf lsp-mtu {
            type string;
          }
          container lsp-password {
            leaf auth-type {
              type string;
            }
            leaf enc-type {
              type string;
            }
            choice password-choice {
              leaf password {
                type string;
              }
              leaf keychain {
                type string;
              }
            }
            leaf level {
              type string;
            }
            leaf send-only {
              type empty;
            }
            leaf snp {
              type empty;
            }
          }
          leaf max-lsp-lifetime {
            type string;
          }
          container address-family {
            container ipv4 {
              container unicast {
                presence true;
                uses ncs_template_router-isis-common-grouping;
                uses ncs_template_router-isis-common-af-grouping;
                uses ncs_template_router-isis-af-grouping;
              }
            }
            container ipv6 {
              container unicast {
                presence true;
                uses ncs_template_router-isis-common-grouping;
                uses ncs_template_router-isis-common-af-grouping;
                uses ncs_template_router-isis-af-grouping;
              }
            }
          }
          list interface {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf interface-type {
              type string;
            }
            leaf circuit-type {
              type string;
            }
            container bfd {
              leaf fast-detect {
                type string;
              }
              leaf minimum-interval {
                type string;
              }
              leaf multiplier {
                type string;
              }
            }
            leaf priority {
              type string;
            }
            leaf point-to-point {
              type empty;
            }
            container lsp-interval {
              leaf milliseconds {
                type string;
              }
            }
            leaf hello-interval {
              type string;
            }
            leaf hello-padding {
              type string;
            }
            container hello-password {
              choice authentication-choice {
                leaf keychain {
                  type string;
                }
                leaf accept {
                  type empty;
                }
                leaf hmac-md5 {
                  type empty;
                }
                leaf text {
                  type empty;
                }
              }
              choice password-choice {
                leaf clear {
                  // NCS drop when statement
                  type string;
                }
                leaf encrypted {
                  // NCS drop when statement
                  type string;
                }
                leaf password {
                  // NCS drop when statement
                  type string;
                }
              }
              leaf level {
                type string;
              }
              leaf send-only {
                type empty;
              }
            }
            container link-down {
              leaf fast-detect {
                type empty;
              }
            }
            container address-family {
              container ipv4 {
                container unicast {
                  presence true;
                  uses ncs_template_router-isis-common-af-grouping;
                  uses ncs_template_router-isis-if-af-grouping;
                }
              }
              container ipv6 {
                container unicast {
                  presence true;
                  uses ncs_template_router-isis-common-af-grouping;
                  uses ncs_template_router-isis-if-af-grouping;
                }
              }
            }
          }
          container authentication {
            container key-chain {
              leaf ref {
                type string;
              }
              leaf level {
                type string;
              }
            }
            container mode {
              choice mode-choice {
                container md5 {
                  presence true;
                  leaf level {
                    type string;
                  }
                }
                container text {
                  presence true;
                  leaf level {
                    type string;
                  }
                }
              }
            }
          }
          container bfd {
            leaf all-interfaces {
              type empty;
            }
            leaf check-ctrl-plane-failure {
              type empty;
            }
          }
          container mpls {
            leaf ldp {
              type string;
            }
            container traffic-eng {
              leaf level-1 {
                type empty;
              }
              leaf level-2 {
                type empty;
              }
              leaf multicast-intact {
                type empty;
              }
              leaf router-id {
                type empty;
              }
              leaf scanner {
                type empty;
              }
            }
          }
          uses ncs_template_router-isis-common-grouping;
        }
      }
      list ospf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_router-ospf-authentication-grouping;
        uses ncs_template_router-ospf-grouping;
        container mpls {
          container traffic-eng {
            container router-id {
              uses ncs_template_interface-name-grouping;
            }
            leaf multicast-intact {
              type empty;
            }
          }
          container ldp {
            leaf sync {
              type empty;
            }
            leaf auto-config {
              type empty;
            }
          }
        }
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-ospf-grouping;
        }
      }
      list ospfv3 {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_router-ospfv3-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-ospfv3-grouping;
        }
      }
      container bgp {
        list bgp-no-instance {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          uses ncs_template_router-bgp-grouping;
        }
        list bgp-instance {
          // NCS patched for predictable order
          ordered-by user;
          key "id instance";
          leaf id {
            type string;
          }
          leaf instance {
            type string;
          }
          uses ncs_template_router-bgp-grouping;
        }
      }
      container mld {
        uses ncs_template_router-mld-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-mld-grouping;
        }
      }
      container pim {
        uses ncs_template_router-pim-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-pim-grouping;
        }
      }
      container rip {
        presence true;
        uses ncs_template_router-rip-grouping;
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          uses ncs_template_router-rip-grouping;
        }
      }
      container vrrp {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container bfd {
            leaf minimum-interval {
              type string;
            }
            leaf multiplier {
              type string;
            }
          }
          container address-family {
            container ipv4 {
              list vrrp {
                // NCS patched for predictable order
                ordered-by user;
                key id;
                leaf id {
                  type string;
                }
                uses ncs_template_router-vrrp-if-af-vrrp-grouping;
                list address {
                  // NCS patched for predictable order
                  ordered-by user;
                  key ip;
                  leaf ip {
                    type string;
                  }
                  leaf secondary {
                    type empty;
                  }
                }
                container bfd {
                  container fast-detect {
                    container peer {
                      leaf ipv4 {
                        type string;
                      }
                    }
                  }
                }
                leaf text-authentication {
                  type string;
                }
              }
            }
            container ipv6 {
              list vrrp {
                // NCS patched for predictable order
                ordered-by user;
                key id;
                leaf id {
                  type string;
                }
                uses ncs_template_router-vrrp-if-af-vrrp-grouping;
                container address {
                  list global {
                    // NCS patched for predictable order
                    ordered-by user;
                    key ip;
                    leaf ip {
                      type string;
                    }
                  }
                  leaf linklocal {
                    type string;
                  }
                }
              }
            }
          }
        }
      }
      container hsrp {
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container hsrp {
            container bfd {
              leaf minimum-interval {
                type string;
              }
              leaf multiplier {
                type string;
              }
            }
            container delay {
              leaf minimum {
                type string;
              }
              leaf reload {
                type string;
              }
            }
            leaf use-bia {
              type empty;
            }
          }
          container address-family {
            container ipv4 {
              container hsrp {
                uses ncs_template_router-hsrp-ipv4-group-grouping;
              }
              container hsrp-version1-list {
                list hsrp {
                  // NCS patched for predictable order
                  ordered-by user;
                  key id;
                  leaf id {
                    type string;
                  }
                  uses ncs_template_router-hsrp-ipv4-group-grouping;
                }
              }
              container hsrp-version2 {
                container hsrp {
                  list version {
                    // NCS patched for predictable order
                    ordered-by user;
                    key version;
                    leaf version {
                      type string;
                    }
                    uses ncs_template_router-hsrp-ipv4-group-grouping;
                  }
                }
              }
              container hsrp-version2-list {
                list hsrp {
                  // NCS patched for predictable order
                  ordered-by user;
                  key "id version";
                  leaf id {
                    type string;
                  }
                  leaf version {
                    type string;
                  }
                  uses ncs_template_router-hsrp-ipv4-group-grouping;
                }
              }
            }
            container ipv6 {
              container hsrp {
                uses ncs_template_router-hsrp-ipv6-group-grouping;
              }
              container hsrp-version1-list {
                list hsrp {
                  // NCS patched for predictable order
                  ordered-by user;
                  key id;
                  leaf id {
                    type string;
                  }
                  uses ncs_template_router-hsrp-ipv6-group-grouping;
                }
              }
              container hsrp-version2 {
                container hsrp {
                  list version {
                    // NCS patched for predictable order
                    ordered-by user;
                    key version;
                    leaf version {
                      type string;
                    }
                    uses ncs_template_router-hsrp-ipv6-group-grouping;
                  }
                }
              }
              container hsrp-version2-list {
                list hsrp {
                  // NCS patched for predictable order
                  ordered-by user;
                  key "id version";
                  leaf id {
                    type string;
                  }
                  leaf version {
                    type string;
                  }
                  uses ncs_template_router-hsrp-ipv6-group-grouping;
                }
              }
            }
          }
        }
      }
    }
    container service-policy {
      leaf-list apply-order {
        // NCS patched for predictable order
        ordered-by user;
        type string;
      }
    }
    container service-function-chaining {
      list sf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list locator {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container transport {
            container vxlan-gpe {
              container source-address {
                leaf ipv4 {
                  type string;
                }
              }
              container destination-address {
                leaf ipv4 {
                  type string;
                }
              }
              leaf source-port {
                type string;
              }
              leaf vni {
                type string;
              }
            }
          }
        }
      }
      list sff {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list locator {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          container transport {
            container vxlan-gpe {
              container source-address {
                leaf ipv4 {
                  type string;
                }
              }
              container destination-address {
                leaf ipv4 {
                  type string;
                }
              }
              leaf source-port {
                type string;
              }
              leaf vni {
                type string;
              }
            }
          }
        }
      }
      list metadata {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list type {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf format {
            type string;
          }
          leaf tenant-id {
            type string;
          }
        }
      }
      list path {
        // NCS patched for predictable order
        ordered-by user;
        key id;
        leaf id {
          type string;
        }
        list terminate-list {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf terminate {
            type empty;
          }
          leaf metadata-disposition {
            type string;
          }
          container default-action {
            container redirect {
              container ipv4 {
                container nexthop {
                  choice nexthop-choice {
                    leaf address {
                      type string;
                    }
                    leaf vrf {
                      type string;
                    }
                  }
                }
              }
            }
          }
        }
        list sf-list {
          // NCS patched for predictable order
          ordered-by user;
          key "id sf";
          leaf id {
            type string;
          }
          leaf sf {
            type string;
          }
        }
        list sff-list {
          // NCS patched for predictable order
          ordered-by user;
          key "id sff";
          leaf id {
            type string;
          }
          leaf sff {
            type string;
          }
        }
      }
      list metadata-disposition {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        list type {
          // NCS patched for predictable order
          ordered-by user;
          key id;
          leaf id {
            type string;
          }
          leaf format {
            type string;
          }
          list match-entry {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            container tenant-id {
              leaf id {
                type string;
              }
              container redirect {
                container ipv4 {
                  container nexthop {
                    choice nexthop-choice {
                      leaf address {
                        type string;
                      }
                      leaf vrf {
                        type string;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    container flowspec {
      container local-install {
        leaf interface-all {
          type empty;
        }
      }
      container address-family {
        container ipv4 {
          container local-install {
            leaf interface-all {
              type empty;
            }
          }
          list service-policy {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            leaf type {
              type string;
            }
          }
        }
      }
    }
    container rsvp {
      list interface {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        container bandwidth {
          presence true;
          choice bandwidth-choice {
            case percentage-case {
              leaf percentage {
                type empty;
              }
              leaf total-reservable-percent {
                type string;
              }
            }
            case rsvp-case {
              leaf total-reservable {
                type string;
              }
              leaf total-reservable-unit {
                // NCS drop when statement
                type string;
              }
            }
            case rdm-case {
              container rdm {
                leaf bc0 {
                  type string;
                }
                leaf largest-reservable-flow {
                  type string;
                }
                leaf bc1 {
                  type string;
                }
              }
            }
          }
        }
        container signalling {
          leaf dscp {
            type string;
          }
        }
      }
      container signalling {
        container graceful-restart {
          presence true;
        }
        container message-bundle {
          leaf disable {
            type empty;
          }
        }
      }
      container authentication {
        container key-source {
          leaf key-chain {
            type string;
          }
        }
      }
    }
    container lmp {
      presence true;
      container gmpls {
        container optical-uni {
          list controller {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            container neighbor {
              leaf name {
                type string;
              }
              container link-id {
                container ipv4 {
                  leaf unicast {
                    type string;
                  }
                }
              }
              container interface-id {
                leaf unnumbered {
                  type string;
                }
              }
            }
            container link-id {
              container ipv4 {
                leaf unicast {
                  type string;
                }
              }
            }
          }
          list neighbor {
            // NCS patched for predictable order
            ordered-by user;
            key name;
            leaf name {
              type string;
            }
            container ipcc {
              leaf routed {
                type empty;
              }
            }
            container router-id {
              container ipv4 {
                leaf unicast {
                  type string;
                }
              }
            }
          }
          container router-id {
            container ipv4 {
              leaf unicast {
                type string;
              }
            }
          }
        }
      }
    }
    container mpls {
      container label {
        leaf protocol {
          type string;
        }
        container range {
          leaf min {
            type string;
          }
          leaf max {
            type string;
          }
        }
      }
      container traffic-eng {
        container auto-tunnel {
          container p2p {
            container tunnel-id {
              leaf min {
                type string;
              }
              leaf max {
                type string;
              }
            }
          }
          container pcc {
            container tunnel-id {
              leaf min {
                type string;
              }
              leaf max {
                type string;
              }
            }
          }
          container backup {
            container timers {
              container removal {
                leaf unused {
                  type string;
                }
              }
            }
            container tunnel-id {
              leaf min {
                type string;
              }
              leaf max {
                type string;
              }
            }
          }
          container mesh {
            list group {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf onehop {
                type empty;
              }
              leaf attribute-set {
                type string;
              }
              leaf destination-list {
                type string;
              }
            }
            container tunnel-id {
              leaf min {
                type string;
              }
              leaf max {
                type string;
              }
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container bfd {
            leaf fast-detect {
              type empty;
            }
          }
          container auto-tunnel {
            container backup {
              presence true;
              container exclude {
                container srlg {
                  presence true;
                  leaf preferred {
                    type empty;
                  }
                }
              }
            }
          }
          leaf attribute-flags {
            type string;
          }
          container attribute-names {
            leaf name {
              type string;
            }
            list index {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf name {
                type string;
              }
            }
          }
          leaf admin-weight {
            type string;
          }
          container backup-path {
            leaf tunnel-te {
              type string;
            }
          }
        }
        container pce {
          container peer {
            container source {
              leaf ipv4 {
                type string;
              }
            }
            list ipv4 {
              // NCS patched for predictable order
              ordered-by user;
              key address;
              leaf address {
                type string;
              }
            }
          }
          leaf segment-routing {
            type empty;
          }
          container stateful-client {
            leaf instantiation {
              type empty;
            }
            leaf cisco-extension {
              type empty;
            }
          }
        }
        container logging {
          container events {
            leaf all {
              type empty;
            }
            leaf frr-protection {
              type empty;
            }
            leaf preemption {
              type empty;
            }
          }
        }
        list affinity-map {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          leaf value {
            type string;
          }
          leaf bit-position {
            type string;
          }
        }
        list attribute-set {
          // NCS patched for predictable order
          ordered-by user;
          key "type pathname";
          leaf type {
            type string;
          }
          leaf pathname {
            type string;
          }
          container affinity {
            leaf value {
              type string;
            }
            leaf mask {
              type string;
            }
          }
          container logging {
            container events {
              uses ncs_template_lsp-status-grouping;
            }
          }
          leaf bandwidth {
            type string;
          }
          container priority {
            leaf setup {
              type string;
            }
            leaf hold {
              type string;
            }
          }
          container signalled-bandwidth {
            leaf bw-req {
              type string;
            }
            leaf class-type {
              type string;
            }
          }
          container autoroute {
            leaf announce {
              type empty;
            }
          }
          container fast-reroute {
            presence true;
            leaf-list protect {
              // NCS patched for predictable order
              ordered-by user;
              type string;
            }
          }
          container policy-class {
            presence true;
            leaf value {
              type string;
            }
          }
          leaf record-route {
            type empty;
          }
          leaf forward-class {
            type string;
          }
          list exclude {
            // NCS patched for predictable order
            ordered-by user;
            key "source destination tunnel-id extended-tunnel-id";
            leaf mode {
              type string;
            }
            leaf lsp {
              type empty;
            }
            leaf source {
              type string;
            }
            leaf destination {
              type string;
            }
            leaf tunnel-id {
              type string;
            }
            leaf extended-tunnel-id {
              type string;
            }
            leaf lsp-id {
              type string;
            }
          }
          container pce {
            presence true;
          }
          container path-selection {
            presence true;
            leaf metric {
              type string;
            }
          }
        }
        container ds-te {
          container mode {
            leaf ietf {
              type empty;
            }
          }
          container te-classes {
            list te-class {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              choice te-class-choice {
                leaf unused {
                  type empty;
                }
                case used {
                  leaf class-type {
                    type string;
                  }
                  leaf priority {
                    type string;
                  }
                }
              }
            }
          }
        }
        container soft-preemption {
          leaf timeout {
            type string;
          }
        }
        container auto-bw {
          container collect {
            leaf frequency {
              type string;
            }
          }
        }
        container reoptimize {
          leaf value {
            type string;
          }
          container timers {
            container delay {
              leaf cleanup {
                type string;
              }
              leaf installation {
                type string;
              }
              leaf after-frr {
                type string;
              }
              leaf path-protection {
                type string;
              }
            }
          }
        }
        container bfd {
          container lsp {
            container head {
              container down-action {
                leaf resetup {
                  type empty;
                }
                container reoptimize {
                  leaf timeout {
                    type string;
                  }
                }
              }
            }
          }
          leaf multiplier {
            type string;
          }
          leaf minimum-interval {
            type string;
          }
        }
        container fast-reroute {
          container timers {
            leaf promotion {
              type string;
            }
          }
        }
        container link-management {
          container timers {
            container preemption-delay {
              leaf bundle-capacity {
                type string;
              }
            }
          }
        }
        container signalling {
          container advertise {
            leaf explicit-null {
              type empty;
            }
          }
        }
        container gmpls {
          container optical-uni {
            list controller {
              // NCS patched for predictable order
              ordered-by user;
              key name;
              leaf name {
                type string;
              }
              container tunnel-properties {
                leaf signalled-name {
                  type string;
                }
                leaf tunnel-id {
                  type string;
                }
                container destination {
                  container ipv4 {
                    leaf unicast {
                      type string;
                    }
                  }
                }
                list path-option {
                  // NCS patched for predictable order
                  ordered-by user;
                  key id;
                  leaf id {
                    type string;
                  }
                  choice path-choice {
                    case explicit {
                      leaf explicit {
                        type empty;
                      }
                      leaf identifier {
                        type string;
                      }
                      leaf name {
                        // NCS drop when statement
                        type string;
                      }
                    }
                    case no-ero {
                      leaf no-ero {
                        type empty;
                      }
                    }
                  }
                  leaf signaled-label {
                    type string;
                  }
                  leaf wavelength {
                    // NCS drop when statement
                    type string;
                  }
                  leaf xro-attribute-set {
                    type string;
                  }
                  leaf lockdown {
                    type empty;
                  }
                  leaf verbatim {
                    type empty;
                  }
                }
              }
            }
          }
        }
        container load-share {
          leaf unequal {
            type empty;
          }
        }
      }
      container ldp {
        container log {
          leaf adjacency {
            type empty;
          }
          leaf neighbor {
            type empty;
          }
          leaf graceful-restart {
            type empty;
          }
          leaf session-protection {
            type empty;
          }
          leaf nsr {
            type empty;
          }
        }
        leaf nsr {
          type empty;
        }
        container graceful-restart {
          presence true;
        }
        leaf holdtime {
          type string;
        }
        container session {
          container protection {
            presence true;
            leaf duration {
              type string;
            }
          }
        }
        container signalling {
          leaf dscp {
            type string;
          }
        }
        container igp {
          container sync {
            container delay-on-proc-restart {
              container delay {
                leaf on-proc-restart {
                  type string;
                }
              }
            }
            container delay {
              leaf on-session-up {
                type empty;
              }
              leaf delay-value {
                type string;
              }
            }
          }
        }
        container mldp {
          container logging {
            leaf notifications {
              type empty;
            }
            leaf internal {
              type empty;
            }
          }
          container address-family {
            container ipv4 {
              container make-before-break {
                leaf delay {
                  type string;
                }
              }
              container recursive-fec {
                presence true;
              }
            }
          }
        }
        container discovery {
          container instance-tlv {
            leaf disable {
              type empty;
            }
          }
          container hello {
            leaf holdtime {
              type string;
            }
            leaf interval {
              type string;
            }
          }
          container targeted-hello {
            container accept {
              presence true;
              leaf from {
                type string;
              }
            }
          }
        }
        leaf router-id {
          type string;
        }
        container neighbor {
          container password {
            leaf type {
              type string;
            }
            leaf password {
              type string;
            }
          }
          list neighbor-list {
            // NCS patched for predictable order
            ordered-by user;
            key id;
            leaf id {
              type string;
            }
            container password {
              choice password-choice {
                leaf disable {
                  type empty;
                }
                leaf clear {
                  type string;
                }
                leaf encrypted {
                  type string;
                }
              }
            }
          }
        }
        container redistribute {
          container bgp {
            leaf as {
              type string;
            }
          }
        }
        container password {
          container option {
            leaf sequence-nr {
              type string;
            }
            leaf for {
              type string;
            }
            leaf enc-type {
              type string;
            }
            leaf password {
              type string;
            }
          }
          container required {
            presence true;
            leaf for {
              type string;
            }
          }
        }
        container label {
          container allocate {
            leaf for {
              type string;
            }
          }
          container advertise {
            leaf disable {
              type empty;
            }
            leaf for {
              type string;
            }
          }
        }
        container address-family {
          container ipv4 {
            container discovery {
              container targeted-hello {
                container accept {
                  presence true;
                  leaf from {
                    type string;
                  }
                }
              }
            }
            container label {
              container local {
                container allocate {
                  leaf for {
                    type string;
                  }
                }
                container advertise {
                  container explicit-null {
                    presence true;
                    leaf for {
                      type string;
                    }
                    leaf to {
                      type string;
                    }
                  }
                  leaf disable {
                    type empty;
                  }
                  list for {
                    // NCS patched for predictable order
                    ordered-by user;
                    key acl;
                    leaf acl {
                      type string;
                    }
                  }
                }
              }
            }
            container traffic-eng {
              container auto-tunnel {
                container mesh {
                  list group {
                    // NCS patched for predictable order
                    ordered-by user;
                    key id;
                    leaf id {
                      type string;
                    }
                  }
                }
              }
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container address-family {
            container ipv4 {
              container mldp {
                leaf disable {
                  type empty;
                }
              }
            }
          }
        }
      }
      container oam {
        container echo {
          leaf revision {
            type string;
          }
          leaf disable-vendor-extension {
            type empty;
          }
        }
      }
      container static {
        list ipv4 {
          // NCS patched for predictable order
          ordered-by user;
          key "address mask interface";
          leaf address {
            type string;
          }
          leaf mask {
            type string;
          }
          leaf interface {
            type string;
          }
          leaf nexthop {
            type string;
          }
          choice label-choice {
            leaf label {
              type string;
            }
            leaf ipv4-explicit-null {
              type empty;
            }
            leaf ipv6-explicit-null {
              type empty;
            }
            container pop {
              presence true;
              choice pop-choice {
                leaf labelled {
                  type empty;
                }
                leaf unlabelled {
                  type empty;
                }
              }
            }
          }
        }
        list interface {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
        }
        container address-family {
          list ipv4 {
            // NCS patched for predictable order
            ordered-by user;
            key af-modifier;
            leaf af-modifier {
              type string;
            }
            list local-label {
              // NCS patched for predictable order
              ordered-by user;
              key id;
              leaf id {
                type string;
              }
              leaf allocate {
                type empty;
              }
              leaf per-prefix {
                type string;
              }
              container forward {
                list path {
                  // NCS patched for predictable order
                  ordered-by user;
                  key id;
                  leaf id {
                    type string;
                  }
                  leaf nexthop {
                    type string;
                  }
                  leaf nexthop-address {
                    type string;
                  }
                  leaf out-label {
                    type string;
                  }
                }
              }
            }
          }
        }
        list vrf {
          // NCS patched for predictable order
          ordered-by user;
          key name;
          leaf name {
            type string;
          }
          container address-family {
            list ipv4 {
              // NCS patched for predictable order
              ordered-by user;
              key af-modifier;
              leaf af-modifier {
                type string;
              }
              list local-label {
                // NCS patched for predictable order
                ordered-by user;
                key id;
                leaf id {
                  type string;
                }
                leaf allocate {
                  type empty;
                }
                choice allocate-choice {
                  leaf per-prefix {
                    type string;
                  }
                  leaf per-vrf {
                    type empty;
                  }
                }
                container forward {
                  // NCS drop when statement
                  list path {
                    // NCS patched for predictable order
                    ordered-by user;
                    key id;
                    leaf id {
                      type string;
                    }
                    leaf pop-and-lookup {
                      type empty;
                    }
                  }
                }
              }
            }
          }
        }
      }
      container ip-ttl-propagate {
        container disable {
          presence true;
          leaf disable-type {
            type string;
          }
        }
      }
    }
    container segment-routing {
      container global-block {
        leaf lower-bound {
          type string;
        }
        leaf upper-bound {
          type string;
        }
      }
      container mapping-server {
        container prefix-sid-map {
          container address-family {
            container ipv4 {
              list prefix {
                // NCS patched for predictable order
                ordered-by user;
                key prefix;
                leaf prefix {
                  type string;
                }
                leaf SID-interval {
                  type string;
                }
                leaf range {
                  type string;
                }
              }
            }
          }
        }
      }
    }
    container multicast-routing {
      uses ncs_template_multicast-routing-grouping;
      list vrf {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        uses ncs_template_multicast-routing-grouping;
      }
    }
    container alias {
      list alias-list {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf line {
          type string;
        }
      }
      list exec {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf line {
          type string;
        }
      }
      list config {
        // NCS patched for predictable order
        ordered-by user;
        key name;
        leaf name {
          type string;
        }
        leaf line {
          type string;
        }
      }
    }
    container cached-show {
      container version {
        leaf version {
          type string;
        }
        leaf model {
          type string;
        }
      }
    }
    leaf xyzroot {
      type string;
      // NCS drop default statement
    }
  }
}
